
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>controllers: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/dell/csm-operator/controllers/acc_controller.go (89.3%)</option>
				
				<option value="file1">github.com/dell/csm-operator/controllers/csm_controller.go (87.9%)</option>
				
				<option value="file2">github.com/dell/csm-operator/pkg/logger/logger.go (100.0%)</option>
				
				<option value="file3">github.com/dell/csm-operator/pkg/resources/configmap/configmap.go (100.0%)</option>
				
				<option value="file4">github.com/dell/csm-operator/pkg/resources/csidriver/csidriver.go (100.0%)</option>
				
				<option value="file5">github.com/dell/csm-operator/pkg/resources/daemonset/daemonset.go (100.0%)</option>
				
				<option value="file6">github.com/dell/csm-operator/pkg/resources/deployment/deployment.go (100.0%)</option>
				
				<option value="file7">github.com/dell/csm-operator/pkg/resources/rbac/clusterrole.go (94.7%)</option>
				
				<option value="file8">github.com/dell/csm-operator/pkg/resources/rbac/rolebindings.go (100.0%)</option>
				
				<option value="file9">github.com/dell/csm-operator/pkg/resources/serviceaccount/serviceaccount.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">//  Copyright © 2023 Dell Inc. or its subsidiaries. All Rights Reserved.
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//       http://www.apache.org/licenses/LICENSE-2.0
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package controllers

import (
        "context"
        "fmt"
        "os"
        "path/filepath"
        "strconv"
        "strings"
        "sync"
        "sync/atomic"
        "time"

        "k8s.io/apimachinery/pkg/runtime"
        ctrl "sigs.k8s.io/controller-runtime"
        crclient "sigs.k8s.io/controller-runtime/pkg/client"

        csmv1 "github.com/dell/csm-operator/api/v1"
        "github.com/dell/csm-operator/pkg/constants"
        "github.com/dell/csm-operator/pkg/logger"

        "github.com/dell/csm-operator/pkg/utils"
        "go.uber.org/zap"

        k8serror "k8s.io/apimachinery/pkg/api/errors"
        t1 "k8s.io/apimachinery/pkg/types"
        sinformer "k8s.io/client-go/informers"
        "k8s.io/client-go/kubernetes"
        "k8s.io/client-go/tools/cache"
        "k8s.io/client-go/tools/record"
        "sigs.k8s.io/controller-runtime/pkg/controller"
        "sigs.k8s.io/controller-runtime/pkg/event"
        "sigs.k8s.io/controller-runtime/pkg/predicate"
        "sigs.k8s.io/controller-runtime/pkg/ratelimiter"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"

        appsv1 "k8s.io/api/apps/v1"
        corev1 "k8s.io/api/core/v1"
)

const (
        // AccManifest - deployment resources for Apex Connectivity Client
        AccManifest string = "statefulset.yaml"

        // AccNamespace - deployment namespace
        AccNamespace string = "&lt;NAMESPACE&gt;"

        // AggregatorURLDefault - default aggregator location
        AggregatorURLDefault string = "connect-into.dell.com"

        // AggregatorURL - tag for specifying aggregator endpoint
        AggregatorURL string = "&lt;AGGREGATOR_URL&gt;"

        // CaCertOption - tag for specifying if cacert option is used
        CaCertOption string = "&lt;CACERT_OPTION&gt;"

        // CaCertFlag - cacert option
        CaCertFlag string = "--cacert"

        // CaCerts - tag for specifying --cacert value
        CaCerts string = "&lt;CACERTS&gt;"

        // CaCertsList - cert locations for aggregator and loadbalancer
        CaCertsList string = "/opt/dellemc/certs/loadbalancer_root_ca_cert.crt,/opt/dellemc/certs/aggregator_internal_root_ca_cert.crt"

        // ConnectivityClientContainerName - name of the DCM client container
        ConnectivityClientContainerName string = "connectivity-client-docker-k8s"

        // ConnectivityClientContainerImage - tag for DCM client image
        ConnectivityClientContainerImage string = "&lt;CONNECTIVITY_CLIENT_IMAGE&gt;"

        // KubernetesProxySidecarName - name of proxy sidecar container
        KubernetesProxySidecarName string = "kubernetes-proxy"

        // KubernetesProxySidecarImage - tag for proxy image
        KubernetesProxySidecarImage string = "&lt;KUBERNETES_PROXY_IMAGE&gt;"

        // CertPersisterSidecarName - name of cert persister image
        CertPersisterSidecarName string = "cert-persister"

        // CertPersisterSidecarImage - name of cert persister image
        CertPersisterSidecarImage string = "&lt;CERT_PERSISTER_IMAGE&gt;"

        // AccInitContainerName - name of init container image
        AccInitContainerName string = "connectivity-client-init"

        // AccInitContainerImage - tag for init container image
        AccInitContainerImage string = "&lt;ACC_INIT_CONTAINER_IMAGE&gt;"

        // BrownfieldManifest - manifest for brownfield role/rolebinding creation
        BrownfieldManifest string = "brownfield-onboard.yaml"
)

// ApexConnectivityClientReconciler reconciles a ApexConnectivityClient object
type ApexConnectivityClientReconciler struct {
        // controller runtime client, responsible for create, delete, update, get etc.
        crclient.Client
        // k8s client, implements client-go/kubernetes interface, responsible for apply, which
        // client.Client does not provides
        K8sClient     kubernetes.Interface
        Scheme        *runtime.Scheme
        Log           *zap.SugaredLogger
        Config        utils.OperatorConfig
        updateCount   int32
        trcID         string
        EventRecorder record.EventRecorder
}

const (
        // AccMetadataPrefix - prefix for all labels &amp; annotations
        AccMetadataPrefix = "storage.dell.com"

        // AccFinalizerName - the name of the finalizer
        AccFinalizerName = "finalizer.dell.com"
)

var (
        accdMutex           sync.RWMutex
        accConfigVersionKey = fmt.Sprintf("%s/%s", AccMetadataPrefix, "ApexConnectivityClientConfigVersion")

        // AccStopWatch - watcher stop handle
        AccStopWatch = make(chan struct{})
)

//+kubebuilder:rbac:groups=storage.dell.com,resources=apexconnectivityclients,verbs=get;list;watch;create;update;patch;delete
//+kubebuilder:rbac:groups=storage.dell.com,resources=apexconnectivityclients/status,verbs=get;update;patch
//+kubebuilder:rbac:groups=storage.dell.com,resources=apexconnectivityclients/finalizers,verbs=update
//+kubebuilder:rbac:groups=apps,resources=deployments,verbs=get;list;watch;create;update;patch;delete
//+kubebuilder:rbac:groups=core,resources=pods,verbs=get;list;watch
//+kubebuilder:rbac:groups=mobility.storage.dell.com,resources=backups,verbs=get;list;watch;create;update;patch;delete

// Reconcile is part of the main kubernetes reconciliation loop which aims to
// move the current state of the cluster closer to the desired state.
// TODO(user): Modify the Reconcile function to compare the state specified by
// the ApexConnectivityClient object against the actual cluster state, and then
// perform operations to make the cluster state reflect the state specified by
// the user.
//
// For more details, check Reconcile and its Result here:
// - https://pkg.go.dev/sigs.k8s.io/controller-runtime@v0.10.0/pkg/reconcile
func (r *ApexConnectivityClientReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) <span class="cov8" title="1">{
        r.IncrUpdateCount()
        r.trcID = fmt.Sprintf("%d", r.GetUpdateCount())
        name := req.Name + "-" + r.trcID
        ctx, log := logger.GetNewContextWithLogger(name)
        log.Info("################Starting Apex Connectivity Client Reconcile##############")
        acc := new(csmv1.ApexConnectivityClient)

        log.Infow("reconcile for", "Namespace", req.Namespace, "Name", req.Name, "Attempt", r.GetUpdateCount())

        // Fetch the ApexConnectivityClientReconciler instance
        err := r.Client.Get(ctx, req.NamespacedName, acc)
        if err != nil </span><span class="cov8" title="1">{
                if k8serror.IsNotFound(err) </span><span class="cov8" title="1">{
                        // Request object not found, could have been deleted after reconcile request.
                        // Owned objects are automatically garbage collected. For additional cleanup logic use finalizers.
                        // Return and don't requeue
                        return reconcile.Result{}, nil
                }</span>
                // Error reading the object - requeue the request.
                <span class="cov0" title="0">return reconcile.Result{}, nil</span>
        }

        <span class="cov8" title="1">op := &amp;utils.OperatorConfig{
                IsOpenShift:     r.Config.IsOpenShift,
                K8sVersion:      r.Config.K8sVersion,
                ConfigDirectory: r.Config.ConfigDirectory,
        }
        crc := r.GetClient()

        // perform prechecks
        err = r.PreChecks(ctx, acc, *op)
        if err != nil </span><span class="cov8" title="1">{
                acc.GetApexConnectivityClientStatus().State = constants.InvalidConfig
                r.EventRecorder.Event(acc, corev1.EventTypeWarning, csmv1.EventUpdated, fmt.Sprintf("Failed Prechecks: %s", err))
                return utils.HandleAccValidationError(ctx, acc, r, err)
        }</span>

        <span class="cov8" title="1">if acc.IsBeingDeleted() </span><span class="cov8" title="1">{
                log.Infow("Delete request", "acc", req.Namespace, "Name", req.Name)

                // check for force cleanup
                if acc.Spec.Client.ForceRemoveClient </span><span class="cov8" title="1">{
                        // remove all resources deployed from CR by operator
                        if err = DeployApexConnectivityClient(ctx, true, *op, *acc, crc); err != nil </span><span class="cov8" title="1">{
                                r.EventRecorder.Event(acc, corev1.EventTypeWarning, csmv1.EventDeleted, fmt.Sprintf("Failed to remove client: %s", err))
                                log.Errorw("remove client", "error", err.Error())
                                return ctrl.Result{}, fmt.Errorf("error when deleting client: %v", err)
                        }</span>
                }

                <span class="cov8" title="1">if err = r.removeFinalizer(ctx, acc); err != nil </span><span class="cov0" title="0">{
                        r.EventRecorder.Event(acc, corev1.EventTypeWarning, csmv1.EventDeleted, fmt.Sprintf("Failed to delete finalizer: %s", err))
                        log.Errorw("Remove Apex Connectivity Client finalizer", "error", err.Error())
                        return ctrl.Result{}, fmt.Errorf("error when handling finalizer: %v", err)
                }</span>
                <span class="cov8" title="1">r.EventRecorder.Event(acc, corev1.EventTypeNormal, csmv1.EventDeleted, "Object finalizer is deleted")

                return ctrl.Result{}, nil</span>
        }

        // Add finalizer
        <span class="cov8" title="1">if !acc.HasFinalizer(AccFinalizerName) </span><span class="cov8" title="1">{
                log.Infow("HandleFinalizer", "name", AccFinalizerName)
                if err = r.addFinalizer(ctx, acc); err != nil </span><span class="cov8" title="1">{
                        r.EventRecorder.Event(acc, corev1.EventTypeWarning, csmv1.EventUpdated, fmt.Sprintf("Failed to add finalizer: %s", err))
                        log.Errorw("HandleFinalizer", "error", err.Error())
                        return ctrl.Result{}, fmt.Errorf("error when adding finalizer: %v", err)
                }</span>
                <span class="cov0" title="0">r.EventRecorder.Event(acc, corev1.EventTypeNormal, csmv1.EventUpdated, "Object finalizer is added")</span>
        }

        <span class="cov8" title="1">oldStatus := acc.GetApexConnectivityClientStatus()

        // Set the driver annotation
        isUpdated := applyAccConfigVersionAnnotations(ctx, acc)
        if isUpdated </span><span class="cov8" title="1">{
                err = r.GetClient().Update(ctx, acc)
                if err != nil </span><span class="cov8" title="1">{
                        log.Error(err, "Failed to update CR with annotation")
                        return reconcile.Result{}, err
                }</span>
        }

        <span class="cov8" title="1">newStatus := acc.GetApexConnectivityClientStatus()
        _, err = utils.HandleAccSuccess(ctx, acc, r, newStatus, oldStatus)
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err, "Failed to update CR status")
        }</span>

        <span class="cov8" title="1">if err = DeployApexConnectivityClient(ctx, false, *op, *acc, crc); err == nil </span><span class="cov8" title="1">{
                r.EventRecorder.Eventf(acc, corev1.EventTypeNormal, csmv1.EventCompleted, "install/update storage component: %s completed OK", acc.Name)
                return utils.LogBannerAndReturn(reconcile.Result{}, nil)
        }</span>

        // Failed deployment
        <span class="cov0" title="0">r.EventRecorder.Eventf(acc, corev1.EventTypeWarning, csmv1.EventUpdated, "Failed install: %s", err.Error())

        return utils.LogBannerAndReturn(reconcile.Result{Requeue: true}, err)</span>
}

func (r *ApexConnectivityClientReconciler) ignoreUpdatePredicate() predicate.Predicate <span class="cov8" title="1">{
        return predicate.Funcs{
                UpdateFunc: func(e event.UpdateEvent) bool </span><span class="cov8" title="1">{
                        // Ignore updates to status in which case metadata.Generation does not change
                        return e.ObjectOld.GetGeneration() != e.ObjectNew.GetGeneration()
                }</span>,

                DeleteFunc: func(e event.DeleteEvent) bool <span class="cov8" title="1">{
                        // Evaluates to false if the object has been confirmed deleted.
                        return !e.DeleteStateUnknown
                }</span>,
        }
}

// StatefulSetForApexConnectivityClient returns a apexConnectivityClient StatefulSet object
func (r *ApexConnectivityClientReconciler) handleStatefulSetUpdate(oldObj interface{}, obj interface{}) <span class="cov8" title="1">{
        accdMutex.Lock()
        defer accdMutex.Unlock()

        old, _ := oldObj.(*appsv1.StatefulSet)
        d, _ := obj.(*appsv1.StatefulSet)
        name := d.Spec.Template.Labels[constants.AccLabel]
        key := name + "-" + fmt.Sprintf("%d", r.GetUpdateCount())
        ctx, log := logger.GetNewContextWithLogger(key)
        if name == "" </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">log.Debugw("statefulSet modified generation", d.Generation, old.Generation)

        desired := d.Status.Replicas
        available := d.Status.AvailableReplicas
        ready := d.Status.ReadyReplicas

        log.Infow("statefulSet", "desired", desired)
        log.Infow("statefulSet", "numberReady", ready)
        log.Infow("statefulSet", "available", available)

        ns := d.Namespace
        log.Debugw("statefulSet", "namespace", ns, "name", name)
        namespacedName := t1.NamespacedName{
                Name:      name,
                Namespace: ns,
        }

        acc := new(csmv1.ApexConnectivityClient)
        err := r.Client.Get(ctx, namespacedName, acc)
        if err != nil </span><span class="cov0" title="0">{
                log.Error("statefulSet get acc", "error", err.Error())
        }</span>

        <span class="cov8" title="1">newStatus := acc.GetApexConnectivityClientStatus()
        newStatus.ClientStatus.Available = strconv.Itoa(int(available))
        newStatus.ClientStatus.Desired = strconv.Itoa(int(desired))

        err = utils.UpdateAccStatus(ctx, acc, r, newStatus)
        if err != nil </span><span class="cov8" title="1">{
                log.Debugw("statefulSet status ", "pods", err.Error())
        }</span> else<span class="cov0" title="0"> {
                r.EventRecorder.Eventf(acc, corev1.EventTypeNormal, csmv1.EventCompleted, "Apex Connectivity Client running OK")
        }</span>
}

func (r *ApexConnectivityClientReconciler) handlePodsUpdate(_ interface{}, obj interface{}) <span class="cov8" title="1">{
        accdMutex.Lock()
        defer accdMutex.Unlock()

        p, _ := obj.(*corev1.Pod)
        name := p.GetLabels()[constants.AccLabel]
        ns := p.Namespace
        if name == "" </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">key := name + "-" + fmt.Sprintf("%d", r.GetUpdateCount())
        ctx, log := logger.GetNewContextWithLogger(key)

        if !p.ObjectMeta.DeletionTimestamp.IsZero() </span><span class="cov0" title="0">{
                log.Debugw("driver delete invoked", "stopping pod with name", p.Name)
                return
        }</span>
        <span class="cov8" title="1">log.Infow("pod modified for driver", "name", p.Name)

        namespacedName := t1.NamespacedName{
                Name:      name,
                Namespace: ns,
        }
        acc := new(csmv1.ApexConnectivityClient)
        err := r.Client.Get(ctx, namespacedName, acc)
        if err != nil </span><span class="cov0" title="0">{
                r.Log.Errorw("statefulset get acc", "error", err.Error())
        }</span>
        <span class="cov8" title="1">log.Infow("acc prev status ", "state", acc.Status)
        newStatus := acc.GetApexConnectivityClientStatus()

        err = utils.UpdateAccStatus(ctx, acc, r, newStatus)
        state := acc.GetApexConnectivityClientStatus().State
        stamp := fmt.Sprintf("at %d", time.Now().UnixNano())
        if state != "0" &amp;&amp; err != nil </span><span class="cov8" title="1">{
                log.Infow("pod status ", "state", err.Error())
                r.EventRecorder.Eventf(acc, corev1.EventTypeWarning, csmv1.EventUpdated, "%s Pod error details %s", stamp, err.Error())
        }</span> else<span class="cov0" title="0"> {
                r.EventRecorder.Eventf(acc, corev1.EventTypeNormal, csmv1.EventCompleted, "%s Apex Connectivity Client pods running OK", stamp)
        }</span>
}

// ClientContentWatch - watch updates on deployment and statefulset
func (r *ApexConnectivityClientReconciler) ClientContentWatch() error <span class="cov8" title="1">{
        sharedInformerFactory := sinformer.NewSharedInformerFactory(r.K8sClient, time.Duration(time.Hour))

        statefulSetInformer := sharedInformerFactory.Apps().V1().StatefulSets().Informer()
        _, err := statefulSetInformer.AddEventHandler(cache.ResourceEventHandlerFuncs{
                UpdateFunc: r.handleStatefulSetUpdate,
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ClientContentWatch failed adding event handler to statefulsetInformer: %v", err)
        }</span>

        <span class="cov8" title="1">podsInformer := sharedInformerFactory.Core().V1().Pods().Informer()
        _, err = podsInformer.AddEventHandler(cache.ResourceEventHandlerFuncs{
                UpdateFunc: r.handlePodsUpdate,
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ClientContentWatch failed adding event handler to podsInformer: %v", err)
        }</span>

        <span class="cov8" title="1">sharedInformerFactory.Start(AccStopWatch)
        return nil</span>
}

// SetupWithManager sets up the controller with the Manager.
func (r *ApexConnectivityClientReconciler) SetupWithManager(mgr ctrl.Manager, limiter ratelimiter.RateLimiter, maxReconcilers int) error <span class="cov8" title="1">{
        go r.ClientContentWatch()
        return ctrl.NewControllerManagedBy(mgr).
                For(&amp;csmv1.ApexConnectivityClient{}).
                WithEventFilter(r.ignoreUpdatePredicate()).
                WithOptions(controller.Options{
                        RateLimiter:             limiter,
                        MaxConcurrentReconciles: maxReconcilers,
                }).Complete(r)
}</span>

func (r *ApexConnectivityClientReconciler) removeFinalizer(ctx context.Context, instance *csmv1.ApexConnectivityClient) error <span class="cov8" title="1">{
        if !instance.HasFinalizer(AccFinalizerName) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">instance.SetFinalizers(nil)
        return r.Update(ctx, instance)</span>
}

func (r *ApexConnectivityClientReconciler) addFinalizer(ctx context.Context, instance *csmv1.ApexConnectivityClient) error <span class="cov8" title="1">{
        instance.SetFinalizers([]string{AccFinalizerName})
        instance.GetApexConnectivityClientStatus().State = constants.Creating
        return r.Update(ctx, instance)
}</span>

// PreChecks - validate input values
func (r *ApexConnectivityClientReconciler) PreChecks(ctx context.Context, cr *csmv1.ApexConnectivityClient, operatorConfig utils.OperatorConfig) error <span class="cov8" title="1">{
        log := logger.GetLogger(ctx)

        // Check if driver version is supported by doing a stat on a config file
        configFilePath := fmt.Sprintf("%s/clientconfig/%s/%s/upgrade-path.yaml", operatorConfig.ConfigDirectory, csmv1.DreadnoughtClient, cr.Spec.Client.ConfigVersion)
        log.Info(configFilePath)
        if _, err := os.Stat(configFilePath); os.IsNotExist(err) </span><span class="cov8" title="1">{
                return fmt.Errorf("%s %s not supported", csmv1.DreadnoughtClient, cr.Spec.Client.ConfigVersion)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func applyAccConfigVersionAnnotations(ctx context.Context, instance *csmv1.ApexConnectivityClient) bool <span class="cov8" title="1">{
        log := logger.GetLogger(ctx)

        // If client has not been initialized yet, we first annotate the client with the config version annotation

        annotations := instance.GetAnnotations()
        isUpdated := false
        if annotations == nil </span><span class="cov8" title="1">{
                annotations = make(map[string]string)
        }</span>
        <span class="cov8" title="1">if _, ok := annotations[accConfigVersionKey]; !ok </span><span class="cov8" title="1">{
                annotations[accConfigVersionKey] = instance.Spec.Client.ConfigVersion
                isUpdated = true
                instance.SetAnnotations(annotations)
                log.Infof("Installing storage component %s with config Version %s. Updating Annotations with Config Version",
                        instance.GetName(), instance.Spec.Client.ConfigVersion)
        }</span>
        <span class="cov8" title="1">return isUpdated</span>
}

// DeployApexConnectivityClient - perform deployment
func DeployApexConnectivityClient(ctx context.Context, isDeleting bool, operatorConfig utils.OperatorConfig, cr csmv1.ApexConnectivityClient, ctrlClient crclient.Client) error <span class="cov8" title="1">{
        log := logger.GetLogger(ctx)

        YamlString := ""
        ModifiedYamlString := ""
        deploymentPath := fmt.Sprintf("%s/clientconfig/%s/%s/%s", operatorConfig.ConfigDirectory, csmv1.DreadnoughtClient, cr.Spec.Client.ConfigVersion, AccManifest)
        buf, err := os.ReadFile(filepath.Clean(deploymentPath))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">YamlString = utils.ModifyCommonCRs(string(buf), cr)
        ModifiedYamlString = ModifyApexConnectivityClientCR(YamlString, cr)
        deployObjects, err := utils.GetModuleComponentObj([]byte(ModifiedYamlString))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for _, ctrlObj := range deployObjects </span><span class="cov8" title="1">{
                if isDeleting </span><span class="cov8" title="1">{
                        if err := utils.DeleteObject(ctx, ctrlObj, ctrlClient); err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                } else<span class="cov8" title="1"> {
                        if err := utils.ApplyObject(ctx, ctrlObj, ctrlClient); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov8" title="1">if err = utils.CreateBrownfieldRbac(ctx, operatorConfig, cr, ctrlClient, isDeleting); err != nil </span><span class="cov0" title="0">{
                log.Error(err, "error creating role/rolebindings")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ModifyApexConnectivityClientCR - update the custom resource
func ModifyApexConnectivityClientCR(yamlString string, cr csmv1.ApexConnectivityClient) string <span class="cov8" title="1">{
        namespace := ""
        aggregatorURL := AggregatorURLDefault
        connectivityClientImage := ""
        kubeProxyImage := ""
        certPersisterImage := ""
        accInitContainerImage := ""
        caCertFlag := ""
        caCertsList := ""

        namespace = cr.Namespace

        if cr.Spec.Client.ConnectionTarget != "" </span><span class="cov8" title="1">{
                aggregatorURL = string(cr.Spec.Client.ConnectionTarget)
        }</span>

        <span class="cov8" title="1">if cr.Spec.Client.UsePrivateCaCerts </span><span class="cov8" title="1">{
                caCertFlag = CaCertFlag
                caCertsList = CaCertsList
        }</span>

        <span class="cov8" title="1">if cr.Spec.Client.Common.Name == ConnectivityClientContainerName </span><span class="cov8" title="1">{
                if cr.Spec.Client.Common.Image != "" </span><span class="cov8" title="1">{
                        connectivityClientImage = string(cr.Spec.Client.Common.Image)
                }</span>
        }

        <span class="cov8" title="1">for _, initContainer := range cr.Spec.Client.InitContainers </span><span class="cov8" title="1">{
                if initContainer.Name == AccInitContainerName </span><span class="cov8" title="1">{
                        if initContainer.Image != "" </span><span class="cov8" title="1">{
                                accInitContainerImage = string(initContainer.Image)
                        }</span>
                }
        }

        <span class="cov8" title="1">for _, sidecar := range cr.Spec.Client.SideCars </span><span class="cov8" title="1">{
                if sidecar.Name == KubernetesProxySidecarName </span><span class="cov8" title="1">{
                        if sidecar.Image != "" </span><span class="cov8" title="1">{
                                kubeProxyImage = string(sidecar.Image)
                        }</span>
                }
                <span class="cov8" title="1">if sidecar.Name == CertPersisterSidecarName </span><span class="cov8" title="1">{
                        if sidecar.Image != "" </span><span class="cov8" title="1">{
                                certPersisterImage = string(sidecar.Image)
                        }</span>
                }
        }

        <span class="cov8" title="1">yamlString = strings.ReplaceAll(yamlString, AccNamespace, namespace)
        yamlString = strings.ReplaceAll(yamlString, AggregatorURL, aggregatorURL)
        yamlString = strings.ReplaceAll(yamlString, CaCertOption, caCertFlag)
        yamlString = strings.ReplaceAll(yamlString, CaCerts, caCertsList)
        yamlString = strings.ReplaceAll(yamlString, ConnectivityClientContainerImage, connectivityClientImage)
        yamlString = strings.ReplaceAll(yamlString, AccInitContainerImage, accInitContainerImage)
        yamlString = strings.ReplaceAll(yamlString, KubernetesProxySidecarImage, kubeProxyImage)
        yamlString = strings.ReplaceAll(yamlString, CertPersisterSidecarImage, certPersisterImage)
        return yamlString</span>
}

// GetClient - returns the split client
func (r *ApexConnectivityClientReconciler) GetClient() crclient.Client <span class="cov8" title="1">{
        return r.Client
}</span>

// IncrUpdateCount - Increments the update count
func (r *ApexConnectivityClientReconciler) IncrUpdateCount() <span class="cov8" title="1">{
        atomic.AddInt32(&amp;r.updateCount, 1)
}</span>

// GetUpdateCount - Returns the current update count
func (r *ApexConnectivityClientReconciler) GetUpdateCount() int32 <span class="cov8" title="1">{
        return r.updateCount
}</span>

// GetK8sClient - Returns the current update count
func (r *ApexConnectivityClientReconciler) GetK8sClient() kubernetes.Interface <span class="cov8" title="1">{
        return r.K8sClient
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">//  Copyright © 2021 - 2023 Dell Inc. or its subsidiaries. All Rights Reserved.
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//       http://www.apache.org/licenses/LICENSE-2.0
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package controllers

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "strconv"
        "sync"
        "sync/atomic"
        "time"

        "github.com/dell/csm-operator/pkg/drivers"
        "github.com/dell/csm-operator/pkg/modules"
        "k8s.io/apimachinery/pkg/runtime"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"

        csmv1 "github.com/dell/csm-operator/api/v1"
        "github.com/dell/csm-operator/pkg/constants"
        "github.com/dell/csm-operator/pkg/logger"
        "github.com/dell/csm-operator/pkg/resources/configmap"
        "github.com/dell/csm-operator/pkg/resources/csidriver"
        "github.com/dell/csm-operator/pkg/resources/daemonset"
        "github.com/dell/csm-operator/pkg/resources/deployment"
        "github.com/dell/csm-operator/pkg/resources/rbac"
        "github.com/dell/csm-operator/pkg/resources/serviceaccount"
        "github.com/dell/csm-operator/pkg/utils"
        "go.uber.org/zap"

        k8serror "k8s.io/apimachinery/pkg/api/errors"
        t1 "k8s.io/apimachinery/pkg/types"
        sinformer "k8s.io/client-go/informers"
        "k8s.io/client-go/kubernetes"
        "k8s.io/client-go/tools/cache"
        "k8s.io/client-go/tools/record"
        "sigs.k8s.io/controller-runtime/pkg/controller"
        "sigs.k8s.io/controller-runtime/pkg/event"
        "sigs.k8s.io/controller-runtime/pkg/predicate"
        "sigs.k8s.io/controller-runtime/pkg/ratelimiter"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"

        appsv1 "k8s.io/api/apps/v1"
        corev1 "k8s.io/api/core/v1"
        storagev1 "k8s.io/api/storage/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        // metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// ContainerStorageModuleReconciler reconciles a ContainerStorageModule object
type ContainerStorageModuleReconciler struct {
        // controller runtime client, responsible for create, delete, update, get etc.
        client.Client
        // k8s client, implements client-go/kubernetes interface, responsible for apply, which
        // client.Client does not provides
        K8sClient     kubernetes.Interface
        Scheme        *runtime.Scheme
        Log           *zap.SugaredLogger
        Config        utils.OperatorConfig
        updateCount   int32
        trcID         string
        EventRecorder record.EventRecorder
}

// DriverConfig  -
type DriverConfig struct {
        Driver     *storagev1.CSIDriver
        ConfigMap  *corev1.ConfigMap
        Node       *utils.NodeYAML
        Controller *utils.ControllerYAML
}

const (
        // MetadataPrefix - prefix for all labels &amp; annotations
        MetadataPrefix = "storage.dell.com"

        // NodeYaml - yaml file name for node
        NodeYaml = "node.yaml"

        // CSMFinalizerName -
        CSMFinalizerName = "finalizer.dell.emc.com"

        // CSMVersion -
        CSMVersion = "v1.10.0"
)

var (
        dMutex                          sync.RWMutex
        configVersionKey                = fmt.Sprintf("%s/%s", MetadataPrefix, "CSMOperatorConfigVersion")
        previouslyAppliedCustomResource = fmt.Sprintf("%s/%s", MetadataPrefix, "PreviouslyAppliedConfiguration")

        // CSMVersionKey -
        CSMVersionKey = fmt.Sprintf("%s/%s", MetadataPrefix, "CSMVersion")

        // StopWatch - watcher stop handle
        StopWatch = make(chan struct{})
)

// +kubebuilder:rbac:groups=storage.dell.com,resources=containerstoragemodules,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=storage.dell.com,resources=containerstoragemodules/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=storage.dell.com,resources=containerstoragemodules/finalizers,verbs=update
// +kubebuilder:rbac:groups="replication.storage.dell.com",resources=dellcsireplicationgroups,verbs=get;list;watch;update;create;delete;patch
// +kubebuilder:rbac:groups="replication.storage.dell.com",resources=dellcsireplicationgroups/status,verbs=get;update;patch
// +kubebuilder:rbac:groups="",resources=pods;services;services/finalizers;endpoints;persistentvolumeclaims;events;configmaps;secrets;serviceaccounts;roles;ingresses,verbs=*
// +kubebuilder:rbac:groups="",resources=nodes,verbs=get;list;watch;create;patch;update
// +kubebuilder:rbac:groups="",resources=persistentvolumeclaims/status,verbs=update;patch;get
// +kubebuilder:rbac:groups="",resources=namespaces,verbs=create;get;list;watch
// +kubebuilder:rbac:groups="",resources=persistentvolumes,verbs=get;list;watch;create;delete;patch;update
// +kubebuilder:rbac:groups="apps",resources=deployments;daemonsets;replicasets;statefulsets,verbs=get;list;watch;update;create;delete;patch
// +kubebuilder:rbac:groups="rbac.authorization.k8s.io",resources=clusterroles;clusterrolebindings;replicasets;rolebindings,verbs=get;list;watch;update;create;delete;patch
// +kubebuilder:rbac:groups="rbac.authorization.k8s.io",resources=clusterroles/finalizers,verbs=get;list;watch;update;create;delete;patch
// +kubebuilder:rbac:groups="rbac.authorization.k8s.io",resources=subjectaccessreviews,verbs=create
// +kubebuilder:rbac:groups="rbac.authorization.k8s.io",resources=roles,verbs=get;list;watch;update;create;delete;patch
// +kubebuilder:rbac:groups="*",resources=*,resourceNames=application-mobility-velero-server,verbs=*
// +kubebuilder:rbac:groups="monitoring.coreos.com",resources=servicemonitors,verbs=get;create
// +kubebuilder:rbac:groups="",resources=deployments/finalizers,resourceNames=dell-csm-operator-controller-manager,verbs=update
// +kubebuilder:rbac:groups="storage.k8s.io",resources=csidrivers,verbs=get;list;watch;create;update;delete;patch
// +kubebuilder:rbac:groups="storage.k8s.io",resources=storageclasses,verbs=get;list;watch;create;update;delete
// +kubebuilder:rbac:groups="storage.k8s.io",resources=volumeattachments,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups="storage.k8s.io",resources=csinodes,verbs=get;list;watch;create;update
// +kubebuilder:rbac:groups="csi.storage.k8s.io",resources=csinodeinfos,verbs=get;list;watch
// +kubebuilder:rbac:groups="snapshot.storage.k8s.io",resources=volumesnapshotclasses;volumesnapshotcontents,verbs=get;list;watch;create;update;delete;patch
// +kubebuilder:rbac:groups="snapshot.storage.k8s.io",resources=volumesnapshotcontents/status,verbs=get;list;watch;patch;update
// +kubebuilder:rbac:groups="snapshot.storage.k8s.io",resources=volumesnapshots,verbs=get;list;watch;update;patch;create;delete
// +kubebuilder:rbac:groups="snapshot.storage.k8s.io",resources=volumesnapshots/status,verbs=get;list;watch;update;patch
// +kubebuilder:rbac:groups="volumegroup.storage.dell.com",resources=dellcsivolumegroupsnapshots;dellcsivolumegroupsnapshots/status,verbs=create;list;watch;delete;update
// +kubebuilder:rbac:groups="apiextensions.k8s.io",resources=customresourcedefinitions,verbs=*
// +kubebuilder:rbac:groups="apiextensions.k8s.io",resources=customresourcedefinitions/status,verbs=get;list;patch;watch
// +kubebuilder:rbac:groups="storage.k8s.io",resources=volumeattachments/status,verbs=patch
// +kubebuilder:rbac:groups="coordination.k8s.io",resources=leases,verbs=get;list;watch;create;update;delete;patch
// +kubebuilder:rbac:groups="security.openshift.io",resources=securitycontextconstraints,resourceNames=privileged,verbs=use
// +kubebuilder:rbac:urls="/metrics",verbs=get
// +kubebuilder:rbac:groups="authentication.k8s.io",resources=tokenreviews,verbs=create
// +kubebuilder:rbac:groups="authorization.k8s.io",resources=subjectaccessreviews,verbs=create
// +kubebuilder:rbac:groups="cert-manager.io",resources=issuers;issuers/status,verbs=update;get;list;watch;patch
// +kubebuilder:rbac:groups="cert-manager.io",resources=clusterissuers;clusterissuers/status,verbs=update;get;list;watch;patch
// +kubebuilder:rbac:groups="cert-manager.io",resources=certificates;certificaterequests;clusterissuers;issuers,verbs=*
// +kubebuilder:rbac:groups="cert-manager.io",resources=certificates/finalizers;certificaterequests/finalizers,verbs=update
// +kubebuilder:rbac:groups="cert-manager.io",resources=certificates/status;certificaterequests/status,verbs=update;patch
// +kubebuilder:rbac:groups="cert-manager.io",resources=certificates;certificaterequests;issuers,verbs=create;delete;deletecollection;patch;update
// +kubebuilder:rbac:groups="cert-manager.io",resources=signers,resourceNames=issuers.cert-manager.io/*;clusterissuers.cert-manager.io/*,verbs=approve
// +kubebuilder:rbac:groups="cert-manager.io",resources=*/*,verbs=*
// +kubebuilder:rbac:groups="",resources=secrets,resourceNames=cert-manager-webhook-ca,verbs=get;list;watch;update
// +kubebuilder:rbac:groups="cert-manager.io",resources=configmaps,resourceNames=cert-manager-cainjector-leader-election;cert-manager-cainjector-leader-election-core,verbs=get;update;patch
// +kubebuilder:rbac:groups="",resources=configmaps,resourceNames=cert-manager-controller,verbs=get;update;patch
// +kubebuilder:rbac:groups="mobility.storage.dell.com",resources=backups,verbs=create;delete;get;list;patch;update;watch
// +kubebuilder:rbac:groups="mobility.storage.dell.com",resources=backups/finalizers,verbs=update
// +kubebuilder:rbac:groups="mobility.storage.dell.com",resources=backups/status,verbs=get;patch;update
// +kubebuilder:rbac:groups="mobility.storage.dell.com",resources=clusterconfigs,verbs=create;delete;get;list;patch;update;watch
// +kubebuilder:rbac:groups="mobility.storage.dell.com",resources=clusterconfigs/finalizers,verbs=update
// +kubebuilder:rbac:groups="mobility.storage.dell.com",resources=clusterconfigs/status,verbs=get;patch;update
// +kubebuilder:rbac:groups="mobility.storage.dell.com",resources=podvolumebackups,verbs=create;delete;get;list;patch;update;watch
// +kubebuilder:rbac:groups="mobility.storage.dell.com",resources=podvolumebackups/finalizers,verbs=update
// +kubebuilder:rbac:groups="mobility.storage.dell.com",resources=podvolumebackups/status,verbs=get;patch;update
// +kubebuilder:rbac:groups="mobility.storage.dell.com",resources=podvolumerestores,verbs=create;delete;get;list;patch;update;watch
// +kubebuilder:rbac:groups="mobility.storage.dell.com",resources=podvolumerestores/finalizers,verbs=update
// +kubebuilder:rbac:groups="mobility.storage.dell.com",resources=podvolumerestores/status,verbs=get;patch;update
// +kubebuilder:rbac:groups="mobility.storage.dell.com",resources=restores,verbs=create;delete;get;list;patch;update;watch
// +kubebuilder:rbac:groups="mobility.storage.dell.com",resources=restores/finalizers,verbs=update
// +kubebuilder:rbac:groups="mobility.storage.dell.com",resources=restores/status,verbs=get;patch;update
// +kubebuilder:rbac:groups="mobility.storage.dell.com",resources=schedules,verbs=create;delete;get;list;patch;update;watch
// +kubebuilder:rbac:groups="mobility.storage.dell.com",resources=schedules/status,verbs=get;patch;update
// +kubebuilder:rbac:groups="velero.io",resources=backups,verbs=create;delete;get;list;patch;update;watch
// +kubebuilder:rbac:groups="velero.io",resources=backups/finalizers,verbs=update
// +kubebuilder:rbac:groups="velero.io",resources=backups/status,verbs=get;list;patch;update
// +kubebuilder:rbac:groups="velero.io",resources=backupstoragelocations,verbs=get;list;patch;update;watch
// +kubebuilder:rbac:groups="velero.io",resources=deletebackuprequests,verbs=create;delete;get;list;watch
// +kubebuilder:rbac:groups="velero.io",resources=podvolumebackups,verbs=create;delete;get;list;patch;update;watch
// +kubebuilder:rbac:groups="velero.io",resources=podvolumebackups/finalizers,verbs=update
// +kubebuilder:rbac:groups="velero.io",resources=podvolumebackups/status,verbs=create;get;list;patch;update
// +kubebuilder:rbac:groups="velero.io",resources=podvolumerestores,verbs=create;delete;get;list;patch;update;watch
// +kubebuilder:rbac:groups="velero.io",resources=backuprepositories,verbs=create;delete;get;list;patch;update;watch
// +kubebuilder:rbac:groups="velero.io",resources=restores,verbs=create;delete;get;list;patch;update;watch
// +kubebuilder:rbac:groups="coordination.k8s.io",resources=leases,resourceNames=cert-manager-cainjector-leader-election;cert-manager-cainjector-leader-election-core,verbs=get;update;patch
// +kubebuilder:rbac:groups="coordination.k8s.io",resources=leases,resourceNames=cert-manager-controller,verbs=get;update;patch
// +kubebuilder:rbac:groups="coordination.k8s.io",resources=leases,verbs=create;patch
// +kubebuilder:rbac:groups="acme.cert-manager.io",resources=orders,verbs=create;delete;get;list;watch
// +kubebuilder:rbac:groups="acme.cert-manager.io",resources=orders;orders/status,verbs=update;patch
// +kubebuilder:rbac:groups="acme.cert-manager.io",resources=orders;challenges,verbs=get;list;watch;create;delete;deletecollection;patch;update
// +kubebuilder:rbac:groups="acme.cert-manager.io",resources=clusterissuers;issuers,verbs=get;list;watch
// +kubebuilder:rbac:groups="acme.cert-manager.io",resources=challenges,verbs=create;delete
// +kubebuilder:rbac:groups="acme.cert-manager.io",resources=orders/finalizers,verbs=update
// +kubebuilder:rbac:groups="acme.cert-manager.io",resources=challenges;challenges/status,verbs=update;get;list;watch;patch
// +kubebuilder:rbac:groups="acme.cert-manager.io",resources=challenges/finalizers,verbs=update
// +kubebuilder:rbac:groups="acme.cert-manager.io",resources=*/*,verbs=*
// +kubebuilder:rbac:groups="networking.k8s.io",resources=ingresses,verbs=*
// +kubebuilder:rbac:groups="networking.k8s.io",resources=ingresses/finalizers,verbs=update
// +kubebuilder:rbac:groups="networking.k8s.io",resources=ingressclasses,verbs=create;get;list;watch;update;delete
// +kubebuilder:rbac:groups="networking.k8s.io",resources=ingresses/status,verbs=update;get;list;watch
// +kubebuilder:rbac:groups="gateway.networking.k8s.io",resources=httproutes,verbs=get;list;watch;create;delete;update
// +kubebuilder:rbac:groups="gateway.networking.k8s.io",resources=httproutes;gateways,verbs=get;list;watch
// +kubebuilder:rbac:groups="gateway.networking.k8s.io",resources=gateways/finalizers;httproutes/finalizers,verbs=update
// +kubebuilder:rbac:groups="route.openshift.io",resources=routes/custom-host,verbs=create
// +kubebuilder:rbac:groups="admissionregistration.k8s.io",resources=validatingwebhookconfigurations;mutatingwebhookconfigurations,verbs=create;get;list;watch;update;delete;patch
// +kubebuilder:rbac:groups="apiregistration.k8s.io",resources=apiservices,verbs=get;list;watch;update
// +kubebuilder:rbac:groups="apiregistration.k8s.io",resources=customresourcedefinitions,verbs=get;list;watch;update
// +kubebuilder:rbac:groups="auditregistration.k8s.io",resources=auditsinks,verbs=get;list;watch;update
// +kubebuilder:rbac:groups="",resources=configmaps,resourceNames=ingress-controller-leader,verbs=get;update
// +kubebuilder:rbac:groups="coordination.k8s.io",resources=leases,resourceNames=ingress-controller-leader,verbs=get;update;patch
// +kubebuilder:rbac:groups="coordination.k8s.io",resources=leases,verbs=create;list;watch;patch
// +kubebuilder:rbac:groups="coordination.k8s.io",resources=leases,resourceNames=cert-manager-cainjector-leader-election;cert-manager-cainjector-leader-election-core,verbs=get;update;patch
// +kubebuilder:rbac:groups="discovery.k8s.io",resources=endpointslices,verbs=list;watch;get
// +kubebuilder:rbac:groups="certificates.k8s.io",resources=certificatesigningrequests,verbs=get;list;watch;update
// +kubebuilder:rbac:groups="certificates.k8s.io",resources=certificatesigningrequests/status,verbs=update;patch
// +kubebuilder:rbac:groups="certificates.k8s.io",resources=signers,resourceNames=issuers.cert-manager.io/*;clusterissuers.cert-manager.io/*,verbs=sign
// +kubebuilder:rbac:groups="",resources=configmaps,resourceNames=cert-manager-cainjector-leader-election;cert-manager-cainjector-leader-election-core;cert-manager-controller,verbs=get;update;patch
// +kubebuilder:rbac:groups="batch",resources=jobs,verbs=list;watch;create;update;delete
// +kubebuilder:rbac:groups="storage.k8s.io",resources=csistoragecapacities,verbs=get;list;watch;create;update;patch;delete

// Reconcile is part of the main kubernetes reconciliation loop which aims to
// move the current state of the cluster closer to the desired state.
// TODO(user): Modify the Reconcile function to compare the state specified by
// the ContainerStorageModule object against the actual cluster state, and then
// perform operations to make the cluster state reflect the state specified by
// the user.
//
// For more details, check Reconcile and its Result here:
// - https://pkg.go.dev/sigs.k8s.io/controller-runtime@v0.9.2/pkg/reconcile

// Reconcile - main loop
func (r *ContainerStorageModuleReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) <span class="cov8" title="1">{
        r.IncrUpdateCount()
        r.trcID = fmt.Sprintf("%d", r.GetUpdateCount())
        name := req.Name + "-" + r.trcID
        ctx, log := logger.GetNewContextWithLogger(name)
        unitTestRun := utils.DetermineUnitTestRun(ctx)

        log.Info("################Starting Reconcile##############")
        csm := new(csmv1.ContainerStorageModule)

        log.Infow("reconcile for", "Namespace", req.Namespace, "Name", req.Name, "Attempt", r.GetUpdateCount())

        // Fetch the ContainerStorageModuleReconciler instance
        err := r.Client.Get(ctx, req.NamespacedName, csm)
        if err != nil </span><span class="cov8" title="1">{
                if k8serror.IsNotFound(err) </span><span class="cov8" title="1">{
                        // Request object not found, could have been deleted after reconcile request.
                        // Owned objects are automatically garbage collected. For additional cleanup logic use finalizers.
                        // Return and don't requeue
                        return reconcile.Result{}, nil
                }</span>
                // Error reading the object - requeue the request.
                <span class="cov0" title="0">return reconcile.Result{}, nil</span>
        }

        <span class="cov8" title="1">operatorConfig := &amp;utils.OperatorConfig{
                IsOpenShift:     r.Config.IsOpenShift,
                K8sVersion:      r.Config.K8sVersion,
                ConfigDirectory: r.Config.ConfigDirectory,
        }

        // perform prechecks
        err = r.PreChecks(ctx, csm, *operatorConfig)
        if err != nil </span><span class="cov8" title="1">{
                csm.GetCSMStatus().State = constants.InvalidConfig
                r.EventRecorder.Event(csm, corev1.EventTypeWarning, csmv1.EventUpdated, fmt.Sprintf("Failed Prechecks: %s", err))
                return utils.HandleValidationError(ctx, csm, r, err)
        }</span>

        <span class="cov8" title="1">if csm.IsBeingDeleted() </span><span class="cov8" title="1">{
                log.Infow("Delete request", "csm", req.Namespace, "Name", req.Name)

                // remove role/rolebinding from the csm object namespace
                err := r.SyncRbac(ctx, *csm, *operatorConfig, r.Client)
                if err != nil </span><span class="cov0" title="0">{
                        r.EventRecorder.Event(csm, corev1.EventTypeWarning, csmv1.EventDeleted, fmt.Sprintf("Failed to sync rbac: %s", err))
                        log.Errorw("sync rbac", "error", err.Error())
                        return ctrl.Result{}, fmt.Errorf("error when syncing rbac: %v", err)
                }</span>

                // check for force cleanup
                <span class="cov8" title="1">if csm.Spec.Driver.ForceRemoveDriver </span><span class="cov8" title="1">{
                        // remove all resources deployed from CR by operator
                        if err := r.removeDriver(ctx, *csm, *operatorConfig); err != nil </span><span class="cov8" title="1">{
                                r.EventRecorder.Event(csm, corev1.EventTypeWarning, csmv1.EventDeleted, fmt.Sprintf("Failed to remove driver: %s", err))
                                log.Errorw("remove driver", "error", err.Error())
                                return ctrl.Result{}, fmt.Errorf("error when deleting driver: %v", err)
                        }</span>
                }

                // check for force cleanup on standalone module
                <span class="cov8" title="1">for _, m := range csm.Spec.Modules </span><span class="cov8" title="1">{
                        if m.ForceRemoveModule </span><span class="cov8" title="1">{
                                // remove all resources deployed from CR by operator
                                if err := r.removeModule(ctx, *csm, *operatorConfig, r.Client); err != nil </span><span class="cov0" title="0">{
                                        r.EventRecorder.Event(csm, corev1.EventTypeWarning, csmv1.EventDeleted, fmt.Sprintf("Failed to remove module: %s", err))
                                        log.Errorw("remove module", "error", err.Error())
                                        return ctrl.Result{}, fmt.Errorf("error when deleting module: %v", err)
                                }</span>
                        }
                }

                <span class="cov8" title="1">if err := r.removeFinalizer(ctx, csm); err != nil </span><span class="cov8" title="1">{
                        r.EventRecorder.Event(csm, corev1.EventTypeWarning, csmv1.EventDeleted, fmt.Sprintf("Failed to delete finalizer: %s", err))
                        log.Errorw("remove driver finalizer", "error", err.Error())
                        return ctrl.Result{}, fmt.Errorf("error when handling finalizer: %v", err)
                }</span>
                <span class="cov8" title="1">r.EventRecorder.Event(csm, corev1.EventTypeNormal, csmv1.EventDeleted, "Object finalizer is deleted")

                return ctrl.Result{}, nil</span>
        }

        // Add finalizer
        <span class="cov8" title="1">if !csm.HasFinalizer(CSMFinalizerName) </span><span class="cov8" title="1">{
                log.Infow("HandleFinalizer", "name", CSMFinalizerName)
                if err := r.addFinalizer(ctx, csm); err != nil </span><span class="cov8" title="1">{
                        r.EventRecorder.Event(csm, corev1.EventTypeWarning, csmv1.EventUpdated, fmt.Sprintf("Failed to add finalizer: %s", err))
                        log.Errorw("HandleFinalizer", "error", err.Error())
                        return ctrl.Result{}, fmt.Errorf("error when adding finalizer: %v", err)
                }</span>
                <span class="cov8" title="1">r.EventRecorder.Event(csm, corev1.EventTypeNormal, csmv1.EventUpdated, "Object finalizer is added")</span>
        }

        <span class="cov8" title="1">oldStatus := csm.GetCSMStatus()

        // Set the driver annotation
        isUpdated := applyConfigVersionAnnotations(ctx, csm)
        if isUpdated </span><span class="cov8" title="1">{
                err = r.GetClient().Update(ctx, csm)
                if err != nil </span><span class="cov8" title="1">{
                        log.Error(err, "Failed to update CR with annotation")
                        return reconcile.Result{}, err
                }</span>
        }

        <span class="cov8" title="1">newStatus := csm.GetCSMStatus()
        requeue := utils.HandleSuccess(ctx, csm, r, newStatus, oldStatus)

        // Update the driver
        syncErr := r.SyncCSM(ctx, *csm, *operatorConfig, r.Client)
        if syncErr == nil &amp;&amp; !requeue.Requeue </span><span class="cov8" title="1">{
                err = utils.UpdateStatus(ctx, csm, r, newStatus)
                if err != nil &amp;&amp; !unitTestRun </span><span class="cov0" title="0">{
                        log.Error(err, "Failed to update CR status")
                        return utils.LogBannerAndReturn(reconcile.Result{Requeue: true}, err)
                }</span>
                <span class="cov8" title="1">r.EventRecorder.Eventf(csm, corev1.EventTypeNormal, csmv1.EventCompleted, "install/update storage component: %s completed OK", csm.Name)
                return utils.LogBannerAndReturn(reconcile.Result{}, nil)</span>
        }

        // syncErr can be nil, even if CSM state = failed
        <span class="cov8" title="1">if syncErr == nil </span><span class="cov8" title="1">{
                syncErr = errors.New("CSM state is failed")
        }</span>

        // Failed deployment
        <span class="cov8" title="1">r.EventRecorder.Eventf(csm, corev1.EventTypeWarning, csmv1.EventUpdated, "Failed install: %s", syncErr.Error())

        return utils.LogBannerAndReturn(reconcile.Result{Requeue: true}, syncErr)</span>
}

func (r *ContainerStorageModuleReconciler) ignoreUpdatePredicate() predicate.Predicate <span class="cov8" title="1">{
        return predicate.Funcs{
                UpdateFunc: func(e event.UpdateEvent) bool </span><span class="cov8" title="1">{
                        // Ignore updates to status in which case metadata.Generation does not change
                        return e.ObjectOld.GetGeneration() != e.ObjectNew.GetGeneration()
                }</span>,

                DeleteFunc: func(e event.DeleteEvent) bool <span class="cov8" title="1">{
                        // Evaluates to false if the object has been confirmed deleted.
                        return !e.DeleteStateUnknown
                }</span>,
        }
}

func (r *ContainerStorageModuleReconciler) handleDeploymentUpdate(oldObj interface{}, obj interface{}) <span class="cov8" title="1">{
        dMutex.Lock()
        defer dMutex.Unlock()

        old, _ := oldObj.(*appsv1.Deployment)
        d, _ := obj.(*appsv1.Deployment)
        name := d.Spec.Template.Labels[constants.CsmLabel]
        key := name + "-" + fmt.Sprintf("%d", r.GetUpdateCount())
        ctx, log := logger.GetNewContextWithLogger(key)
        if name == "" </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">log.Debugw("deployment modified generation", d.Name, d.Generation, old.Generation)

        desired := d.Status.Replicas
        available := d.Status.AvailableReplicas
        ready := d.Status.ReadyReplicas
        numberUnavailable := d.Status.UnavailableReplicas

        // Replicas:               2 desired | 2 updated | 2 total | 2 available | 0 unavailable

        log.Infow("deployment", "deployment name", d.Name, "desired", desired)
        log.Infow("deployment", "deployment name", d.Name, "numberReady", ready)
        log.Infow("deployment", "deployment name", d.Name, "available", available)
        log.Infow("deployment", "deployment name", d.Name, "numberUnavailable", numberUnavailable)

        ns := d.Spec.Template.Labels[constants.CsmNamespaceLabel]
        if ns == "" </span><span class="cov8" title="1">{
                ns = d.Namespace
        }</span>
        <span class="cov8" title="1">log.Debugw("csm being modified in handledeployment", "namespace", ns, "name", name)
        namespacedName := t1.NamespacedName{
                Name:      name,
                Namespace: ns,
        }

        csm := new(csmv1.ContainerStorageModule)
        err := r.Client.Get(ctx, namespacedName, csm)
        if err != nil </span><span class="cov0" title="0">{
                log.Error("deployment get csm", "error", err.Error())
        }</span>

        <span class="cov8" title="1">newStatus := csm.GetCSMStatus()

        // Updating controller status manually as controller runtime API is not updating csm object with latest data
        // TODO: Can remove this once the controller runtime repo has a fix for updating the object passed
        newStatus.ControllerStatus.Available = strconv.Itoa(int(available))
        newStatus.ControllerStatus.Desired = strconv.Itoa(int(desired))
        newStatus.ControllerStatus.Failed = strconv.Itoa(int(numberUnavailable))

        err = utils.UpdateStatus(ctx, csm, r, newStatus)
        if err != nil </span><span class="cov8" title="1">{
                log.Debugw("deployment status ", "pods", err.Error())
        }</span> else<span class="cov0" title="0"> {
                r.EventRecorder.Eventf(csm, corev1.EventTypeNormal, csmv1.EventCompleted, "Driver deployment running OK")
        }</span>
}

func (r *ContainerStorageModuleReconciler) handlePodsUpdate(_ interface{}, obj interface{}) <span class="cov8" title="1">{
        dMutex.Lock()
        defer dMutex.Unlock()

        p, _ := obj.(*corev1.Pod)
        name := p.GetLabels()[constants.CsmLabel]
        // if this pod is an obs. pod, namespace might not match csm namespace
        ns := p.GetLabels()[constants.CsmNamespaceLabel]
        if ns == "" </span><span class="cov8" title="1">{
                ns = p.Namespace
        }</span>
        <span class="cov8" title="1">if name == "" </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">key := name + "-" + fmt.Sprintf("%d", r.GetUpdateCount())
        ctx, log := logger.GetNewContextWithLogger(key)

        if !p.ObjectMeta.DeletionTimestamp.IsZero() </span><span class="cov0" title="0">{
                log.Debugw("driver delete invoked", "stopping pod with name", p.Name)
                return
        }</span>
        <span class="cov8" title="1">log.Infow("pod modified for driver", "name", p.Name)

        namespacedName := t1.NamespacedName{
                Name:      name,
                Namespace: ns,
        }
        csm := new(csmv1.ContainerStorageModule)
        err := r.Client.Get(ctx, namespacedName, csm)
        if err != nil </span><span class="cov0" title="0">{
                r.Log.Errorw("daemonset get csm", "error", err.Error())
        }</span>
        <span class="cov8" title="1">log.Infow("csm prev status ", "state", csm.Status)
        newStatus := csm.GetCSMStatus()

        err = utils.UpdateStatus(ctx, csm, r, newStatus)
        state := csm.GetCSMStatus().State
        stamp := fmt.Sprintf("at %d", time.Now().UnixNano())
        if state != "0" &amp;&amp; err != nil </span><span class="cov8" title="1">{
                log.Infow("pod status ", "state", err.Error())
                r.EventRecorder.Eventf(csm, corev1.EventTypeWarning, csmv1.EventUpdated, "%s Pod error details %s", stamp, err.Error())
        }</span> else<span class="cov0" title="0"> {
                r.EventRecorder.Eventf(csm, corev1.EventTypeNormal, csmv1.EventCompleted, "%s Driver pods running OK", stamp)
        }</span>
}

func (r *ContainerStorageModuleReconciler) handleDaemonsetUpdate(oldObj interface{}, obj interface{}) <span class="cov8" title="1">{
        dMutex.Lock()
        defer dMutex.Unlock()

        old, _ := oldObj.(*appsv1.DaemonSet)
        d, _ := obj.(*appsv1.DaemonSet)
        name := d.Spec.Template.Labels[constants.CsmLabel]
        if name == "" </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">key := name + "-" + fmt.Sprintf("%d", r.GetUpdateCount())
        ctx, log := logger.GetNewContextWithLogger(key)

        log.Debugw("daemonset modified generation", "new", d.Generation, "old", old.Generation)

        desired := d.Status.DesiredNumberScheduled
        available := d.Status.NumberAvailable
        ready := d.Status.NumberReady
        numberUnavailable := d.Status.NumberUnavailable

        log.Infow("daemonset ", "name", d.Name, "namespace", d.Namespace)
        log.Infow("daemonset ", "desired", desired)
        log.Infow("daemonset ", "numberReady", ready)
        log.Infow("daemonset ", "available", available)
        log.Infow("daemonset ", "numberUnavailable", numberUnavailable)

        ns := d.Spec.Template.Labels[constants.CsmNamespaceLabel]
        if ns == "" </span><span class="cov8" title="1">{
                ns = d.Namespace
        }</span>
        <span class="cov8" title="1">r.Log.Debugw("daemonset ", "ns", ns, "name", name)
        namespacedName := t1.NamespacedName{
                Name:      name,
                Namespace: ns,
        }

        csm := new(csmv1.ContainerStorageModule)
        err := r.Client.Get(ctx, namespacedName, csm)
        if err != nil </span><span class="cov0" title="0">{
                r.Log.Error("daemonset get csm", "error", err.Error())
        }</span>

        <span class="cov8" title="1">log.Infow("csm prev status ", "state", csm.Status)
        newStatus := csm.GetCSMStatus()
        err = utils.UpdateStatus(ctx, csm, r, newStatus)
        if err != nil </span><span class="cov0" title="0">{
                log.Debugw("daemonset status ", "pods", err.Error())
        }</span> else<span class="cov8" title="1"> {
                r.EventRecorder.Eventf(csm, corev1.EventTypeNormal, csmv1.EventCompleted, "Driver daemonset running OK")
        }</span>
}

// ContentWatch - watch updates on deployment and deamonset
func (r *ContainerStorageModuleReconciler) ContentWatch() error <span class="cov8" title="1">{
        sharedInformerFactory := sinformer.NewSharedInformerFactory(r.K8sClient, time.Duration(time.Hour))

        daemonsetInformer := sharedInformerFactory.Apps().V1().DaemonSets().Informer()
        _, err := daemonsetInformer.AddEventHandler(cache.ResourceEventHandlerFuncs{
                UpdateFunc: r.handleDaemonsetUpdate,
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ContentWatch failed adding event handler to daemonsetInformer: %v", err)
        }</span>

        <span class="cov8" title="1">deploymentInformer := sharedInformerFactory.Apps().V1().Deployments().Informer()
        _, err = deploymentInformer.AddEventHandler(cache.ResourceEventHandlerFuncs{
                UpdateFunc: r.handleDeploymentUpdate,
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ContentWatch failed adding event handler to deploymentInformer: %v", err)
        }</span>

        <span class="cov8" title="1">podsInformer := sharedInformerFactory.Core().V1().Pods().Informer()
        _, err = podsInformer.AddEventHandler(cache.ResourceEventHandlerFuncs{
                UpdateFunc: r.handlePodsUpdate,
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ContentWatch failed adding event handler to podsInformer: %v", err)
        }</span>

        <span class="cov8" title="1">sharedInformerFactory.Start(StopWatch)
        return nil</span>
}

// SetupWithManager sets up the controller with the Manager.
func (r *ContainerStorageModuleReconciler) SetupWithManager(mgr ctrl.Manager, limiter ratelimiter.RateLimiter, maxReconcilers int) error <span class="cov8" title="1">{
        go r.ContentWatch()

        return ctrl.NewControllerManagedBy(mgr).
                For(&amp;csmv1.ContainerStorageModule{}).
                WithEventFilter(r.ignoreUpdatePredicate()).
                WithOptions(controller.Options{
                        RateLimiter:             limiter,
                        MaxConcurrentReconciles: maxReconcilers,
                }).Complete(r)
}</span>

func (r *ContainerStorageModuleReconciler) removeFinalizer(ctx context.Context, instance *csmv1.ContainerStorageModule) error <span class="cov8" title="1">{
        if !instance.HasFinalizer(CSMFinalizerName) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">instance.SetFinalizers(nil)
        return r.Update(ctx, instance)</span>
}

func (r *ContainerStorageModuleReconciler) addFinalizer(ctx context.Context, instance *csmv1.ContainerStorageModule) error <span class="cov8" title="1">{
        instance.SetFinalizers([]string{CSMFinalizerName})
        instance.GetCSMStatus().State = constants.Creating
        return r.Update(ctx, instance)
}</span>

func (r *ContainerStorageModuleReconciler) oldStandAloneModuleCleanup(ctx context.Context, newCR *csmv1.ContainerStorageModule, operatorConfig utils.OperatorConfig, driverConfig *DriverConfig) error <span class="cov8" title="1">{
        log := logger.GetLogger(ctx)
        log.Info("Checking if standalone modules need clean up")

        replicaEnabled := func(cr *csmv1.ContainerStorageModule) bool </span><span class="cov8" title="1">{
                for _, m := range cr.Spec.Modules </span><span class="cov8" title="1">{
                        if m.Name == csmv1.Replication </span><span class="cov8" title="1">{
                                return m.Enabled
                        }</span>
                }
                <span class="cov8" title="1">return false</span>
        }

        <span class="cov8" title="1">var err error

        if oldCrJSON, ok := newCR.Annotations[previouslyAppliedCustomResource]; ok &amp;&amp; oldCrJSON != "" </span><span class="cov8" title="1">{
                oldCR := new(csmv1.ContainerStorageModule)
                err = json.Unmarshal([]byte(oldCrJSON), oldCR)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error unmarshalling old annotation: %v", err)
                }</span>

                // Check if replica needs to be uninstalled
                <span class="cov8" title="1">if replicaEnabled(oldCR) &amp;&amp; !replicaEnabled(newCR) </span><span class="cov8" title="1">{
                        _, clusterClients, err := utils.GetDefaultClusters(ctx, *oldCR, r)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">for _, cluster := range clusterClients </span><span class="cov8" title="1">{
                                log.Infow("Deleting Replication controller", "clusterID:", cluster.ClusterID)
                                if err = modules.ReplicationManagerController(ctx, true, operatorConfig, *oldCR, cluster.ClusterCTRLClient); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>

                                // also uninstalled drivers in target clusters
                                <span class="cov8" title="1">if cluster.ClusterID != utils.DefaultSourceClusterID </span><span class="cov0" title="0">{
                                        if err = removeDriverReplicaCluster(ctx, cluster, driverConfig); err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                }
                        }
                }
                // check if observability needs to be uninstalled
                <span class="cov8" title="1">oldObservabilityEnabled, oldObs := utils.IsModuleEnabled(ctx, *oldCR, csmv1.Observability)
                newObservabilityEnabled, _ := utils.IsModuleEnabled(ctx, *newCR, csmv1.Observability)
                // check if observability components need to be uninstalled
                components := []string{}
                if oldObservabilityEnabled &amp;&amp; newObservabilityEnabled </span><span class="cov8" title="1">{
                        for _, comp := range oldObs.Components </span><span class="cov8" title="1">{
                                oldCompEnabled := utils.IsModuleComponentEnabled(ctx, *oldCR, csmv1.Observability, comp.Name)
                                newCompEnabled := utils.IsModuleComponentEnabled(ctx, *newCR, csmv1.Observability, comp.Name)
                                if oldCompEnabled &amp;&amp; !newCompEnabled </span><span class="cov0" title="0">{
                                        components = append(components, comp.Name)
                                }</span>
                        }
                }
                <span class="cov8" title="1">if (oldObservabilityEnabled &amp;&amp; !newObservabilityEnabled) || len(components) &gt; 0 </span><span class="cov8" title="1">{
                        _, clusterClients, err := utils.GetDefaultClusters(ctx, *oldCR, r)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">for _, cluster := range clusterClients </span><span class="cov8" title="1">{
                                // remove module observability
                                log.Infow("Deleting observability")
                                if err = r.reconcileObservability(ctx, true, operatorConfig, *oldCR, components, cluster.ClusterCTRLClient, cluster.ClusterK8sClient); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }

                // check if application mobility needs to be uninstalled
                <span class="cov8" title="1">oldApplicationmobilityEnabled, _ := utils.IsModuleEnabled(ctx, *oldCR, csmv1.ApplicationMobility)
                newApplicationmobilityEnabled, _ := utils.IsModuleEnabled(ctx, *newCR, csmv1.ApplicationMobility)

                if oldApplicationmobilityEnabled &amp;&amp; !newApplicationmobilityEnabled </span><span class="cov8" title="1">{
                        _, clusterClients, err := utils.GetDefaultClusters(ctx, *oldCR, r)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov8" title="1">for _, cluster := range clusterClients </span><span class="cov8" title="1">{
                                log.Infow("Deleting application mobility")
                                if err := r.reconcileAppMobility(ctx, true, operatorConfig, *oldCR, cluster.ClusterCTRLClient); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">copyCR := newCR.DeepCopy()
        delete(copyCR.Annotations, previouslyAppliedCustomResource)
        delete(copyCR.Annotations, "kubectl.kubernetes.io/last-applied-configuration")
        copyCR.ManagedFields = nil
        copyCR.Status = csmv1.ContainerStorageModuleStatus{}
        out, err := json.Marshal(copyCR)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error marshalling CR to annotation: %v", err)
        }</span>
        <span class="cov8" title="1">newCR.Annotations[previouslyAppliedCustomResource] = string(out)

        return r.GetClient().Update(ctx, newCR)</span>
}

// SyncCSM - Sync the current installation - this can lead to a create or update
func (r *ContainerStorageModuleReconciler) SyncCSM(ctx context.Context, cr csmv1.ContainerStorageModule, operatorConfig utils.OperatorConfig, ctrlClient client.Client) error <span class="cov8" title="1">{
        log := logger.GetLogger(ctx)

        // Create/Update Authorization Proxy Server
        authorizationEnabled, _ := utils.IsModuleEnabled(ctx, cr, csmv1.AuthorizationServer)
        if authorizationEnabled </span><span class="cov8" title="1">{
                log.Infow("Create/Update authorization")
                if err := r.reconcileAuthorization(ctx, false, operatorConfig, cr, ctrlClient); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("failed to deploy authorization proxy server: %v", err)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov8" title="1">if appmobilityEnabled, _ := utils.IsModuleEnabled(ctx, cr, csmv1.ApplicationMobility); appmobilityEnabled </span><span class="cov8" title="1">{
                log.Infow("Create/Update application mobility")
                if err := r.reconcileAppMobilityCRDS(ctx, operatorConfig, cr, ctrlClient); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("failed to deploy application mobility: %v", err)
                }</span>
                <span class="cov8" title="1">if err := r.reconcileAppMobility(ctx, false, operatorConfig, cr, ctrlClient); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to deploy application mobility: %v", err)
                }</span>
        }

        // Create/Update Reverseproxy Server
        <span class="cov8" title="1">if reverseProxyEnabled, _ := utils.IsModuleEnabled(ctx, cr, csmv1.ReverseProxy); reverseProxyEnabled </span><span class="cov8" title="1">{
                log.Infow("Trying Create/Update reverseproxy...")
                if err := r.reconcileReverseProxy(ctx, false, operatorConfig, cr, ctrlClient); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("failed to deploy reverseproxy proxy server: %v", err)
                }</span>
                <span class="cov8" title="1">log.Infow("Create/Update reverseproxy successful...")</span>
        }

        // Get Driver resources
        <span class="cov8" title="1">driverConfig, err := getDriverConfig(ctx, cr, operatorConfig)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // driverConfig = nil means no driver specified in manifest
        <span class="cov8" title="1">if driverConfig == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">err = r.oldStandAloneModuleCleanup(ctx, &amp;cr, operatorConfig, driverConfig)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">driver := driverConfig.Driver
        configMap := driverConfig.ConfigMap
        node := driverConfig.Node
        controller := driverConfig.Controller

        replicationEnabled, clusterClients, err := utils.GetDefaultClusters(ctx, cr, r)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for _, m := range cr.Spec.Modules </span><span class="cov8" title="1">{
                if m.Enabled </span><span class="cov8" title="1">{
                        switch m.Name </span>{
                        case csmv1.Authorization:<span class="cov8" title="1">
                                log.Info("Injecting CSM Authorization")
                                dp, err := modules.AuthInjectDeployment(controller.Deployment, cr, operatorConfig)
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("injecting auth into deployment: %v", err)
                                }</span>
                                <span class="cov8" title="1">controller.Deployment = *dp

                                ds, err := modules.AuthInjectDaemonset(node.DaemonSetApplyConfig, cr, operatorConfig)
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("injecting auth into deamonset: %v", err)
                                }</span>

                                <span class="cov8" title="1">node.DaemonSetApplyConfig = *ds</span>
                        case csmv1.Resiliency:<span class="cov8" title="1">
                                log.Info("Injecting CSM Resiliency")

                                // for controller-pod
                                driverName := string(cr.Spec.Driver.CSIDriverType)
                                dp, err := modules.ResiliencyInjectDeployment(controller.Deployment, cr, operatorConfig, driverName)
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("injecting resiliency into deployment: %v", err)
                                }</span>
                                <span class="cov8" title="1">controller.Deployment = *dp

                                clusterRole, err := modules.ResiliencyInjectClusterRole(controller.Rbac.ClusterRole, cr, operatorConfig, "controller")
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("injecting resiliency into controller cluster role: %v", err)
                                }</span>

                                <span class="cov8" title="1">controller.Rbac.ClusterRole = *clusterRole

                                // for node-pod
                                ds, err := modules.ResiliencyInjectDaemonset(node.DaemonSetApplyConfig, cr, operatorConfig, driverName)
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("injecting resiliency into daemonset: %v", err)
                                }</span>
                                <span class="cov8" title="1">node.DaemonSetApplyConfig = *ds

                                clusterRoleForNode, err := modules.ResiliencyInjectClusterRole(node.Rbac.ClusterRole, cr, operatorConfig, "node")
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("injecting resiliency into node cluster role: %v", err)
                                }</span>

                                <span class="cov8" title="1">node.Rbac.ClusterRole = *clusterRoleForNode</span>
                        case csmv1.Replication:<span class="cov8" title="1">
                                log.Info("Injecting CSM Replication")
                                dp, err := modules.ReplicationInjectDeployment(controller.Deployment, cr, operatorConfig)
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("injecting replication into deployment: %v", err)
                                }</span>
                                <span class="cov8" title="1">controller.Deployment = *dp

                                clusterRole, err := modules.ReplicationInjectClusterRole(controller.Rbac.ClusterRole, cr, operatorConfig)
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("injecting replication into controller cluster role: %v", err)
                                }</span>

                                <span class="cov8" title="1">controller.Rbac.ClusterRole = *clusterRole</span>
                        }
                }
        }

        <span class="cov8" title="1">for _, cluster := range clusterClients </span><span class="cov8" title="1">{
                log.Infof("Starting SYNC for %s cluster", cluster.ClusterID)
                // Create/Update ServiceAccount
                if err = serviceaccount.SyncServiceAccount(ctx, node.Rbac.ServiceAccount, cluster.ClusterCTRLClient); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                <span class="cov8" title="1">if err = serviceaccount.SyncServiceAccount(ctx, controller.Rbac.ServiceAccount, cluster.ClusterCTRLClient); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Create/Update ClusterRoles
                <span class="cov8" title="1">if err = rbac.SyncClusterRole(ctx, node.Rbac.ClusterRole, cluster.ClusterCTRLClient); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                <span class="cov8" title="1">if err = rbac.SyncClusterRole(ctx, controller.Rbac.ClusterRole, cluster.ClusterCTRLClient); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Create/Update ClusterRoleBinding
                <span class="cov8" title="1">if err = rbac.SyncClusterRoleBindings(ctx, node.Rbac.ClusterRoleBinding, cluster.ClusterCTRLClient); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                <span class="cov8" title="1">if err = rbac.SyncClusterRoleBindings(ctx, controller.Rbac.ClusterRoleBinding, cluster.ClusterCTRLClient); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Create/Update CSIDriver
                <span class="cov8" title="1">if err = csidriver.SyncCSIDriver(ctx, *driver, cluster.ClusterCTRLClient); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                // Create/Update ConfigMap
                <span class="cov8" title="1">if err = configmap.SyncConfigMap(ctx, *configMap, cluster.ClusterCTRLClient); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                // Create/Update Deployment
                <span class="cov8" title="1">if err = deployment.SyncDeployment(ctx, controller.Deployment, cluster.ClusterK8sClient, cr.Name); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Create/Update DeamonSet, except for auth proxy
                <span class="cov8" title="1">if !authorizationEnabled </span><span class="cov8" title="1">{
                        if err = daemonset.SyncDaemonset(ctx, node.DaemonSetApplyConfig, cluster.ClusterK8sClient, cr.Name); err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                }

                <span class="cov8" title="1">if replicationEnabled </span><span class="cov8" title="1">{
                        if err = modules.ReplicationManagerController(ctx, false, operatorConfig, cr, cluster.ClusterCTRLClient); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to deploy replication controller: %v", err)
                        }</span>
                }

                // if Observability is enabled, create or update obs components: topology, metrics of PowerScale and PowerFlex
                <span class="cov8" title="1">if observabilityEnabled, _ := utils.IsModuleEnabled(ctx, cr, csmv1.Observability); observabilityEnabled </span><span class="cov8" title="1">{
                        log.Infow("Create/Update observability")

                        if err = r.reconcileObservability(ctx, false, operatorConfig, cr, nil, cluster.ClusterCTRLClient, cluster.ClusterK8sClient); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

        }
        // If dell connectivity client is deployed, create role/rolebindings in the csm namespaces
        <span class="cov8" title="1">if err = utils.CheckAccAndCreateOrDeleteRbac(ctx, operatorConfig, ctrlClient, false); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// SyncRbac - Sync the current installation - this can lead to a create or update
func (r *ContainerStorageModuleReconciler) SyncRbac(ctx context.Context, _ csmv1.ContainerStorageModule, operatorConfig utils.OperatorConfig, ctrlClient client.Client) error <span class="cov8" title="1">{
        if err := utils.CheckAccAndCreateOrDeleteRbac(ctx, operatorConfig, ctrlClient, true); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// reconcileObservability - Delete/Create/Update observability components
// isDeleting - true: Delete; false: Create/Update
func (r *ContainerStorageModuleReconciler) reconcileObservability(ctx context.Context, isDeleting bool, op utils.OperatorConfig, cr csmv1.ContainerStorageModule, components []string, ctrlClient client.Client, k8sClient kubernetes.Interface) error <span class="cov8" title="1">{
        log := logger.GetLogger(ctx)

        // if components is empty, reconcile all enabled components
        if len(components) == 0 </span><span class="cov8" title="1">{
                if enabled, obs := utils.IsModuleEnabled(ctx, cr, csmv1.Observability); enabled </span><span class="cov8" title="1">{
                        for _, comp := range obs.Components </span><span class="cov8" title="1">{
                                if utils.IsModuleComponentEnabled(ctx, cr, csmv1.Observability, comp.Name) </span><span class="cov8" title="1">{
                                        components = append(components, comp.Name)
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">comp2reconFunc := map[string]func(context.Context, bool, utils.OperatorConfig, csmv1.ContainerStorageModule, client.Client) error{
                modules.ObservabilityTopologyName:         modules.ObservabilityTopology,
                modules.ObservabilityOtelCollectorName:    modules.OtelCollector,
                modules.ObservabilityCertManagerComponent: modules.CommonCertManager,
        }
        metricsComp2reconFunc := map[string]func(context.Context, bool, utils.OperatorConfig, csmv1.ContainerStorageModule, client.Client, kubernetes.Interface) error{
                modules.ObservabilityMetricsPowerScaleName: modules.PowerScaleMetrics,
                modules.ObservabilityMetricsPowerFlexName:  modules.PowerFlexMetrics,
                modules.ObservabilityMetricsPowerMaxName:   modules.PowerMaxMetrics,
        }

        for _, comp := range components </span><span class="cov8" title="1">{
                log.Infow(fmt.Sprintf("reconcile %s", comp))
                var err error
                switch comp </span>{
                case modules.ObservabilityTopologyName, modules.ObservabilityOtelCollectorName, modules.ObservabilityCertManagerComponent:<span class="cov8" title="1">
                        err = comp2reconFunc[comp](ctx, isDeleting, op, cr, ctrlClient)</span>
                case modules.ObservabilityMetricsPowerScaleName, modules.ObservabilityMetricsPowerFlexName, modules.ObservabilityMetricsPowerMaxName:<span class="cov8" title="1">
                        err = metricsComp2reconFunc[comp](ctx, isDeleting, op, cr, ctrlClient, k8sClient)</span>
                default:<span class="cov8" title="1">
                        err = fmt.Errorf("unsupported component type: %v", comp)</span>
                }
                <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                        log.Errorf("failed to reconcile %s", comp)
                        return err
                }</span>
        }

        // We are doing this separately after creating other components because the certificates rely on cert-manager being up
        <span class="cov8" title="1">if err := modules.IssuerCertServiceObs(ctx, isDeleting, op, cr, ctrlClient); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("unable to deploy Certificate &amp; Issuer for Observability: %v", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// reconcileAuthorization - deploy authorization proxy server
func (r *ContainerStorageModuleReconciler) reconcileAuthorization(ctx context.Context, isDeleting bool, op utils.OperatorConfig, cr csmv1.ContainerStorageModule, ctrlClient client.Client) error <span class="cov8" title="1">{
        log := logger.GetLogger(ctx)
        if utils.IsModuleComponentEnabled(ctx, cr, csmv1.AuthorizationServer, modules.AuthProxyServerComponent) </span><span class="cov8" title="1">{
                log.Infow("Reconcile authorization proxy-server")
                if err := modules.AuthorizationServerDeployment(ctx, isDeleting, op, cr, ctrlClient); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("unable to reconcile authorization proxy server: %v", err)
                }</span>

                <span class="cov8" title="1">if err := modules.InstallPolicies(ctx, isDeleting, op, cr, ctrlClient); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("unable to install policies: %v", err)
                }</span>
        }

        <span class="cov8" title="1">if utils.IsModuleComponentEnabled(ctx, cr, csmv1.AuthorizationServer, modules.AuthCertManagerComponent) </span><span class="cov8" title="1">{
                log.Infow("Reconcile authorization cert-manager")
                if err := modules.CommonCertManager(ctx, isDeleting, op, cr, ctrlClient); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("unable to reconcile cert-manager for authorization: %v", err)
                }</span>
        }

        <span class="cov8" title="1">if utils.IsModuleComponentEnabled(ctx, cr, csmv1.AuthorizationServer, modules.AuthNginxIngressComponent) </span><span class="cov8" title="1">{
                log.Infow("Reconcile authorization nginx ingress controller")
                if err := modules.NginxIngressController(ctx, isDeleting, op, cr, ctrlClient); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("unable to reconcile nginx ingress controller for authorization: %v", err)
                }</span>
        }

        // Authorization Ingress rules are applied after NGINX ingress controller is installed
        <span class="cov8" title="1">if utils.IsModuleComponentEnabled(ctx, cr, csmv1.AuthorizationServer, modules.AuthProxyServerComponent) </span><span class="cov8" title="1">{
                log.Infow("Reconcile authorization Ingresses")
                if err := modules.AuthorizationIngress(ctx, isDeleting, op, cr, r, ctrlClient); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("unable to reconcile authorization ingress rules: %v", err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (r *ContainerStorageModuleReconciler) reconcileAppMobilityCRDS(ctx context.Context, op utils.OperatorConfig, cr csmv1.ContainerStorageModule, ctrlClient client.Client) error <span class="cov8" title="1">{
        log := logger.GetLogger(ctx)

        // AppMobility installs Application Mobility CRDS
        if utils.IsAppMobilityComponentEnabled(ctx, cr, r, csmv1.ApplicationMobility, modules.AppMobCtrlMgrComponent) </span><span class="cov8" title="1">{
                log.Infow("Reconcile Application Mobility CRDS")
                if err := modules.AppMobCrdDeploy(ctx, op, cr, ctrlClient); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("unable to reconcile Application Mobility CRDs: %v", err)
                }</span>
                <span class="cov8" title="1">if err := modules.VeleroCrdDeploy(ctx, op, cr, ctrlClient); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("unable to reconcile Velero CRDS : %v", err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// reconcileAppMobility - deploy Application Mobility
func (r *ContainerStorageModuleReconciler) reconcileAppMobility(ctx context.Context, isDeleting bool, op utils.OperatorConfig, cr csmv1.ContainerStorageModule, ctrlClient client.Client) error <span class="cov8" title="1">{
        log := logger.GetLogger(ctx)

        // AppMobility installs Application Mobility Controller Manager
        if utils.IsAppMobilityComponentEnabled(ctx, cr, r, csmv1.ApplicationMobility, modules.AppMobCtrlMgrComponent) </span><span class="cov8" title="1">{
                log.Infow("Reconcile Application Mobility Controller Manager")
                if err := modules.AppMobilityWebhookService(ctx, isDeleting, op, cr, ctrlClient); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("unable to deploy WebhookService for Application Mobility: %v", err)
                }</span>
                <span class="cov8" title="1">if err := modules.ControllerManagerMetricService(ctx, isDeleting, op, cr, ctrlClient); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("unable to deploy MetricService for Application Mobility: %v", err)
                }</span>
                <span class="cov8" title="1">if utils.IsAppMobilityComponentEnabled(ctx, cr, r, csmv1.ApplicationMobility, modules.AppMobCertManagerComponent) </span><span class="cov8" title="1">{
                        if err := modules.CommonCertManager(ctx, isDeleting, op, cr, ctrlClient); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("unable to reconcile cert-manager for Application Mobility: %v", err)
                        }</span>
                }
                <span class="cov8" title="1">if err := modules.IssuerCertService(ctx, isDeleting, op, cr, ctrlClient); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("unable to deploy Certificate &amp; Issuer for Application Mobility: %v", err)
                }</span>
                <span class="cov8" title="1">if err := modules.AppMobilityDeployment(ctx, isDeleting, op, cr, ctrlClient); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("unable to reconcile Application Mobility controller Manager: %v", err)
                }</span>
        }

        // Appmobility installs velero
        <span class="cov8" title="1">if utils.IsAppMobilityComponentEnabled(ctx, cr, r, csmv1.ApplicationMobility, modules.AppMobVeleroComponent) </span><span class="cov8" title="1">{
                log.Infow("Reconcile application mobility velero")
                if err := modules.AppMobilityVelero(ctx, isDeleting, op, cr, ctrlClient); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("unable to reconcile velero for Application Mobility: %v", err)
                }</span>
                <span class="cov8" title="1">if err := modules.UseBackupStorageLoc(ctx, isDeleting, op, cr, ctrlClient); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("unable to apply backupstorage location for Application Mobility: %v", err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func getDriverConfig(ctx context.Context,
        cr csmv1.ContainerStorageModule,
        operatorConfig utils.OperatorConfig,
) (*DriverConfig, error) <span class="cov8" title="1">{
        var (
                err        error
                driver     *storagev1.CSIDriver
                configMap  *corev1.ConfigMap
                node       *utils.NodeYAML
                controller *utils.ControllerYAML
                log        = logger.GetLogger(ctx)
        )

        // if no driver is specified, return nil
        if cr.Spec.Driver.CSIDriverType == "" </span><span class="cov8" title="1">{
                log.Infof("No driver specified in manifest")
                return nil, nil
        }</span>

        // Get Driver resources
        <span class="cov8" title="1">log.Infof("Getting %s CSI Driver for Dell Technologies", cr.Spec.Driver.CSIDriverType)
        driverType := cr.Spec.Driver.CSIDriverType

        if driverType == csmv1.PowerScale </span><span class="cov8" title="1">{
                // use powerscale instead of isilon as the folder name is powerscale
                driverType = csmv1.PowerScaleName
        }</span>
        <span class="cov8" title="1">configMap, err = drivers.GetConfigMap(ctx, cr, operatorConfig, driverType)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("getting %s configMap: %v", driverType, err)
        }</span>

        <span class="cov8" title="1">driver, err = drivers.GetCSIDriver(ctx, cr, operatorConfig, driverType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("getting %s CSIDriver: %v", driverType, err)
        }</span>

        <span class="cov8" title="1">node, err = drivers.GetNode(ctx, cr, operatorConfig, driverType, NodeYaml)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("getting %s node: %v", driverType, err)
        }</span>

        <span class="cov8" title="1">controller, err = drivers.GetController(ctx, cr, operatorConfig, driverType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("getting %s controller: %v", driverType, err)
        }</span>

        <span class="cov8" title="1">return &amp;DriverConfig{
                Driver:     driver,
                ConfigMap:  configMap,
                Node:       node,
                Controller: controller,
        }, nil</span>
}

// reconcileReverseProxy - deploy reverse proxy server
func (r *ContainerStorageModuleReconciler) reconcileReverseProxy(ctx context.Context, isDeleting bool, op utils.OperatorConfig, cr csmv1.ContainerStorageModule, ctrlClient client.Client) error <span class="cov8" title="1">{
        log := logger.GetLogger(ctx)
        log.Infow("Reconcile reverseproxy proxy")
        if err := modules.ReverseProxyServer(ctx, isDeleting, op, cr, ctrlClient); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("unable to reconcile reverse-proxy proxy server: %v", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func removeDriverReplicaCluster(ctx context.Context, cluster utils.ReplicaCluster, driverConfig *DriverConfig) error <span class="cov8" title="1">{
        log := logger.GetLogger(ctx)
        var err error

        log.Infow("removing driver from", cluster.ClusterID)

        if err = utils.DeleteObject(ctx, &amp;driverConfig.Node.Rbac.ServiceAccount, cluster.ClusterCTRLClient); err != nil </span><span class="cov8" title="1">{
                log.Errorw("error delete node service account", "Error", err.Error())
                return err
        }</span>

        <span class="cov8" title="1">if err = utils.DeleteObject(ctx, &amp;driverConfig.Controller.Rbac.ServiceAccount, cluster.ClusterCTRLClient); err != nil </span><span class="cov0" title="0">{
                log.Errorw("error delete controller service account", "Error", err.Error())
                return err
        }</span>

        <span class="cov8" title="1">if err = utils.DeleteObject(ctx, &amp;driverConfig.Node.Rbac.ClusterRole, cluster.ClusterCTRLClient); err != nil </span><span class="cov8" title="1">{
                log.Errorw("error delete node cluster role", "Error", err.Error())
                return err
        }</span>

        <span class="cov8" title="1">if err = utils.DeleteObject(ctx, &amp;driverConfig.Controller.Rbac.ClusterRole, cluster.ClusterCTRLClient); err != nil </span><span class="cov0" title="0">{
                log.Errorw("error delete controller cluster role", "Error", err.Error())
                return err
        }</span>

        <span class="cov8" title="1">if err = utils.DeleteObject(ctx, &amp;driverConfig.Node.Rbac.ClusterRoleBinding, cluster.ClusterCTRLClient); err != nil </span><span class="cov8" title="1">{
                log.Errorw("error delete node cluster role binding", "Error", err.Error())
                return err
        }</span>

        <span class="cov8" title="1">if err = utils.DeleteObject(ctx, &amp;driverConfig.Controller.Rbac.ClusterRoleBinding, cluster.ClusterCTRLClient); err != nil </span><span class="cov0" title="0">{
                log.Errorw("error delete controller cluster role binding", "Error", err.Error())
                return err
        }</span>

        <span class="cov8" title="1">if err = utils.DeleteObject(ctx, driverConfig.ConfigMap, cluster.ClusterCTRLClient); err != nil </span><span class="cov8" title="1">{
                log.Errorw("error delete configmap", "Error", err.Error())
                return err
        }</span>

        <span class="cov8" title="1">if err = utils.DeleteObject(ctx, driverConfig.Driver, cluster.ClusterCTRLClient); err != nil </span><span class="cov8" title="1">{
                log.Errorw("error delete csi driver", "Error", err.Error())
                return err
        }</span>

        <span class="cov8" title="1">daemonsetKey := client.ObjectKey{
                Namespace: *driverConfig.Node.DaemonSetApplyConfig.Namespace,
                Name:      *driverConfig.Node.DaemonSetApplyConfig.Name,
        }

        daemonsetObj := &amp;appsv1.DaemonSet{}
        err = cluster.ClusterCTRLClient.Get(ctx, daemonsetKey, daemonsetObj)
        if err == nil </span><span class="cov8" title="1">{
                if err = cluster.ClusterCTRLClient.Delete(ctx, daemonsetObj); err != nil &amp;&amp; !k8serror.IsNotFound(err) </span><span class="cov8" title="1">{
                        log.Errorw("error delete daemonset", "Error", err.Error())
                        return err
                }</span>
        } else<span class="cov8" title="1"> {
                log.Infow("error getting daemonset", "daemonsetKey", daemonsetKey)
        }</span>

        <span class="cov8" title="1">deploymentKey := client.ObjectKey{
                Namespace: *driverConfig.Controller.Deployment.Namespace,
                Name:      *driverConfig.Controller.Deployment.Name,
        }

        deploymentObj := &amp;appsv1.Deployment{}
        if err = cluster.ClusterCTRLClient.Get(ctx, deploymentKey, deploymentObj); err == nil </span><span class="cov8" title="1">{
                if err = cluster.ClusterCTRLClient.Delete(ctx, deploymentObj); err != nil &amp;&amp; !k8serror.IsNotFound(err) </span><span class="cov8" title="1">{
                        log.Errorw("error delete deployment", "Error", err.Error())
                        return err
                }</span>
        } else<span class="cov8" title="1"> {
                log.Infow("error getting deployment", "deploymentKey", deploymentKey)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *ContainerStorageModuleReconciler) removeDriver(ctx context.Context, instance csmv1.ContainerStorageModule, operatorConfig utils.OperatorConfig) error <span class="cov8" title="1">{
        log := logger.GetLogger(ctx)

        // Get Driver resources
        driverConfig, err := getDriverConfig(ctx, instance, operatorConfig)
        if err != nil </span><span class="cov8" title="1">{
                log.Error("error in getDriverConfig")
                return err
        }</span>
        // driverConfig = nil means no driver specified in manifest
        <span class="cov8" title="1">if driverConfig == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">replicationEnabled, clusterClients, err := utils.GetDefaultClusters(ctx, instance, r)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">for _, cluster := range clusterClients </span><span class="cov8" title="1">{
                if err = removeDriverReplicaCluster(ctx, cluster, driverConfig); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">if replicationEnabled </span><span class="cov8" title="1">{
                        log.Infow("Deleting Replication controller")
                        if err = modules.ReplicationManagerController(ctx, true, operatorConfig, instance, cluster.ClusterCTRLClient); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                // remove module observability
                <span class="cov8" title="1">if observabilityEnabled, _ := utils.IsModuleEnabled(ctx, instance, csmv1.Observability); observabilityEnabled </span><span class="cov8" title="1">{
                        log.Infow("Deleting observability")
                        if err = r.reconcileObservability(ctx, true, operatorConfig, instance, nil, cluster.ClusterCTRLClient, cluster.ClusterK8sClient); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

        }

        <span class="cov8" title="1">return nil</span>
}

// removeModule - remove standalone modules
func (r *ContainerStorageModuleReconciler) removeModule(ctx context.Context, instance csmv1.ContainerStorageModule, operatorConfig utils.OperatorConfig, ctrlClient client.Client) error <span class="cov8" title="1">{
        log := logger.GetLogger(ctx)

        if authorizationEnabled, _ := utils.IsModuleEnabled(ctx, instance, csmv1.AuthorizationServer); authorizationEnabled </span><span class="cov8" title="1">{
                log.Infow("Deleting Authorization Proxy Server")
                if err := r.reconcileAuthorization(ctx, true, operatorConfig, instance, ctrlClient); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">if appMobilityEnabled, _ := utils.IsModuleEnabled(ctx, instance, csmv1.ApplicationMobility); appMobilityEnabled </span><span class="cov8" title="1">{
                log.Infow("Deleting Application Mobility")
                if err := r.reconcileAppMobility(ctx, true, operatorConfig, instance, ctrlClient); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">if reverseproxyEnabled, _ := utils.IsModuleEnabled(ctx, instance, csmv1.ReverseProxy); reverseproxyEnabled </span><span class="cov8" title="1">{
                log.Infow("Deleting ReverseProxy")
                if err := r.reconcileReverseProxy(ctx, true, operatorConfig, instance, ctrlClient); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// PreChecks - validate input values
func (r *ContainerStorageModuleReconciler) PreChecks(ctx context.Context, cr *csmv1.ContainerStorageModule, operatorConfig utils.OperatorConfig) error <span class="cov8" title="1">{
        log := logger.GetLogger(ctx)
        // Check drivers
        switch cr.Spec.Driver.CSIDriverType </span>{
        case csmv1.PowerScale:<span class="cov8" title="1">
                err := drivers.PrecheckPowerScale(ctx, cr, operatorConfig, r.GetClient())
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("failed powerscale validation: %v", err)
                }</span>
        case csmv1.PowerFlex:<span class="cov8" title="1">
                err := drivers.PrecheckPowerFlex(ctx, cr, operatorConfig, r.GetClient())
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("failed powerflex validation: %v", err)
                }</span>
        case csmv1.PowerStore:<span class="cov8" title="1">
                err := drivers.PrecheckPowerStore(ctx, cr, operatorConfig, r.GetClient())
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("failed powerstore validation: %v", err)
                }</span>

        case csmv1.Unity:<span class="cov8" title="1">
                err := drivers.PrecheckUnity(ctx, cr, operatorConfig, r.GetClient())
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("failed unity validation: %v", err)
                }</span>
        case csmv1.PowerMax:<span class="cov8" title="1">
                err := drivers.PrecheckPowerMax(ctx, cr, operatorConfig, r.GetClient())
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("failed powermax validation: %v", err)
                }</span>
        default:<span class="cov8" title="1">
                // Go to checkUpgrade if it is standalone module i.e. app mobility or authorizatio proxy server
                if cr.HasModule(csmv1.ApplicationMobility) || cr.HasModule(csmv1.AuthorizationServer) </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov8" title="1">return fmt.Errorf("unsupported driver type %s", cr.Spec.Driver.CSIDriverType)</span>
        }

        <span class="cov8" title="1">upgradeValid, err := r.checkUpgrade(ctx, cr, operatorConfig)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed upgrade check: %v", err)
        }</span> else<span class="cov8" title="1"> if !upgradeValid </span><span class="cov0" title="0">{
                return fmt.Errorf("failed upgrade check because upgrade is not valid")
        }</span>

        // check for owner reference
        <span class="cov8" title="1">deployments := r.K8sClient.AppsV1().Deployments(cr.Namespace)
        driver, err := deployments.Get(ctx, cr.Name+"-controller", metav1.GetOptions{})
        if err != nil </span><span class="cov8" title="1">{
                log.Infow("Driver not installed yet")
        }</span> else<span class="cov8" title="1"> {
                if driver.GetOwnerReferences() != nil </span><span class="cov8" title="1">{
                        cred := driver.GetOwnerReferences()
                        for _, m := range cred </span><span class="cov8" title="1">{
                                if m.Name == cr.Name </span><span class="cov8" title="1">{
                                        log.Infow("Owner reference is found and matches")
                                        break</span>
                                }
                                <span class="cov0" title="0">return fmt.Errorf("required Owner reference not found. Please re-install driver ")</span>
                        }
                }
        }

        // check modules
        <span class="cov8" title="1">log.Infow("Starting prechecks for modules")
        for _, m := range cr.Spec.Modules </span><span class="cov8" title="1">{
                if m.Enabled </span><span class="cov8" title="1">{
                        switch m.Name </span>{
                        case csmv1.Authorization:<span class="cov8" title="1">
                                if err := modules.AuthorizationPrecheck(ctx, operatorConfig, m, *cr, r.GetClient()); err != nil </span><span class="cov8" title="1">{
                                        return fmt.Errorf("failed authorization validation: %v", err)
                                }</span>

                        case csmv1.AuthorizationServer:<span class="cov8" title="1">
                                if err := modules.AuthorizationServerPrecheck(ctx, operatorConfig, m, *cr, r); err != nil </span><span class="cov8" title="1">{
                                        return fmt.Errorf("failed authorization proxy server validation: %v", err)
                                }</span>

                        case csmv1.Replication:<span class="cov8" title="1">
                                if err := modules.ReplicationPrecheck(ctx, operatorConfig, m, *cr, r); err != nil </span><span class="cov8" title="1">{
                                        return fmt.Errorf("failed replication validation: %v", err)
                                }</span>

                        case csmv1.Resiliency:<span class="cov8" title="1">
                                if err := modules.ResiliencyPrecheck(ctx, operatorConfig, m, *cr, r); err != nil </span><span class="cov8" title="1">{
                                        return fmt.Errorf("failed resiliency validation: %v", err)
                                }</span>

                        case csmv1.Observability:<span class="cov8" title="1">
                                // observability precheck
                                if err := modules.ObservabilityPrecheck(ctx, operatorConfig, m, *cr, r); err != nil </span><span class="cov8" title="1">{
                                        return fmt.Errorf("failed observability validation: %v", err)
                                }</span>
                        case csmv1.ApplicationMobility:<span class="cov8" title="1">
                                // ApplicationMobility precheck
                                if err := modules.ApplicationMobilityPrecheck(ctx, operatorConfig, m, *cr, r); err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed Appmobility validation: %v", err)
                                }</span>
                        case csmv1.ReverseProxy:<span class="cov8" title="1">
                                if err := modules.ReverseProxyPrecheck(ctx, operatorConfig, m, *cr, r); err != nil </span><span class="cov8" title="1">{
                                        return fmt.Errorf("failed reverseproxy validation: %v", err)
                                }</span>
                        default:<span class="cov8" title="1">
                                return fmt.Errorf("unsupported module type %s", m.Name)</span>
                        }
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// Check for upgrade/if upgrade is appropriate
func (r *ContainerStorageModuleReconciler) checkUpgrade(ctx context.Context, cr *csmv1.ContainerStorageModule, operatorConfig utils.OperatorConfig) (bool, error) <span class="cov8" title="1">{
        log := logger.GetLogger(ctx)

        // If it is an upgrade/downgrade, check to see if we meet the minimum version using GetUpgradeInfo, which returns the minimum version required
        // for the desired upgrade. If the upgrade path is not valid fail
        // Existing version
        annotations := cr.GetAnnotations()
        oldVersion, configVersionExists := annotations[configVersionKey]
        // If annotation exists, we are doing an upgrade or modify
        if configVersionExists </span><span class="cov8" title="1">{
                if cr.HasModule(csmv1.AuthorizationServer) </span><span class="cov8" title="1">{
                        newVersion := cr.GetModule(csmv1.AuthorizationServer).ConfigVersion
                        return utils.IsValidUpgrade(ctx, oldVersion, newVersion, csmv1.Authorization, operatorConfig)
                }</span>
                <span class="cov8" title="1">if cr.HasModule(csmv1.ApplicationMobility) </span><span class="cov8" title="1">{
                        newVersion := cr.GetModule(csmv1.ApplicationMobility).ConfigVersion
                        return utils.IsValidUpgrade(ctx, oldVersion, newVersion, csmv1.ApplicationMobility, operatorConfig)
                }</span>
                <span class="cov8" title="1">driverType := cr.Spec.Driver.CSIDriverType
                if driverType == csmv1.PowerScale </span><span class="cov8" title="1">{
                        // use powerscale instead of isilon as the folder name is powerscale
                        driverType = csmv1.PowerScaleName
                }</span>
                <span class="cov8" title="1">newVersion := cr.Spec.Driver.ConfigVersion
                return utils.IsValidUpgrade(ctx, oldVersion, newVersion, driverType, operatorConfig)</span>

        }
        <span class="cov8" title="1">log.Infow("proceeding with fresh driver install")
        return true, nil</span>
}

// applyConfigVersionAnnotations - applies the config version annotation to the instance.
func applyConfigVersionAnnotations(ctx context.Context, instance *csmv1.ContainerStorageModule) bool <span class="cov8" title="1">{
        log := logger.GetLogger(ctx)

        annotations := instance.GetAnnotations()
        if annotations == nil </span><span class="cov8" title="1">{
                annotations = make(map[string]string)
        }</span>

        <span class="cov8" title="1">annotations[CSMVersionKey] = CSMVersion

        var configVersion string
        if instance.HasModule(csmv1.AuthorizationServer) </span><span class="cov8" title="1">{
                configVersion = instance.GetModule(csmv1.AuthorizationServer).ConfigVersion
        }</span> else<span class="cov8" title="1"> if instance.HasModule(csmv1.ApplicationMobility) </span><span class="cov8" title="1">{
                configVersion = instance.GetModule(csmv1.ApplicationMobility).ConfigVersion
        }</span> else<span class="cov8" title="1"> {
                configVersion = instance.Spec.Driver.ConfigVersion
        }</span>

        <span class="cov8" title="1">if annotations[configVersionKey] != configVersion </span><span class="cov8" title="1">{
                annotations[configVersionKey] = configVersion
                log.Infof("Installing csm component %s with config Version %s. Updating Annotations with Config Version",
                        instance.GetName(), configVersion)
                instance.SetAnnotations(annotations)
                return true
        }</span>

        <span class="cov8" title="1">return false</span>
}

// GetClient - returns the split client
func (r *ContainerStorageModuleReconciler) GetClient() client.Client <span class="cov8" title="1">{
        return r.Client
}</span>

// IncrUpdateCount - Increments the update count
func (r *ContainerStorageModuleReconciler) IncrUpdateCount() <span class="cov8" title="1">{
        atomic.AddInt32(&amp;r.updateCount, 1)
}</span>

// GetUpdateCount - Returns the current update count
func (r *ContainerStorageModuleReconciler) GetUpdateCount() int32 <span class="cov8" title="1">{
        return r.updateCount
}</span>

// GetK8sClient - Returns the current update count
func (r *ContainerStorageModuleReconciler) GetK8sClient() kubernetes.Interface <span class="cov8" title="1">{
        return r.K8sClient
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">//  Copyright © 2022 Dell Inc. or its subsidiaries. All Rights Reserved.
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//       http://www.apache.org/licenses/LICENSE-2.0
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package logger

import (
        "context"
        "os"

        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
)

// LogLevel represents the level for the log.
type LogLevel string

const (
        // ProductionLogLevel is the level for the production log.
        ProductionLogLevel LogLevel = "PRODUCTION"
        // DevelopmentLogLevel is the level for development log.
        DevelopmentLogLevel LogLevel = "DEVELOPMENT"
        // EnvLoggerLevel is the environment variable name for log level.
        EnvLoggerLevel = "LOGGER_LEVEL"
        // LogCtxIDKey holds the TraceId for log.
        LogCtxIDKey = "TraceId"
)

var defaultLogLevel LogLevel

// loggerKey holds the context key used for loggers.
type loggerKey struct{}

// SetLoggerLevel helps set defaultLogLevel, using which newLogger func helps
// create either development logger or production logger
func SetLoggerLevel(logLevel LogLevel) <span class="cov8" title="1">{
        defaultLogLevel = logLevel
}</span>

// getLogger returns the logger associated with the given context.
// If there is no logger associated with context, getLogger func will return
// a new logger.
func getLogger(ctx context.Context) *zap.Logger <span class="cov8" title="1">{
        if logger, _ := ctx.Value(loggerKey{}).(*zap.Logger); logger != nil </span><span class="cov8" title="1">{
                return logger
        }</span>
        <span class="cov8" title="1">return newLogger()</span>
}

// GetLogger returns SugaredLogger associated with given context.
func GetLogger(ctx context.Context) *zap.SugaredLogger <span class="cov8" title="1">{
        return getLogger(ctx).Sugar()
}</span>

// NewContextWithLogger returns a new child context with context ID set
func NewContextWithLogger(ctx context.Context, key string) context.Context <span class="cov8" title="1">{
        newCtx := withFields(ctx, zap.String(LogCtxIDKey, key))
        return newCtx
}</span>

// GetNewContextWithLogger creates a new context with context UUID and logger
// set func returns both context and logger to the caller.
func GetNewContextWithLogger(key string) (context.Context, *zap.SugaredLogger) <span class="cov8" title="1">{
        newCtx := NewContextWithLogger(context.Background(), key)
        return newCtx, GetLogger(newCtx)
}</span>

// withFields returns a new context derived from ctx
// that has a logger that always logs the given fields.
func withFields(ctx context.Context, fields ...zapcore.Field) context.Context <span class="cov8" title="1">{
        return context.WithValue(ctx, loggerKey{}, getLogger(ctx).With(fields...))
}</span>

// newLogger creates and return a new logger depending logLevel set.
func newLogger() *zap.Logger <span class="cov8" title="1">{
        pe := zap.NewProductionEncoderConfig()
        pe.EncodeTime = zapcore.ISO8601TimeEncoder
        pe.EncodeLevel = zapcore.CapitalLevelEncoder

        pe.EncodeTime = zapcore.ISO8601TimeEncoder
        consoleEncoder := zapcore.NewConsoleEncoder(pe)

        level := zap.InfoLevel
        level = zap.DebugLevel

        core := zapcore.NewCore(consoleEncoder, zapcore.AddSync(os.Stderr), level)

        l := zap.New(core, zap.AddCaller())
        return l
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">//  Copyright © 2021 - 2022 Dell Inc. or its subsidiaries. All Rights Reserved.
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//       http://www.apache.org/licenses/LICENSE-2.0
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package configmap

import (
        "context"

        corev1 "k8s.io/api/core/v1"

        "github.com/dell/csm-operator/pkg/logger"
        "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/types"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

// SyncConfigMap - Creates/Updates a config map
func SyncConfigMap(ctx context.Context, configMap corev1.ConfigMap, client client.Client) error <span class="cov8" title="1">{
        log := logger.GetLogger(ctx)

        found := &amp;corev1.ConfigMap{}
        err := client.Get(ctx, types.NamespacedName{Name: configMap.Name, Namespace: configMap.Namespace}, found)
        if err != nil &amp;&amp; errors.IsNotFound(err) </span><span class="cov8" title="1">{
                log.Infow("Creating a new ConfigMap", "Name", configMap.Name)
                err = client.Create(ctx, &amp;configMap)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> if err != nil </span><span class="cov8" title="1">{
                log.Errorw("Unknown error.", "Error", err.Error())
                return err
        }</span> else<span class="cov8" title="1"> {
                log.Infow("Updating ConfigMap", "Name:", configMap.Name)
                err = client.Update(ctx, &amp;configMap)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">//  Copyright © 2021 - 2022 Dell Inc. or its subsidiaries. All Rights Reserved.
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//       http://www.apache.org/licenses/LICENSE-2.0
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package csidriver

import (
        "context"

        storagev1 "k8s.io/api/storage/v1"

        "github.com/dell/csm-operator/pkg/logger"
        "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/types"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

// SyncCSIDriver - Syncs a CSI Driver object
func SyncCSIDriver(ctx context.Context, csi storagev1.CSIDriver, client client.Client) error <span class="cov8" title="1">{
        log := logger.GetLogger(ctx)
        found := &amp;storagev1.CSIDriver{}
        err := client.Get(ctx, types.NamespacedName{Name: csi.Name}, found)
        if err != nil &amp;&amp; errors.IsNotFound(err) </span><span class="cov8" title="1">{
                log.Infow("Creating a new CSIDriver", "Name:", csi.Name)
                err = client.Create(ctx, &amp;csi)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> if err != nil </span><span class="cov8" title="1">{
                log.Errorw("Unknown error.", "Error", err.Error())
                return err
        }</span> else<span class="cov8" title="1"> {
                log.Infow("CSIDriver Object exist", "Name:", csi.Name)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">//  Copyright © 2021 - 2022 Dell Inc. or its subsidiaries. All Rights Reserved.
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//       http://www.apache.org/licenses/LICENSE-2.0
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package daemonset

import (
        "context"

        "github.com/dell/csm-operator/pkg/logger"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        appsv1 "k8s.io/client-go/applyconfigurations/apps/v1"
        "k8s.io/client-go/kubernetes"
)

// SyncDaemonset - Syncs a daemonset object
func SyncDaemonset(ctx context.Context, daemonset appsv1.DaemonSetApplyConfiguration, k8sClient kubernetes.Interface, csmName string) error <span class="cov8" title="1">{
        log := logger.GetLogger(ctx)

        log.Infow("Sync DaemonSet:", "name", *daemonset.ObjectMetaApplyConfiguration.Name)

        // Get a config to talk to the apiserver
        daemonsets := k8sClient.AppsV1().DaemonSets(*daemonset.ObjectMetaApplyConfiguration.Namespace)

        found, err := daemonsets.Get(ctx, *daemonset.ObjectMetaApplyConfiguration.Name, metav1.GetOptions{})
        if err != nil </span><span class="cov8" title="1">{
                log.Errorw("get SyncDaemonset error", "Error", err.Error())
        }</span>

        <span class="cov8" title="1">opts := metav1.ApplyOptions{FieldManager: "application/apply-patch"}
        if found == nil || found.Name == "" </span><span class="cov8" title="1">{
                log.Infow("No existing DaemonSet", "Name:", daemonset.Name)
        }</span> else<span class="cov8" title="1"> {
                log.Infow("found daemonset", "image", found.Spec.Template.Spec.Containers[0].Image)
        }</span>

        <span class="cov8" title="1">daemonset.Spec.Template.Labels["csm"] = csmName
        _, err = daemonsets.Apply(ctx, &amp;daemonset, opts)
        if err != nil </span><span class="cov8" title="1">{
                log.Errorw("Apply DaemonSet error", "set", err.Error())
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">//  Copyright © 2021 - 2022 Dell Inc. or its subsidiaries. All Rights Reserved.
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//       http://www.apache.org/licenses/LICENSE-2.0
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package deployment

import (
        "context"
        "time"

        //"fmt"

        "github.com/dell/csm-operator/pkg/logger"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        appsv1 "k8s.io/client-go/applyconfigurations/apps/v1"
        "k8s.io/client-go/kubernetes"
        //"reflect"
)

// SleepTime - minimum time to sleep before checking the state of controller pod
var SleepTime = 10 * time.Second

// SyncDeployment - Syncs a Deployment for controller
func SyncDeployment(ctx context.Context, deployment appsv1.DeploymentApplyConfiguration, k8sClient kubernetes.Interface, csmName string) error <span class="cov8" title="1">{
        log := logger.GetLogger(ctx)

        log.Infow("Sync Deployment:", "name", *deployment.ObjectMetaApplyConfiguration.Name)

        deployments := k8sClient.AppsV1().Deployments(*deployment.ObjectMetaApplyConfiguration.Namespace)

        found, err := deployments.Get(ctx, *deployment.ObjectMetaApplyConfiguration.Name, metav1.GetOptions{})
        if err != nil </span><span class="cov8" title="1">{
                log.Errorw("get SyncDeployment error", "Error", err.Error())
        }</span>
        <span class="cov8" title="1">opts := metav1.ApplyOptions{FieldManager: "application/apply-patch"}
        if found == nil || found.Name == "" </span><span class="cov8" title="1">{
                log.Infow("No existing Deployment", "Name:", deployment.Name)
        }</span> else<span class="cov8" title="1"> {
                log.Infow("found deployment", "image", found.Spec.Template.Spec.Containers[0].Image)
        }</span>

        <span class="cov8" title="1">deployment.Spec.Template.Labels["csm"] = csmName
        set, err := deployments.Apply(ctx, &amp;deployment, opts)
        if err != nil </span><span class="cov8" title="1">{
                log.Errorw("Apply Deployment error", "set", err.Error())
                return err
        }</span>
        <span class="cov8" title="1">log.Infow("deployment apply done", "name", set.Name)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">//  Copyright © 2021 - 2022 Dell Inc. or its subsidiaries. All Rights Reserved.
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//       http://www.apache.org/licenses/LICENSE-2.0
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package rbac

import (
        "context"

        "github.com/dell/csm-operator/pkg/logger"
        rbacv1 "k8s.io/api/rbac/v1"
        "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/types"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

// SyncClusterRole - Syncs a ClusterRole
func SyncClusterRole(ctx context.Context, clusterRole rbacv1.ClusterRole, client client.Client) error <span class="cov8" title="1">{
        log := logger.GetLogger(ctx)
        found := &amp;rbacv1.ClusterRole{}
        err := client.Get(ctx, types.NamespacedName{Name: clusterRole.Name, Namespace: clusterRole.Namespace}, found)
        if err != nil &amp;&amp; errors.IsNotFound(err) </span><span class="cov8" title="1">{
                log.Info("Creating a new ClusterRole", "Name", clusterRole.Name)
                err = client.Create(ctx, &amp;clusterRole)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                // we need to return found object
                <span class="cov8" title="1">err := client.Get(ctx, types.NamespacedName{Name: clusterRole.Name, Namespace: clusterRole.Namespace}, found)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> if err != nil </span><span class="cov8" title="1">{
                log.Info("Unknown error.", "Error", err.Error())
                return err
        }</span> else<span class="cov8" title="1"> {
                log.Info("Updating ClusterRole", "Name:", clusterRole.Name)
                err = client.Update(ctx, &amp;clusterRole)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">//  Copyright © 2021 - 2022 Dell Inc. or its subsidiaries. All Rights Reserved.
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//       http://www.apache.org/licenses/LICENSE-2.0
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package rbac

import (
        "context"

        "github.com/dell/csm-operator/pkg/logger"
        rbacv1 "k8s.io/api/rbac/v1"
        "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/types"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

// SyncClusterRoleBindings - Syncs the ClusterRoleBindings
func SyncClusterRoleBindings(ctx context.Context, rb rbacv1.ClusterRoleBinding, client client.Client) error <span class="cov8" title="1">{
        log := logger.GetLogger(ctx)
        found := &amp;rbacv1.ClusterRoleBinding{}
        err := client.Get(ctx, types.NamespacedName{Name: rb.Name, Namespace: rb.Namespace}, found)
        if err != nil &amp;&amp; errors.IsNotFound(err) </span><span class="cov8" title="1">{
                log.Info("Creating a new ClusterRoleBinding", "Namespace", rb.Namespace, "Name", rb.Name)
                err = client.Create(ctx, &amp;rb)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> if err != nil </span><span class="cov8" title="1">{
                log.Info("Unknown error.", "Error", err.Error())
                return err
        }</span> else<span class="cov8" title="1"> {
                log.Info("Updating ClusterRoleBinding", "Name:", rb.Name)
                err = client.Update(ctx, &amp;rb)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">//  Copyright © 2021 - 2022 Dell Inc. or its subsidiaries. All Rights Reserved.
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//       http://www.apache.org/licenses/LICENSE-2.0
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package serviceaccount

import (
        "context"

        "github.com/dell/csm-operator/pkg/logger"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/types"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

// SyncServiceAccount - Syncs a ServiceAccount
// func SyncServiceAccount(ctx context.Context, sa *corev1.ServiceAccount, client client.Client, csmName string, trcID string) error {
func SyncServiceAccount(ctx context.Context, sa corev1.ServiceAccount, client client.Client) error <span class="cov8" title="1">{
        log := logger.GetLogger(ctx)
        found := &amp;corev1.ServiceAccount{}
        err := client.Get(ctx, types.NamespacedName{Name: sa.Name, Namespace: sa.Namespace}, found)
        if err != nil &amp;&amp; errors.IsNotFound(err) </span><span class="cov8" title="1">{
                log.Infow("Creating a new ServiceAccount", "Namespace", sa.Namespace, "Name", sa.Name)
                err = client.Create(ctx, &amp;sa)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                <span class="cov8" title="1">return nil</span>
        } else<span class="cov8" title="1"> if err != nil </span><span class="cov8" title="1">{
                log.Errorw("Unknown error.", "Error", err.Error())
                return err
        }</span>

        // Updating the service account keeps regenerating the secrets.
        // We dont have to update the service account if it exists.
        <span class="cov8" title="1">log.Infow("ServiceAccount already exists", "Name:", sa.Name)
        return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
