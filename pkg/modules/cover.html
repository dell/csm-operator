
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>modules: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/dell/csm-operator/pkg/modules/application_mobility.go (90.3%)</option>
				
				<option value="file1">github.com/dell/csm-operator/pkg/modules/authorization.go (87.8%)</option>
				
				<option value="file2">github.com/dell/csm-operator/pkg/modules/authorization_deployment_scaffold.go (100.0%)</option>
				
				<option value="file3">github.com/dell/csm-operator/pkg/modules/commonconfig.go (87.5%)</option>
				
				<option value="file4">github.com/dell/csm-operator/pkg/modules/observability.go (91.7%)</option>
				
				<option value="file5">github.com/dell/csm-operator/pkg/modules/replication.go (86.6%)</option>
				
				<option value="file6">github.com/dell/csm-operator/pkg/modules/resiliency.go (92.0%)</option>
				
				<option value="file7">github.com/dell/csm-operator/pkg/modules/reverseproxy.go (92.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">//  Copyright Â© 2023 Dell Inc. or its subsidiaries. All Rights Reserved.
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//       http://www.apache.org/licenses/LICENSE-2.0
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package modules

import (
        "context"
        "fmt"
        "os"
        "path/filepath"
        "strings"

        csmv1 "github.com/dell/csm-operator/api/v1"
        "github.com/dell/csm-operator/pkg/logger"
        operatorutils "github.com/dell/csm-operator/pkg/operatorutils"
        corev1 "k8s.io/api/core/v1"
        k8serrors "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/types"

        crclient "sigs.k8s.io/controller-runtime/pkg/client"
)

const (

        // AppMobDeploymentManifest - filename of deployment manifest for app-mobility
        AppMobDeploymentManifest = "app-mobility-controller-manager.yaml"
        // AppMobMetricService - filename of MetricService manifest for app-mobility
        AppMobMetricService = "app-mobility-controller-manager-metrics-service.yaml"
        // AppMobWebhookService - filename of Webhook manifest for app-mobility
        AppMobWebhookService = "app-mobility-webhook-service.yaml"
        // AppMobCrds - name of app-mobility crd manifest yaml
        AppMobCrds = "app-mobility-crds.yaml"
        // VeleroManifest - filename of Velero manifest for app-mobility
        VeleroManifest = "velero-deployment.yaml"
        // AppMobCertManagerManifest - filename of Cert-manager manifest for app-mobility
        AppMobCertManagerManifest = "cert-manager.yaml"
        // UseVolSnapshotManifest - filename of use volume snapshot manifest for velero
        UseVolSnapshotManifest = "velero-volumesnapshotlocation.yaml"
        // BackupStorageLoc - filename of backupstoragelocation manifest for velero
        BackupStorageLoc = "velero-backupstoragelocation.yaml"
        // CleanupCrdManifest - filename of Cleanup Crds manifest for app-mobility
        CleanupCrdManifest = "cleanupcrds.yaml"
        // VeleroCrdManifest - filename of Velero crds manisfest for Velero feature
        VeleroCrdManifest = "velero-crds.yaml"
        // VeleroAccessManifest - filename where velero access with its contents
        VeleroAccessManifest = "velero-secret.yaml"
        // CertManagerIssuerCertManifest - filename of the issuer and cert for app-mobility
        CertManagerIssuerCertManifest = "certificate.yaml"
        // NodeAgentCrdManifest - filename of node-agent manifest for app-mobility
        NodeAgentCrdManifest = "node-agent.yaml"

        // ControllerImg - image for app-mobility-controller
        ControllerImg = "&lt;CONTROLLER_IMAGE&gt;"
        // ControllerImagePullPolicy - default image pull policy in yamls
        ControllerImagePullPolicy = "&lt;CONTROLLER_IMAGE_PULLPOLICY&gt;"
        // AppMobNamespace - namespace Application Mobility is installed in
        AppMobNamespace = "&lt;NAMESPACE&gt;"
        // AppMobReplicaCount - Number of replicas
        AppMobReplicaCount = "&lt;APPLICATION_MOBILITY_REPLICA_COUNT&gt;"
        // AppMobObjStoreSecretName - Secret name for object store
        AppMobObjStoreSecretName = "&lt;APPLICATION_MOBILITY_OBJECT_STORE_SECRET_NAME&gt;"
        // BackupStorageLocation - name for Backup Storage Location
        BackupStorageLocation = "&lt;BACKUPSTORAGELOCATION_NAME&gt;"
        // VeleroBucketName - name for the used velero bucket
        VeleroBucketName = "&lt;BUCKET_NAME&gt;"
        // VeleroCaCert - name for the used velero cacert
        VeleroCaCert = "&lt;BUCKET_CACERT&gt;"
        // VolSnapshotlocation - name for Volume Snapshot location
        VolSnapshotlocation = "&lt;VOL_SNAPSHOT_LOCATION_NAME&gt;"
        // BackupStorageURL - cloud url for backup storage location
        BackupStorageURL = "&lt;BACKUP_STORAGE_URL&gt;"
        // BackupStorageRegion - region for backup to take place in
        BackupStorageRegion = "&lt;BACKUP_REGION_URL&gt;"
        // BackupStorageRegionDefault - default value if BACKUP_REGION_URL is not specified
        BackupStorageRegionDefault = "region"
        // ConfigProvider - configurations provider
        ConfigProvider = "&lt;CONFIGURATION_PROVIDER&gt;"
        // VeleroImage - Image for velero
        VeleroImage = "&lt;VELERO_IMAGE&gt;"
        // VeleroImagePullPolicy - image pull policy for velero
        VeleroImagePullPolicy = "&lt;VELERO_IMAGE_PULLPOLICY&gt;"
        // VeleroAccess  -  Secret name for velero
        VeleroAccess = "&lt;VELERO_ACCESS&gt;"
        // AWSInitContainerName - Name of init container for velero - aws
        AWSInitContainerName = "&lt;AWS_INIT_CONTAINER_NAME&gt;"
        // AWSInitContainerImage - Image of init container for velero -aws
        AWSInitContainerImage = "&lt;AWS_INIT_CONTAINER_IMAGE&gt;"
        // DELLInitContainerName - Name of init container for velero - dell
        DELLInitContainerName = "&lt;DELL_INIT_CONTAINER_NAME&gt;"
        // DELLInitContainerImage - Image of init container for velero - dell
        DELLInitContainerImage = "&lt;DELL_INIT_CONTAINER_IMAGE&gt;"
        // AccessContents - contents of the object store secret
        AccessContents = "&lt;CRED_CONTENTS&gt;"
        // AKeyID - contains the aws access key id
        AKeyID = "&lt;KEY_ID&gt;"
        // AKey - contains the aws access key
        AKey = "&lt;KEY&gt;"

        // AppMobCtrlMgrComponent - component name in cr for app-mobility controller-manager
        AppMobCtrlMgrComponent = "application-mobility-controller-manager"
        // AppMobCertManagerComponent - cert-manager component
        AppMobCertManagerComponent = "cert-manager"
        // AppMobVeleroComponent - velero component
        AppMobVeleroComponent = "velero"

        // AppMobilityCSMNameSpace - namespace CSM is found in. Needed for cases where pod namespace is not namespace of CSM
        AppMobilityCSMNameSpace string = "&lt;CSM_NAMESPACE&gt;"
)

// ApplicationMobilityOldVersion - old version of application-mobility, will be filled in checkUpgrade
var ApplicationMobilityOldVersion = ""

// getAppMobilityModule - get instance of app mobility module
func getAppMobilityModule(cr csmv1.ContainerStorageModule) (csmv1.Module, error) <span class="cov8" title="1">{
        for _, m := range cr.Spec.Modules </span><span class="cov8" title="1">{
                if m.Name == csmv1.ApplicationMobility </span><span class="cov8" title="1">{
                        return m, nil
                }</span>
        }
        <span class="cov8" title="1">return csmv1.Module{}, fmt.Errorf("Application Mobility module not found")</span>
}

// getVeleroCrdDeploy - applies and deploy VeleroCrd manifest
func getVeleroCrdDeploy(op operatorutils.OperatorConfig, cr csmv1.ContainerStorageModule) (string, error) <span class="cov8" title="1">{
        yamlString := ""

        appMob, err := getAppMobilityModule(cr)
        if err != nil </span><span class="cov8" title="1">{
                return yamlString, err
        }</span>

        <span class="cov8" title="1">veleroCrdPath := fmt.Sprintf("%s/moduleconfig/application-mobility/%s/%s", op.ConfigDirectory, appMob.ConfigVersion, VeleroCrdManifest)
        buf, err := os.ReadFile(filepath.Clean(veleroCrdPath))
        if err != nil </span><span class="cov8" title="1">{
                return yamlString, err
        }</span>

        <span class="cov8" title="1">yamlString = string(buf)

        return yamlString, nil</span>
}

// VeleroCrdDeploy - apply and delete Velero crds deployment
func VeleroCrdDeploy(ctx context.Context, op operatorutils.OperatorConfig, cr csmv1.ContainerStorageModule, ctrlClient crclient.Client) error <span class="cov8" title="1">{
        yamlString, err := getVeleroCrdDeploy(op, cr)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">ctrlObjects, err := operatorutils.GetModuleComponentObj([]byte(yamlString))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for _, ctrlObj := range ctrlObjects </span><span class="cov8" title="1">{
                if err := operatorutils.ApplyObject(ctx, ctrlObj, ctrlClient); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// getAppMobCrdDeploy - apply and deploy app mobility crd manifest
func getAppMobCrdDeploy(op operatorutils.OperatorConfig, cr csmv1.ContainerStorageModule) (string, error) <span class="cov8" title="1">{
        yamlString := ""

        appMob, err := getAppMobilityModule(cr)
        if err != nil </span><span class="cov8" title="1">{
                return yamlString, err
        }</span>

        <span class="cov8" title="1">appMobCrdPath := fmt.Sprintf("%s/moduleconfig/application-mobility/%s/%s", op.ConfigDirectory, appMob.ConfigVersion, AppMobCrds)
        buf, err := os.ReadFile(filepath.Clean(appMobCrdPath))
        if err != nil </span><span class="cov8" title="1">{
                return yamlString, err
        }</span>

        <span class="cov8" title="1">yamlString = string(buf)

        yamlString = strings.ReplaceAll(yamlString, AppMobNamespace, cr.Namespace)
        yamlString = strings.ReplaceAll(yamlString, AppMobilityCSMNameSpace, cr.Namespace)

        return yamlString, nil</span>
}

// AppMobCrdDeploy - apply and delete Velero crds deployment
func AppMobCrdDeploy(ctx context.Context, op operatorutils.OperatorConfig, cr csmv1.ContainerStorageModule, ctrlClient crclient.Client) error <span class="cov8" title="1">{
        yamlString, err := getAppMobCrdDeploy(op, cr)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">ctrlObjects, err := operatorutils.GetModuleComponentObj([]byte(yamlString))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for _, ctrlObj := range ctrlObjects </span><span class="cov8" title="1">{
                if err := operatorutils.ApplyObject(ctx, ctrlObj, ctrlClient); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// getAppMobilityModuleDeployment - updates deployment manifest with app mobility CRD values
func getAppMobilityModuleDeployment(op operatorutils.OperatorConfig, cr csmv1.ContainerStorageModule) (string, error) <span class="cov8" title="1">{
        yamlString := ""
        appMob, err := getAppMobilityModule(cr)
        if err != nil </span><span class="cov8" title="1">{
                return yamlString, err
        }</span>

        <span class="cov8" title="1">deploymentPath := fmt.Sprintf("%s/moduleconfig/application-mobility/%s/%s", op.ConfigDirectory, appMob.ConfigVersion, AppMobDeploymentManifest)
        buf, err := os.ReadFile(filepath.Clean(deploymentPath))
        if err != nil </span><span class="cov8" title="1">{
                return yamlString, err
        }</span>

        <span class="cov8" title="1">yamlString = string(buf)
        controllerImage := ""
        controllerImagePullPolicy := ""
        replicaCount := ""
        objectSecretName := ""

        for _, component := range appMob.Components </span><span class="cov8" title="1">{
                if component.Name == AppMobCtrlMgrComponent </span><span class="cov8" title="1">{
                        controllerImage = string(component.Image)
                        controllerImagePullPolicy = string(component.ImagePullPolicy)
                        for _, env := range component.Envs </span><span class="cov8" title="1">{
                                if strings.Contains(AppMobReplicaCount, env.Name) </span><span class="cov8" title="1">{
                                        replicaCount = env.Value
                                }</span>
                        }
                }
                <span class="cov8" title="1">if component.Name == AppMobVeleroComponent </span><span class="cov8" title="1">{
                        for _, env := range component.Envs </span><span class="cov8" title="1">{
                                if strings.Contains(AppMobObjStoreSecretName, env.Name) </span><span class="cov8" title="1">{
                                        objectSecretName = env.Value
                                }</span>
                        }
                }
                <span class="cov8" title="1">for _, cred := range component.ComponentCred </span><span class="cov8" title="1">{
                        if cred.CreateWithInstall </span><span class="cov8" title="1">{
                                yamlString = strings.ReplaceAll(yamlString, AppMobObjStoreSecretName, cred.Name)
                        }</span> else<span class="cov0" title="0"> {
                                yamlString = strings.ReplaceAll(yamlString, AppMobObjStoreSecretName, objectSecretName)
                        }</span>
                }
        }

        <span class="cov8" title="1">yamlString = strings.ReplaceAll(yamlString, CSMName, cr.Name)
        yamlString = strings.ReplaceAll(yamlString, AppMobNamespace, cr.Namespace)
        yamlString = strings.ReplaceAll(yamlString, ControllerImg, controllerImage)
        yamlString = strings.ReplaceAll(yamlString, ControllerImagePullPolicy, controllerImagePullPolicy)
        yamlString = strings.ReplaceAll(yamlString, AppMobReplicaCount, replicaCount)
        yamlString = strings.ReplaceAll(yamlString, AppMobilityCSMNameSpace, cr.Namespace)

        return yamlString, nil</span>
}

// AppMobilityDeployment - apply and delete controller manager deployment
func AppMobilityDeployment(ctx context.Context, isDeleting bool, op operatorutils.OperatorConfig, cr csmv1.ContainerStorageModule, ctrlClient crclient.Client) error <span class="cov8" title="1">{
        yamlString, err := getAppMobilityModuleDeployment(op, cr)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">er := applyDeleteObjects(ctx, ctrlClient, yamlString, isDeleting)
        if er != nil </span><span class="cov0" title="0">{
                return er
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// getControllerManagerMetricService - updates metric manifest with app mobility CRD values
func getControllerManagerMetricService(op operatorutils.OperatorConfig, cr csmv1.ContainerStorageModule) (string, error) <span class="cov8" title="1">{
        yamlString := ""

        appMob, err := getAppMobilityModule(cr)
        if err != nil </span><span class="cov8" title="1">{
                return yamlString, err
        }</span>

        <span class="cov8" title="1">metricServicePath := fmt.Sprintf("%s/moduleconfig/application-mobility/%s/%s", op.ConfigDirectory, appMob.ConfigVersion, AppMobMetricService)
        buf, err := os.ReadFile(filepath.Clean(metricServicePath))
        if err != nil </span><span class="cov8" title="1">{
                return yamlString, err
        }</span>

        <span class="cov8" title="1">yamlString = string(buf)
        yamlString = strings.ReplaceAll(yamlString, AppMobNamespace, cr.Namespace)

        return yamlString, nil</span>
}

// ControllerManagerMetricService - apply and delete Controller manager metric service deployment
func ControllerManagerMetricService(ctx context.Context, isDeleting bool, op operatorutils.OperatorConfig, cr csmv1.ContainerStorageModule, ctrlClient crclient.Client) error <span class="cov8" title="1">{
        yamlString, err := getControllerManagerMetricService(op, cr)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">er := applyDeleteObjects(ctx, ctrlClient, yamlString, isDeleting)
        if er != nil </span><span class="cov0" title="0">{
                return er
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// getAppMobilityWebhookService - gets the app mobility webhook service manifest
func getAppMobilityWebhookService(op operatorutils.OperatorConfig, cr csmv1.ContainerStorageModule) (string, error) <span class="cov8" title="1">{
        yamlString := ""
        appMob, err := getAppMobilityModule(cr)
        if err != nil </span><span class="cov8" title="1">{
                return yamlString, err
        }</span>

        <span class="cov8" title="1">webhookServicePath := fmt.Sprintf("%s/moduleconfig/application-mobility/%s/%s", op.ConfigDirectory, appMob.ConfigVersion, AppMobWebhookService)
        buf, err := os.ReadFile(filepath.Clean(webhookServicePath))
        if err != nil </span><span class="cov8" title="1">{
                return yamlString, err
        }</span>

        <span class="cov8" title="1">yamlString = string(buf)
        yamlString = strings.ReplaceAll(yamlString, AppMobNamespace, cr.Namespace)

        return yamlString, nil</span>
}

// AppMobilityWebhookService - apply/delete app mobility's webhook service
func AppMobilityWebhookService(ctx context.Context, isDeleting bool, op operatorutils.OperatorConfig, cr csmv1.ContainerStorageModule, ctrlClient crclient.Client) error <span class="cov8" title="1">{
        yamlString, err := getAppMobilityWebhookService(op, cr)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">er := applyDeleteObjects(ctx, ctrlClient, yamlString, isDeleting)
        if er != nil </span><span class="cov0" title="0">{
                return er
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// getIssuerCertService - gets the app mobility cert manager's issuer and certificate manifest
func getIssuerCertService(op operatorutils.OperatorConfig, cr csmv1.ContainerStorageModule) (string, error) <span class="cov8" title="1">{
        yamlString := ""
        appMob, err := getAppMobilityModule(cr)
        if err != nil </span><span class="cov8" title="1">{
                return yamlString, err
        }</span>

        <span class="cov8" title="1">issuerCertServicePath := fmt.Sprintf("%s/moduleconfig/application-mobility/%s/%s", op.ConfigDirectory, appMob.ConfigVersion, CertManagerIssuerCertManifest)
        buf, err := os.ReadFile(filepath.Clean(issuerCertServicePath))
        if err != nil </span><span class="cov8" title="1">{
                return yamlString, err
        }</span>

        <span class="cov8" title="1">yamlString = string(buf)
        yamlString = strings.ReplaceAll(yamlString, AppMobNamespace, cr.Namespace)

        return yamlString, nil</span>
}

// IssuerCertService - apply and delete the app mobility issuer and certificate service
func IssuerCertService(ctx context.Context, isDeleting bool, op operatorutils.OperatorConfig, cr csmv1.ContainerStorageModule, ctrlClient crclient.Client) error <span class="cov8" title="1">{
        yamlString, err := getIssuerCertService(op, cr)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">er := applyDeleteObjects(ctx, ctrlClient, yamlString, isDeleting)
        if er != nil </span><span class="cov0" title="0">{
                return er
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ApplicationMobilityPrecheck - runs precheck for CSM Application Mobility
func ApplicationMobilityPrecheck(ctx context.Context, op operatorutils.OperatorConfig, appMob csmv1.Module, _ csmv1.ContainerStorageModule, r operatorutils.ReconcileCSM) error <span class="cov8" title="1">{
        log := logger.GetLogger(ctx)

        // check if provided version is supported
        if appMob.ConfigVersion != "" </span><span class="cov8" title="1">{
                err := checkVersion(string(csmv1.ApplicationMobility), appMob.ConfigVersion, op.ConfigDirectory)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }

        // Check for secrets
        <span class="cov8" title="1">ns := "default"
        appMobilitySecrets := []string{"dls-license", "iv"}
        for _, name := range appMobilitySecrets </span><span class="cov8" title="1">{
                found := &amp;corev1.Secret{}
                err := r.GetClient().Get(ctx, types.NamespacedName{Name: name, Namespace: ns}, found)
                if err != nil </span><span class="cov8" title="1">{
                        if k8serrors.IsNotFound(err) </span><span class="cov8" title="1">{
                                return fmt.Errorf("failed to find secret %s", name)
                        }</span>
                }
        }

        <span class="cov8" title="1">log.Infof("performed pre-checks for %s", appMob.Name)
        return nil</span>
}

// AppMobilityCertManager - Install/Delete cert-manager
func AppMobilityCertManager(ctx context.Context, isDeleting bool, op operatorutils.OperatorConfig, cr csmv1.ContainerStorageModule, ctrlClient crclient.Client) error <span class="cov8" title="1">{
        yamlString, err := getCertManager(op, cr)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">er := applyDeleteObjects(ctx, ctrlClient, yamlString, isDeleting)
        if er != nil </span><span class="cov0" title="0">{
                return er
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// CreateVeleroAccess - Install/Delete velero-secret yaml from operator config
func CreateVeleroAccess(ctx context.Context, isDeleting bool, op operatorutils.OperatorConfig, cr csmv1.ContainerStorageModule, ctrlClient crclient.Client) error <span class="cov8" title="1">{
        yamlString, err := getCreateVeleroAccess(op, cr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">er := applyDeleteObjects(ctx, ctrlClient, yamlString, isDeleting)
        if er != nil </span><span class="cov0" title="0">{
                return er
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// getCreateVeleroAccess - gets the velero-secret manifest from operatorconfig
func getCreateVeleroAccess(op operatorutils.OperatorConfig, cr csmv1.ContainerStorageModule) (string, error) <span class="cov8" title="1">{
        yamlString := ""

        appMob, err := getAppMobilityModule(cr)
        if err != nil </span><span class="cov0" title="0">{
                return yamlString, err
        }</span>

        <span class="cov8" title="1">veleroAccessPath := fmt.Sprintf("%s/moduleconfig/application-mobility/%s/%s", op.ConfigDirectory, appMob.ConfigVersion, VeleroAccessManifest)
        buf, err := os.ReadFile(filepath.Clean(veleroAccessPath))
        if err != nil </span><span class="cov0" title="0">{
                return yamlString, err
        }</span>

        <span class="cov8" title="1">yamlString = string(buf)
        credName := ""
        backupStorageLocationName := ""
        accessID := ""
        access := ""

        for _, component := range appMob.Components </span><span class="cov8" title="1">{
                if component.Name == AppMobVeleroComponent </span><span class="cov8" title="1">{
                        for _, env := range component.Envs </span><span class="cov8" title="1">{
                                if strings.Contains(BackupStorageLocation, env.Name) </span><span class="cov8" title="1">{
                                        backupStorageLocationName = env.Value
                                }</span>
                        }
                }
                <span class="cov8" title="1">for _, cred := range component.ComponentCred </span><span class="cov8" title="1">{
                        if cred.CreateWithInstall </span><span class="cov8" title="1">{
                                credName = string(cred.Name)
                                accessID = string(cred.SecretContents.AccessKeyID)
                                access = string(cred.SecretContents.AccessKey)

                        }</span>
                }

        }

        <span class="cov8" title="1">yamlString = strings.ReplaceAll(yamlString, AppMobNamespace, cr.Namespace)
        yamlString = strings.ReplaceAll(yamlString, VeleroAccess, credName)
        yamlString = strings.ReplaceAll(yamlString, BackupStorageLocation, backupStorageLocationName)
        yamlString = strings.ReplaceAll(yamlString, AKeyID, accessID)
        yamlString = strings.ReplaceAll(yamlString, AKey, access)
        yamlString = strings.ReplaceAll(yamlString, AppMobilityCSMNameSpace, cr.Namespace)

        return yamlString, nil</span>
}

// AppMobilityVelero - Install/Delete velero along with its features - use volume snapshot location and cleanup crds
func AppMobilityVelero(ctx context.Context, isDeleting bool, op operatorutils.OperatorConfig, cr csmv1.ContainerStorageModule, ctrlClient crclient.Client) error <span class="cov8" title="1">{
        var useSnap bool
        var nodeAgent bool
        envCredName := ""
        compCredName := ""
        log := logger.GetLogger(ctx)

        yamlString, err := getVelero(op, cr)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">er := applyDeleteObjects(ctx, ctrlClient, yamlString, isDeleting)
        if er != nil </span><span class="cov0" title="0">{
                return er
        }</span>

        <span class="cov8" title="1">for _, m := range cr.Spec.Modules </span><span class="cov8" title="1">{
                if m.Name == csmv1.ApplicationMobility </span><span class="cov8" title="1">{
                        for _, c := range m.Components </span><span class="cov8" title="1">{
                                if c.Name == AppMobVeleroComponent </span><span class="cov8" title="1">{
                                        if c.UseSnapshot </span><span class="cov8" title="1">{
                                                useSnap = true
                                        }</span>
                                        <span class="cov8" title="1">if c.DeployNodeAgent </span><span class="cov8" title="1">{
                                                nodeAgent = true
                                        }</span>
                                        <span class="cov8" title="1">for _, env := range c.Envs </span><span class="cov8" title="1">{
                                                if strings.Contains(AppMobObjStoreSecretName, env.Name) </span><span class="cov8" title="1">{
                                                        envCredName = env.Value
                                                }</span>
                                        }
                                        <span class="cov8" title="1">for _, cred := range c.ComponentCred </span><span class="cov8" title="1">{
                                                // if createWithInstall is enabled then create a secret
                                                if cred.CreateWithInstall </span><span class="cov8" title="1">{
                                                        compCredName = string(cred.Name)
                                                        foundCred, _ := operatorutils.GetSecret(ctx, compCredName, cr.Namespace, ctrlClient)
                                                        if foundCred == nil </span><span class="cov8" title="1">{
                                                                // creation of a secret
                                                                err := CreateVeleroAccess(ctx, isDeleting, op, cr, ctrlClient)
                                                                if err != nil </span><span class="cov0" title="0">{
                                                                        return fmt.Errorf("\n Unable to deploy velero-secret for Application Mobility: %v", err)
                                                                }</span>
                                                        }
                                                } else<span class="cov0" title="0"> {
                                                        foundCred, err := operatorutils.GetSecret(ctx, envCredName, cr.Namespace, ctrlClient)
                                                        if foundCred == nil </span><span class="cov0" title="0">{
                                                                log.Errorw("\n The secret : %s ", envCredName, " cannot be found in the provided namespace")
                                                                return fmt.Errorf("\n Unable to deploy velero-secret for Application Mobility: %v", err)
                                                        }</span>
                                                }
                                        }
                                }
                        }
                }
        }

        // create volume snapshot location
        <span class="cov8" title="1">if useSnap </span><span class="cov8" title="1">{

                vsName, yamlString2, err := getUseVolumeSnapshot(ctx, op, cr, ctrlClient)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">volumeSnapshotLoc, _ := operatorutils.GetVolumeSnapshotLocation(ctx, vsName, cr.Namespace, ctrlClient)
                if volumeSnapshotLoc != nil </span><span class="cov0" title="0">{
                        log.Infow("\n Volume Snapshot location Name : ", volumeSnapshotLoc.Name, " already exists and being re-used")
                }</span>

                <span class="cov8" title="1">ctrlObjects, err := operatorutils.GetModuleComponentObj([]byte(yamlString2))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">for _, ctrlObj := range ctrlObjects </span><span class="cov8" title="1">{
                        if !isDeleting </span><span class="cov8" title="1">{
                                if err := operatorutils.ApplyObject(ctx, ctrlObj, ctrlClient); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }
        }

        // enable node agent
        <span class="cov8" title="1">if nodeAgent </span><span class="cov8" title="1">{
                yamlString4, err := getNodeAgent(op, cr)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">newVersion := cr.GetModule(csmv1.ApplicationMobility).ConfigVersion

                // if moving AM versions, need to remove old node agent Daemonset due to name change
                if newVersion != ApplicationMobilityOldVersion &amp;&amp; ApplicationMobilityOldVersion != "" </span><span class="cov8" title="1">{
                        log.Infow("Need to remove old node agent Daemonset")
                        if err := RemoveOldDaemonset(ctx, op, ApplicationMobilityOldVersion, cr, ctrlClient); err != nil </span><span class="cov8" title="1">{
                                log.Warnf("Failed to remove old node agent Daemonset: %s", err)
                        }</span>
                }

                <span class="cov8" title="1">er := applyDeleteObjects(ctx, ctrlClient, yamlString4, isDeleting)
                if er != nil </span><span class="cov0" title="0">{
                        return er
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// getVelero - gets the velero-deployment manifest
func getVelero(op operatorutils.OperatorConfig, cr csmv1.ContainerStorageModule) (string, error) <span class="cov8" title="1">{
        yamlString := ""

        appMob, err := getAppMobilityModule(cr)
        if err != nil </span><span class="cov8" title="1">{
                return yamlString, err
        }</span>

        <span class="cov8" title="1">veleroPath := fmt.Sprintf("%s/moduleconfig/application-mobility/%s/%s", op.ConfigDirectory, appMob.ConfigVersion, VeleroManifest)
        buf, err := os.ReadFile(filepath.Clean(veleroPath))
        if err != nil </span><span class="cov8" title="1">{
                return yamlString, err
        }</span>

        <span class="cov8" title="1">yamlString = string(buf)
        veleroImg := ""
        veleroImgPullPolicy := ""
        veleroAWSInitContainerName := ""
        veleroAWSInitContainerImage := ""
        veleroDELLInitContainerName := ""
        veleroDELLInitContainerImage := ""
        objectSecretName := ""

        for _, component := range appMob.Components </span><span class="cov8" title="1">{
                if component.Name == AppMobVeleroComponent </span><span class="cov8" title="1">{
                        if component.Image != "" </span><span class="cov8" title="1">{
                                veleroImg = string(component.Image)
                        }</span>
                        <span class="cov8" title="1">if component.ImagePullPolicy != "" </span><span class="cov8" title="1">{
                                veleroImgPullPolicy = string(component.ImagePullPolicy)
                        }</span>
                        <span class="cov8" title="1">for _, env := range component.Envs </span><span class="cov8" title="1">{
                                if strings.Contains(AppMobObjStoreSecretName, env.Name) </span><span class="cov8" title="1">{
                                        objectSecretName = env.Value
                                }</span>
                        }
                        <span class="cov8" title="1">for _, cred := range component.ComponentCred </span><span class="cov8" title="1">{
                                if cred.CreateWithInstall </span><span class="cov8" title="1">{
                                        yamlString = strings.ReplaceAll(yamlString, AppMobObjStoreSecretName, cred.Name)
                                }</span> else<span class="cov0" title="0"> {
                                        yamlString = strings.ReplaceAll(yamlString, AppMobObjStoreSecretName, objectSecretName)
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">for _, m := range cr.Spec.Modules </span><span class="cov8" title="1">{
                for _, icontainer := range m.InitContainer </span><span class="cov8" title="1">{
                        if icontainer.Name == "velero-plugin-for-aws" </span><span class="cov8" title="1">{
                                veleroAWSInitContainerName = icontainer.Name
                                veleroAWSInitContainerImage = string(icontainer.Image)
                        }</span>
                        <span class="cov8" title="1">if icontainer.Name == "dell-custom-velero-plugin" </span><span class="cov8" title="1">{
                                veleroDELLInitContainerName = icontainer.Name
                                veleroDELLInitContainerImage = string(icontainer.Image)
                        }</span>
                }
        }

        <span class="cov8" title="1">yamlString = strings.ReplaceAll(yamlString, CSMName, cr.Name)
        yamlString = strings.ReplaceAll(yamlString, AppMobNamespace, cr.Namespace)
        yamlString = strings.ReplaceAll(yamlString, VeleroImage, veleroImg)
        yamlString = strings.ReplaceAll(yamlString, VeleroImagePullPolicy, veleroImgPullPolicy)
        yamlString = strings.ReplaceAll(yamlString, AWSInitContainerName, veleroAWSInitContainerName)
        yamlString = strings.ReplaceAll(yamlString, AWSInitContainerImage, veleroAWSInitContainerImage)
        yamlString = strings.ReplaceAll(yamlString, DELLInitContainerName, veleroDELLInitContainerName)
        yamlString = strings.ReplaceAll(yamlString, DELLInitContainerImage, veleroDELLInitContainerImage)
        yamlString = strings.ReplaceAll(yamlString, AppMobilityCSMNameSpace, cr.Namespace)

        return yamlString, nil</span>
}

// getUseVolumeSnapshot - gets the velero - volume snapshot location manifest
func getUseVolumeSnapshot(_ context.Context, op operatorutils.OperatorConfig, cr csmv1.ContainerStorageModule, _ crclient.Client) (string, string, error) <span class="cov8" title="1">{
        yamlString := ""

        appMob, err := getAppMobilityModule(cr)
        if err != nil </span><span class="cov0" title="0">{
                return "Error: ", yamlString, err
        }</span>

        <span class="cov8" title="1">volSnapshotPath := fmt.Sprintf("%s/moduleconfig/application-mobility/%s/%s", op.ConfigDirectory, appMob.ConfigVersion, UseVolSnapshotManifest)
        buf, err := os.ReadFile(filepath.Clean(volSnapshotPath))
        if err != nil </span><span class="cov0" title="0">{
                return "Error: ", yamlString, err
        }</span>

        <span class="cov8" title="1">yamlString = string(buf)
        volSnapshotLocationName := ""
        provider := ""
        backupRegion := ""
        for _, component := range appMob.Components </span><span class="cov8" title="1">{
                if component.Name == AppMobVeleroComponent </span><span class="cov8" title="1">{
                        for _, env := range component.Envs </span><span class="cov8" title="1">{
                                if strings.Contains(VolSnapshotlocation, env.Name) </span><span class="cov8" title="1">{
                                        volSnapshotLocationName = env.Value
                                }</span>
                                <span class="cov8" title="1">if strings.Contains(ConfigProvider, env.Name) </span><span class="cov8" title="1">{
                                        provider = env.Value
                                }</span>
                                <span class="cov8" title="1">if strings.Contains(BackupStorageRegion, env.Name) </span><span class="cov8" title="1">{
                                        backupRegion = env.Value
                                }</span>
                        }
                }
        }

        // if BackupStorageRegion is not provided - use default variable
        <span class="cov8" title="1">if backupRegion == "" </span><span class="cov8" title="1">{
                backupRegion = BackupStorageRegionDefault
        }</span>

        <span class="cov8" title="1">yamlString = strings.ReplaceAll(yamlString, AppMobNamespace, cr.Namespace)
        yamlString = strings.ReplaceAll(yamlString, VolSnapshotlocation, volSnapshotLocationName)
        yamlString = strings.ReplaceAll(yamlString, ConfigProvider, provider)
        yamlString = strings.ReplaceAll(yamlString, BackupStorageRegion, backupRegion)
        yamlString = strings.ReplaceAll(yamlString, AppMobilityCSMNameSpace, cr.Namespace)

        return volSnapshotLocationName, yamlString, nil</span>
}

// getBackupStorageLoc - gets the velero Backup Storage Location manifest
func getBackupStorageLoc(_ context.Context, op operatorutils.OperatorConfig, cr csmv1.ContainerStorageModule, _ crclient.Client) (string, string, error) <span class="cov8" title="1">{
        yamlString := ""

        appMob, err := getAppMobilityModule(cr)
        if err != nil </span><span class="cov8" title="1">{
                return "Error: ", yamlString, err
        }</span>

        <span class="cov8" title="1">BackupStorageLocPath := fmt.Sprintf("%s/moduleconfig/application-mobility/%s/%s", op.ConfigDirectory, appMob.ConfigVersion, BackupStorageLoc)
        buf, err := os.ReadFile(filepath.Clean(BackupStorageLocPath))
        if err != nil </span><span class="cov8" title="1">{
                return "Error: ", yamlString, err
        }</span>

        <span class="cov8" title="1">yamlString = string(buf)
        backupStorageLocationName := ""
        provider := ""
        bucketName := ""
        backupURL := ""
        backupRegion := ""
        bucketCacert := ""
        for _, component := range appMob.Components </span><span class="cov8" title="1">{
                if component.Name == AppMobVeleroComponent </span><span class="cov8" title="1">{
                        for _, env := range component.Envs </span><span class="cov8" title="1">{
                                if strings.Contains(BackupStorageLocation, env.Name) </span><span class="cov8" title="1">{
                                        backupStorageLocationName = env.Value
                                }</span>
                                <span class="cov8" title="1">if strings.Contains(VeleroBucketName, env.Name) </span><span class="cov8" title="1">{
                                        bucketName = env.Value
                                }</span>
                                <span class="cov8" title="1">if strings.Contains(ConfigProvider, env.Name) </span><span class="cov8" title="1">{
                                        provider = env.Value
                                }</span>
                                <span class="cov8" title="1">if strings.Contains(BackupStorageURL, env.Name) </span><span class="cov8" title="1">{
                                        backupURL = env.Value
                                }</span>
                                <span class="cov8" title="1">if strings.Contains(BackupStorageRegion, env.Name) </span><span class="cov8" title="1">{
                                        backupRegion = env.Value
                                }</span>
                                <span class="cov8" title="1">if strings.Contains(VeleroCaCert, env.Name) </span><span class="cov0" title="0">{
                                        bucketCacert = env.Value
                                }</span>
                        }
                }
        }

        // if BackupStorageRegion is not provided - use default variable
        <span class="cov8" title="1">if backupRegion == "" </span><span class="cov8" title="1">{
                backupRegion = BackupStorageRegionDefault
        }</span>

        <span class="cov8" title="1">yamlString = strings.ReplaceAll(yamlString, AppMobNamespace, cr.Namespace)
        yamlString = strings.ReplaceAll(yamlString, BackupStorageLocation, backupStorageLocationName)
        yamlString = strings.ReplaceAll(yamlString, VeleroBucketName, bucketName)
        yamlString = strings.ReplaceAll(yamlString, BackupStorageURL, backupURL)
        yamlString = strings.ReplaceAll(yamlString, ConfigProvider, provider)
        yamlString = strings.ReplaceAll(yamlString, BackupStorageRegion, backupRegion)
        yamlString = strings.ReplaceAll(yamlString, VeleroCaCert, bucketCacert)
        yamlString = strings.ReplaceAll(yamlString, AppMobilityCSMNameSpace, cr.Namespace)

        return backupStorageLocationName, yamlString, nil</span>
}

// UseBackupStorageLoc - Apply/Delete velero-backupstoragelocation yaml from operator config
func UseBackupStorageLoc(ctx context.Context, isDeleting bool, op operatorutils.OperatorConfig, cr csmv1.ContainerStorageModule, ctrlClient crclient.Client) error <span class="cov8" title="1">{
        log := logger.GetLogger(ctx)
        bslName, yamlString, err := getBackupStorageLoc(ctx, op, cr, ctrlClient)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">backupStorageLoc, _ := operatorutils.GetBackupStorageLocation(ctx, bslName, cr.Namespace, ctrlClient)
        if backupStorageLoc != nil </span><span class="cov0" title="0">{
                log.Infow("\n Backup Storage Name : ", backupStorageLoc.Name, "already exists and being re-used")
        }</span>

        <span class="cov8" title="1">ctrlObjects, err := operatorutils.GetModuleComponentObj([]byte(yamlString))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for _, ctrlObj := range ctrlObjects </span><span class="cov8" title="1">{
                if !isDeleting </span><span class="cov0" title="0">{
                        if err := operatorutils.ApplyObject(ctx, ctrlObj, ctrlClient); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// getNodeAgent - gets node-agent services manifests
func getNodeAgent(op operatorutils.OperatorConfig, cr csmv1.ContainerStorageModule) (string, error) <span class="cov8" title="1">{
        yamlString := ""

        appMob, err := getAppMobilityModule(cr)
        if err != nil </span><span class="cov0" title="0">{
                return yamlString, err
        }</span>
        <span class="cov8" title="1">cleanupCrdsPath := fmt.Sprintf("%s/moduleconfig/application-mobility/%s/%s", op.ConfigDirectory, appMob.ConfigVersion, NodeAgentCrdManifest)
        buf, err := os.ReadFile(filepath.Clean(cleanupCrdsPath))
        if err != nil </span><span class="cov0" title="0">{
                return yamlString, err
        }</span>

        <span class="cov8" title="1">yamlString = string(buf)
        veleroImgPullPolicy := ""
        veleroImg := ""
        objectSecretName := ""

        for _, component := range appMob.Components </span><span class="cov8" title="1">{
                if component.Name == AppMobVeleroComponent </span><span class="cov8" title="1">{
                        if component.Image != "" </span><span class="cov8" title="1">{
                                veleroImg = string(component.Image)
                        }</span>
                        <span class="cov8" title="1">if component.ImagePullPolicy != "" </span><span class="cov8" title="1">{
                                veleroImgPullPolicy = string(component.ImagePullPolicy)
                        }</span>
                        <span class="cov8" title="1">for _, env := range component.Envs </span><span class="cov8" title="1">{
                                if strings.Contains(AppMobObjStoreSecretName, env.Name) </span><span class="cov8" title="1">{
                                        objectSecretName = env.Value
                                }</span>
                        }
                        <span class="cov8" title="1">for _, cred := range component.ComponentCred </span><span class="cov8" title="1">{
                                if cred.CreateWithInstall </span><span class="cov8" title="1">{
                                        yamlString = strings.ReplaceAll(yamlString, AppMobObjStoreSecretName, cred.Name)
                                }</span> else<span class="cov0" title="0"> {
                                        yamlString = strings.ReplaceAll(yamlString, AppMobObjStoreSecretName, objectSecretName)
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">yamlString = strings.ReplaceAll(yamlString, VeleroImage, veleroImg)
        yamlString = strings.ReplaceAll(yamlString, AppMobNamespace, cr.Namespace)
        yamlString = strings.ReplaceAll(yamlString, VeleroImagePullPolicy, veleroImgPullPolicy)
        yamlString = strings.ReplaceAll(yamlString, AppMobilityCSMNameSpace, cr.Namespace)
        return yamlString, nil</span>
}

// applyDeleteObjects - Applies/Deletes the object based on boolean value
func applyDeleteObjects(ctx context.Context, ctrlClient crclient.Client, yamlString string, isDeleting bool) error <span class="cov8" title="1">{
        ctrlObjects, err := operatorutils.GetModuleComponentObj([]byte(yamlString))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for _, ctrlObj := range ctrlObjects </span><span class="cov8" title="1">{
                if isDeleting </span><span class="cov8" title="1">{
                        if err := operatorutils.DeleteObject(ctx, ctrlObj, ctrlClient); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                } else<span class="cov8" title="1"> {
                        if err := operatorutils.ApplyObject(ctx, ctrlObj, ctrlClient); err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// RemoveOldDaemonset is used to remove Daemonset if switching between AM versions
func RemoveOldDaemonset(ctx context.Context, op operatorutils.OperatorConfig, oldVersion string, cr csmv1.ContainerStorageModule, ctrlClient crclient.Client) error <span class="cov8" title="1">{
        log := logger.GetLogger(ctx)
        // need to delete the old Daemonset, which is found in versions v1.0.3 or lower
        log.Infof("removing application-mobility-node-agent daemonset from %s namespace", cr.Namespace)
        oldNodeAgentPath := fmt.Sprintf("%s/moduleconfig/application-mobility/%s/%s", op.ConfigDirectory, oldVersion, NodeAgentCrdManifest)

        buf, err := os.ReadFile(filepath.Clean(oldNodeAgentPath))
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to find read old node-agent manifests at path: %s", oldNodeAgentPath)
        }</span>
        <span class="cov0" title="0">yamlString := string(buf)
        yamlString = strings.ReplaceAll(yamlString, AppMobNamespace, cr.Namespace)
        yamlString = strings.ReplaceAll(yamlString, AppMobilityCSMNameSpace, cr.Namespace)
        return applyDeleteObjects(context.Background(), ctrlClient, yamlString, true)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">//  Copyright Â© 2021 - 2025 Dell Inc. or its subsidiaries. All Rights Reserved.
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//       http://www.apache.org/licenses/LICENSE-2.0
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package modules

import (
        "context"
        "encoding/base64"
        "encoding/json"
        "errors"
        "fmt"
        "os"
        "path/filepath"
        "strconv"
        "strings"
        "time"

        certificate "github.com/cert-manager/cert-manager/pkg/apis/certmanager/v1"
        cmmetav1 "github.com/cert-manager/cert-manager/pkg/apis/meta/v1"
        csmv1 "github.com/dell/csm-operator/api/v1"
        drivers "github.com/dell/csm-operator/pkg/drivers"
        "github.com/dell/csm-operator/pkg/logger"
        operatorutils "github.com/dell/csm-operator/pkg/operatorutils"
        "golang.org/x/mod/semver"
        corev1 "k8s.io/api/core/v1"
        networking "k8s.io/api/networking/v1"
        k8serrors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/types"
        applyv1 "k8s.io/client-go/applyconfigurations/apps/v1"
        acorev1 "k8s.io/client-go/applyconfigurations/core/v1"
        crclient "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/yaml"
)

const (
        // AuthDeploymentManifest - deployment resources and ingress rules for authorization module
        AuthDeploymentManifest = "deployment.yaml"
        // AuthIngressManifest -
        AuthIngressManifest = "ingress.yaml"
        // AuthCertManagerManifest -
        AuthCertManagerManifest = "cert-manager.yaml"
        // AuthNginxIngressManifest -
        AuthNginxIngressManifest = "nginx-ingress-controller.yaml"
        // AuthPolicyManifest -
        AuthPolicyManifest = "policies.yaml"
        // AuthLocalProvisionerManifest -
        AuthLocalProvisionerManifest = "local-provisioner.yaml"
        // AuthCustomCert - custom certificate file
        AuthCustomCert = "custom-cert.yaml"

        // AuthNamespace -
        AuthNamespace = "&lt;NAMESPACE&gt;"
        // AuthServerImage -
        AuthServerImage = "&lt;AUTHORIZATION_PROXY_SERVER_IMAGE&gt;"
        // AuthProxyServiceReplicas -
        AuthProxyServiceReplicas = "&lt;AUTHORIZATION_PROXY_SERVICE_REPLICAS&gt;"
        // AuthOpaImage -
        AuthOpaImage = "&lt;AUTHORIZATION_OPA_IMAGE&gt;"
        // AuthOpaKubeMgmtImage -
        AuthOpaKubeMgmtImage = "&lt;AUTHORIZATION_OPA_KUBEMGMT_IMAGE&gt;"
        // AuthTenantServiceImage -
        AuthTenantServiceImage = "&lt;AUTHORIZATION_TENANT_SERVICE_IMAGE&gt;"
        // AuthTenantServiceReplicas -
        AuthTenantServiceReplicas = "&lt;AUTHORIZATION_TENANT_SERVICE_REPLICAS&gt;"
        // AuthRoleServiceImage -
        AuthRoleServiceImage = "&lt;AUTHORIZATION_ROLE_SERVICE_IMAGE&gt;"
        // AuthRoleServiceReplicas -
        AuthRoleServiceReplicas = "&lt;AUTHORIZATION_ROLE_SERVICE_REPLICAS&gt;"
        // AuthStorageServiceImage -
        AuthStorageServiceImage = "&lt;AUTHORIZATION_STORAGE_SERVICE_IMAGE&gt;"
        // AuthStorageServiceReplicas -
        AuthStorageServiceReplicas = "&lt;AUTHORIZATION_STORAGE_SERVICE_REPLICAS&gt;"
        // AuthRedisImage -
        AuthRedisImage = "&lt;AUTHORIZATION_REDIS_IMAGE&gt;"
        // AuthRedisCommanderImage -
        AuthRedisCommanderImage = "&lt;AUTHORIZATION_REDIS_COMMANDER_IMAGE&gt;"
        // AuthRedisStorageClass -
        AuthRedisStorageClass = "&lt;REDIS_STORAGE_CLASS&gt;"
        // AuthControllerImage -
        AuthControllerImage = "&lt;AUTHORIZATION_CONTROLLER_IMAGE&gt;"
        // AuthControllerReplicas -
        AuthControllerReplicas = "&lt;AUTHORIZATION_CONTROLLER_REPLICAS&gt;"
        // AuthLeaderElectionEnabled -
        AuthLeaderElectionEnabled = "&lt;AUTHORIZATION_LEADER_ELECTION_ENABLED&gt;"
        // AuthControllerReconcileInterval -
        AuthControllerReconcileInterval = "&lt;AUTHORIZATION_CONTROLLER_RECONCILE_INTERVAL&gt;"

        // AuthProxyHost -
        AuthProxyHost = "&lt;AUTHORIZATION_HOSTNAME&gt;"
        // AuthProxyIngressHost -
        AuthProxyIngressHost = "&lt;PROXY_INGRESS_HOST&gt;"

        // AuthVaultAddress -
        AuthVaultAddress = "&lt;AUTHORIZATION_VAULT_ADDRESS&gt;"
        // AuthVaultRole -
        AuthVaultRole = "&lt;AUTHORIZATION_VAULT_ROLE&gt;"
        // AuthSkipCertificateValidation -
        AuthSkipCertificateValidation = "&lt;AUTHORIZATION_SKIP_CERTIFICATE_VALIDATION&gt;"
        // AuthKvEnginePath -
        AuthKvEnginePath = "&lt;AUTHORIZATION_KV_ENGINE_PATH&gt;"
        // AuthRedisName -
        AuthRedisName = "&lt;AUTHORIZATION_REDIS_NAME&gt;"
        // AuthRedisCommander -
        AuthRedisCommander = "&lt;AUTHORIZATION_REDIS_COMMANDER&gt;"
        // AuthRedisSentinel -
        AuthRedisSentinel = "&lt;AUTHORIZATION_REDIS_SENTINEL&gt;"
        // AuthRedisSentinelValues -
        AuthRedisSentinelValues = "&lt;AUTHORIZATION_REDIS_SENTINEL_VALUES&gt;"
        // AuthRedisReplicas -
        AuthRedisReplicas = "&lt;AUTHORIZATION_REDIS_REPLICAS&gt;"

        // AuthCert - for tls secret
        AuthCert = "&lt;BASE64_CERTIFICATE&gt;"
        // AuthPrivateKey - for tls secret
        AuthPrivateKey = "&lt;BASE64_PRIVATE_KEY&gt;"

        // AuthProxyServerComponent - proxy-server component
        AuthProxyServerComponent = "proxy-server"
        // AuthSidecarComponent - karavi-authorization-proxy component
        AuthSidecarComponent = "karavi-authorization-proxy"
        // AuthNginxIngressComponent - nginx component
        AuthNginxIngressComponent = "nginx"
        // AuthCertManagerComponent - cert-manager component
        AuthCertManagerComponent = "cert-manager"
        // AuthRedisComponent - redis component
        AuthRedisComponent = "redis"
        // AuthVaultComponent - vault component
        AuthVaultComponent = "vault"
        // AuthStorageSystemCredentialsComponent - storage-system-credentials component
        AuthStorageSystemCredentialsComponent = "storage-system-credentials"
        // defaultRedisSecretName - name of default redis K8s secret
        defaultRedisSecretName = "redis-csm-secret"

        // AuthLocalStorageClass -
        AuthLocalStorageClass = "csm-authorization-local-storage"

        // AuthCrds - name of authorization crd manifest yaml
        AuthCrds = "authorization-crds.yaml"

        // AuthCSMNameSpace - namespace CSM is found in. Needed for cases where pod namespace is not namespace of CSM
        AuthCSMNameSpace string = "&lt;CSM_NAMESPACE&gt;"
)

var (
        redisStorageClass     string
        redisSecretName       string
        redisUsernameKey      string
        redisPasswordKey      string
        authHostname          string
        proxyIngressClassName string
        authCertificate       string
        authPrivateKey        string
        secretName            string

        pathType    = networking.PathTypePrefix
        duration    = 2160 * time.Hour // 90d
        renewBefore = 360 * time.Hour  // 15d
)

// AuthorizationSupportedDrivers ... is a map containing the CSI Drivers supported by CSM Authorization. The key is driver name and the value is the driver plugin identifier
var AuthorizationSupportedDrivers = map[string]SupportedDriverParam{
        "powerscale": {
                PluginIdentifier:              drivers.PowerScalePluginIdentifier,
                DriverConfigParamsVolumeMount: drivers.PowerScaleConfigParamsVolumeMount,
        },
        "isilon": {
                PluginIdentifier:              drivers.PowerScalePluginIdentifier,
                DriverConfigParamsVolumeMount: drivers.PowerScaleConfigParamsVolumeMount,
        },
        "powerflex": {
                PluginIdentifier:              drivers.PowerFlexPluginIdentifier,
                DriverConfigParamsVolumeMount: drivers.PowerFlexConfigParamsVolumeMount,
        },
        "vxflexos": {
                PluginIdentifier:              drivers.PowerFlexPluginIdentifier,
                DriverConfigParamsVolumeMount: drivers.PowerFlexConfigParamsVolumeMount,
        }, // powerscale/isilon &amp; powerflex/vxflexos are valid types
        "powermax": {
                PluginIdentifier:              drivers.PowerMaxPluginIdentifier,
                DriverConfigParamsVolumeMount: drivers.PowerMaxConfigParamsVolumeMount,
        },
}

func getAuthorizationModule(cr csmv1.ContainerStorageModule) (csmv1.Module, error) <span class="cov8" title="1">{
        for _, m := range cr.Spec.Modules </span><span class="cov8" title="1">{
                if m.Name == csmv1.AuthorizationServer </span><span class="cov8" title="1">{
                        return m, nil
                }</span>
        }
        <span class="cov8" title="1">return csmv1.Module{}, fmt.Errorf("authorization module not found")</span>
}

// CheckAnnotationAuth --
func CheckAnnotationAuth(annotation map[string]string) error <span class="cov8" title="1">{
        if annotation != nil </span><span class="cov8" title="1">{
                fmt.Println(annotation)
                if _, ok := annotation["com.dell.karavi-authorization-proxy"]; !ok </span><span class="cov8" title="1">{
                        return errors.New("com.dell.karavi-authorization-proxy is missing from annotation")
                }</span>
                <span class="cov8" title="1">if annotation["com.dell.karavi-authorization-proxy"] != "true" </span><span class="cov8" title="1">{
                        return fmt.Errorf("expected notation value to be true but got %s", annotation["com.dell.karavi-authorization-proxy"])
                }</span>
                <span class="cov8" title="1">return nil</span>
        }
        <span class="cov8" title="1">return errors.New("annotation is nil")</span>
}

// CheckApplyVolumesAuth --
func CheckApplyVolumesAuth(volumes []acorev1.VolumeApplyConfiguration) error <span class="cov8" title="1">{
        // Volume
        volumeNames := []string{"karavi-authorization-config"}
NAME_LOOP:
        for _, volName := range volumeNames </span><span class="cov8" title="1">{
                for _, vol := range volumes </span><span class="cov8" title="1">{
                        if *vol.Name == volName </span><span class="cov8" title="1">{
                                continue NAME_LOOP</span>
                        }
                }
                <span class="cov8" title="1">return fmt.Errorf("missing the following volume %s", volName)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// CheckApplyContainersAuth --
func CheckApplyContainersAuth(containers []acorev1.ContainerApplyConfiguration, drivertype string, skipCertificateValidation bool) error <span class="cov8" title="1">{
        authString := "karavi-authorization-proxy"
        for _, cnt := range containers </span><span class="cov8" title="1">{
                if *cnt.Name == authString </span><span class="cov8" title="1">{
                        volumeMounts := []string{"karavi-authorization-config", AuthorizationSupportedDrivers[drivertype].DriverConfigParamsVolumeMount}
                MOUNT_NAME_LOOP:
                        for _, volName := range volumeMounts </span><span class="cov8" title="1">{
                                for _, vol := range cnt.VolumeMounts </span><span class="cov8" title="1">{
                                        if *vol.Name == volName </span><span class="cov8" title="1">{
                                                continue MOUNT_NAME_LOOP</span>
                                        }
                                }
                                <span class="cov8" title="1">return fmt.Errorf("missing the following volume mount %s", volName)</span>
                        }

                        <span class="cov8" title="1">for _, env := range cnt.Env </span><span class="cov8" title="1">{
                                if *env.Name == "SKIP_CERTIFICATE_VALIDATION" || *env.Name == "INSECURE" </span><span class="cov8" title="1">{
                                        if _, err := strconv.ParseBool(*env.Value); err != nil </span><span class="cov8" title="1">{
                                                return fmt.Errorf("%s is an invalid value for SKIP_CERTIFICATE_VALIDATION: %v", *env.Value, err)
                                        }</span>

                                        <span class="cov8" title="1">if skipCertificateValidation </span><span class="cov8" title="1">{
                                                if *env.Value != "true" </span><span class="cov8" title="1">{
                                                        return fmt.Errorf("expected SKIP_CERTIFICATE_VALIDATION/INSECURE to be true")
                                                }</span>
                                        } else<span class="cov8" title="1"> {
                                                if *env.Value != "false" </span><span class="cov0" title="0">{
                                                        return fmt.Errorf("expected SKIP_CERTIFICATE_VALIDATION/INSECURE to be false")
                                                }</span>
                                        }
                                }
                                <span class="cov8" title="1">if *env.Name == "PROXY_HOST" &amp;&amp; *env.Value == "" </span><span class="cov8" title="1">{
                                        return fmt.Errorf("PROXY_HOST for authorization is empty")
                                }</span>
                        }
                        <span class="cov8" title="1">return nil</span>
                }
        }
        <span class="cov8" title="1">return errors.New("karavi-authorization-proxy container was not injected into driver")</span>
}

func getAuthApplyCR(cr csmv1.ContainerStorageModule, op operatorutils.OperatorConfig) (*csmv1.Module, *acorev1.ContainerApplyConfiguration, error) <span class="cov8" title="1">{
        var err error
        authModule := csmv1.Module{}
        for _, m := range cr.Spec.Modules </span><span class="cov8" title="1">{
                if m.Name == csmv1.Authorization </span><span class="cov8" title="1">{
                        authModule = m
                        break</span>
                }
        }

        <span class="cov8" title="1">authConfigVersion := authModule.ConfigVersion
        if authConfigVersion == "" </span><span class="cov8" title="1">{
                authConfigVersion, err = operatorutils.GetModuleDefaultVersion(cr.Spec.Driver.ConfigVersion, cr.Spec.Driver.CSIDriverType, csmv1.Authorization, op.ConfigDirectory)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, nil, err
                }</span>
        }

        <span class="cov8" title="1">configMapPath := fmt.Sprintf("%s/moduleconfig/authorization/%s/container.yaml", op.ConfigDirectory, authConfigVersion)
        buf, err := os.ReadFile(filepath.Clean(configMapPath))
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">YamlString := operatorutils.ModifyCommonCR(string(buf), cr)

        YamlString = strings.ReplaceAll(YamlString, DefaultPluginIdentifier, AuthorizationSupportedDrivers[string(cr.Spec.Driver.CSIDriverType)].PluginIdentifier)
        YamlString = strings.ReplaceAll(YamlString, AuthCSMNameSpace, cr.Namespace)

        var container acorev1.ContainerApplyConfiguration
        err = yaml.Unmarshal([]byte(YamlString), &amp;container)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">for i, component := range authModule.Components </span><span class="cov8" title="1">{
                if component.Name == "karavi-authorization-proxy" </span><span class="cov8" title="1">{
                        skipcertFound := false
                        for _, env := range authModule.Components[i].Envs </span><span class="cov8" title="1">{
                                if env.Name == "SKIP_CERTIFICATE_VALIDATION" </span><span class="cov8" title="1">{
                                        skipcertFound = true
                                        break</span>
                                }
                        }
                        // If SKIP_CERTIFICATE_VALIDATION is not found, add it
                        <span class="cov8" title="1">if !skipcertFound </span><span class="cov8" title="1">{
                                authModule.Components[i].Envs = append(authModule.Components[i].Envs, corev1.EnvVar{
                                        Name:  "SKIP_CERTIFICATE_VALIDATION",
                                        Value: "true",
                                })
                        }</span>
                }
        }
        <span class="cov8" title="1">container.Env = operatorutils.ReplaceAllApplyCustomEnvs(container.Env, authModule.Components[0].Envs, authModule.Components[0].Envs)

        skipCertValid := false
        for _, env := range authModule.Components[0].Envs </span><span class="cov8" title="1">{
                if env.Name == "INSECURE" || env.Name == "SKIP_CERTIFICATE_VALIDATION" </span><span class="cov8" title="1">{
                        skipCertValid, _ = strconv.ParseBool(env.Value)
                }</span>
        }

        <span class="cov8" title="1">certString := "proxy-server-root-certificate"
        if skipCertValid </span><span class="cov8" title="1">{ // do not mount proxy-server-root-certificate
                for i, c := range container.VolumeMounts </span><span class="cov8" title="1">{
                        if *c.Name == certString </span><span class="cov8" title="1">{
                                container.VolumeMounts[i] = container.VolumeMounts[len(container.VolumeMounts)-1]
                                container.VolumeMounts = container.VolumeMounts[:len(container.VolumeMounts)-1]
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                for i, e := range container.Env </span><span class="cov8" title="1">{
                        if *e.Name == "INSECURE" || *e.Name == "SKIP_CERTIFICATE_VALIDATION" </span><span class="cov8" title="1">{
                                value := strconv.FormatBool(skipCertValid)
                                container.Env[i].Value = &amp;value
                        }</span>
                }
        }
        <span class="cov8" title="1">for i, c := range container.VolumeMounts </span><span class="cov8" title="1">{
                if *c.Name == DefaultDriverConfigParamsVolumeMount </span><span class="cov8" title="1">{
                        newName := AuthorizationSupportedDrivers[string(cr.Spec.Driver.CSIDriverType)].DriverConfigParamsVolumeMount
                        container.VolumeMounts[i].Name = &amp;newName
                        break</span>
                }
        }

        <span class="cov8" title="1">return &amp;authModule, &amp;container, nil</span>
}

func getAuthApplyVolumes(cr csmv1.ContainerStorageModule, op operatorutils.OperatorConfig, auth csmv1.ContainerTemplate) ([]acorev1.VolumeApplyConfiguration, error) <span class="cov8" title="1">{
        version, err := operatorutils.GetModuleDefaultVersion(cr.Spec.Driver.ConfigVersion, cr.Spec.Driver.CSIDriverType, csmv1.Authorization, op.ConfigDirectory)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">configMapPath := fmt.Sprintf("%s/moduleconfig/authorization/%s/volumes.yaml", op.ConfigDirectory, version)
        buf, err := os.ReadFile(filepath.Clean(configMapPath))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var vols []acorev1.VolumeApplyConfiguration
        err = yaml.Unmarshal(buf, &amp;vols)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">skipCertValid := false
        for _, env := range auth.Envs </span><span class="cov8" title="1">{
                if env.Name == "SKIP_CERTIFICATE_VALIDATION" </span><span class="cov8" title="1">{
                        skipCertValid, _ = strconv.ParseBool(env.Value)
                }</span>
        }

        <span class="cov8" title="1">certString := "proxy-server-root-certificate"
        if skipCertValid </span><span class="cov8" title="1">{ // do not mount proxy-server-root-certificate
                for i, c := range vols </span><span class="cov8" title="1">{
                        if *c.Name == certString </span><span class="cov8" title="1">{
                                vols[i] = vols[len(vols)-1]
                                return vols[:len(vols)-1], nil

                        }</span>
                }
        }
        <span class="cov8" title="1">return vols, nil</span>
}

// AuthInjectDaemonset  - inject authorization into daemonset
func AuthInjectDaemonset(ds applyv1.DaemonSetApplyConfiguration, cr csmv1.ContainerStorageModule, op operatorutils.OperatorConfig) (*applyv1.DaemonSetApplyConfiguration, error) <span class="cov8" title="1">{
        authModule, containerPtr, err := getAuthApplyCR(cr, op)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">container := *containerPtr
        operatorutils.UpdateSideCarApply(authModule.Components, &amp;container)

        vols, err := getAuthApplyVolumes(cr, op, authModule.Components[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if ds.Annotations != nil </span><span class="cov8" title="1">{
                ds.Annotations["com.dell.karavi-authorization-proxy"] = "true"
        }</span> else<span class="cov8" title="1"> {
                ds.Annotations = map[string]string{
                        "com.dell.karavi-authorization-proxy": "true",
                }
        }</span>
        <span class="cov8" title="1">ds.Spec.Template.Spec.Containers = append(ds.Spec.Template.Spec.Containers, container)
        ds.Spec.Template.Spec.Volumes = append(ds.Spec.Template.Spec.Volumes, vols...)

        return &amp;ds, nil</span>
}

// AuthInjectDeployment - inject authorization into deployment
func AuthInjectDeployment(dp applyv1.DeploymentApplyConfiguration, cr csmv1.ContainerStorageModule, op operatorutils.OperatorConfig) (*applyv1.DeploymentApplyConfiguration, error) <span class="cov8" title="1">{
        authModule, containerPtr, err := getAuthApplyCR(cr, op)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">container := *containerPtr
        operatorutils.UpdateSideCarApply(authModule.Components, &amp;container)

        vols, err := getAuthApplyVolumes(cr, op, authModule.Components[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if dp.Annotations != nil </span><span class="cov8" title="1">{
                dp.Annotations["com.dell.karavi-authorization-proxy"] = "true"
        }</span> else<span class="cov8" title="1"> {
                dp.Annotations = map[string]string{
                        "com.dell.karavi-authorization-proxy": "true",
                }
        }</span>
        <span class="cov8" title="1">dp.Spec.Template.Spec.Containers = append(dp.Spec.Template.Spec.Containers, container)
        dp.Spec.Template.Spec.Volumes = append(dp.Spec.Template.Spec.Volumes, vols...)

        return &amp;dp, nil</span>
}

// AuthorizationPrecheck  - runs precheck for CSM Authorization
func AuthorizationPrecheck(ctx context.Context, op operatorutils.OperatorConfig, auth csmv1.Module, cr csmv1.ContainerStorageModule, ctrlClient crclient.Client) error <span class="cov8" title="1">{
        log := logger.GetLogger(ctx)
        if _, ok := AuthorizationSupportedDrivers[string(cr.Spec.Driver.CSIDriverType)]; !ok </span><span class="cov8" title="1">{
                return fmt.Errorf("CSM Authorization does not support %s driver", string(cr.Spec.Driver.CSIDriverType))
        }</span>

        // check if provided version is supported
        <span class="cov8" title="1">if auth.ConfigVersion != "" </span><span class="cov8" title="1">{
                err := checkVersion(string(csmv1.Authorization), auth.ConfigVersion, op.ConfigDirectory)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }

        // Check for secrets
        <span class="cov8" title="1">skipCertValid := false
        // check if components are present or not
        for i, component := range auth.Components </span><span class="cov8" title="1">{
                if component.Name == "karavi-authorization-proxy" </span><span class="cov8" title="1">{
                        skipcertFound := false
                        for _, env := range auth.Components[i].Envs </span><span class="cov8" title="1">{
                                if env.Name == "SKIP_CERTIFICATE_VALIDATION" </span><span class="cov8" title="1">{
                                        skipcertFound = true
                                        break</span>
                                }
                        }
                        // If SKIP_CERTIFICATE_VALIDATION is not found, add it
                        <span class="cov8" title="1">if !skipcertFound </span><span class="cov0" title="0">{
                                auth.Components[i].Envs = append(auth.Components[i].Envs, corev1.EnvVar{
                                        Name:  "SKIP_CERTIFICATE_VALIDATION",
                                        Value: "true",
                                })
                        }</span>
                }
        }

        <span class="cov8" title="1">for _, env := range auth.Components[0].Envs </span><span class="cov8" title="1">{
                if env.Name == "SKIP_CERTIFICATE_VALIDATION" </span><span class="cov8" title="1">{
                        b, err := strconv.ParseBool(env.Value)
                        if err != nil </span><span class="cov8" title="1">{
                                return fmt.Errorf("%s is an invalid value for SKIP_CERTIFICATE_VALIDATION: %v", env.Value, err)
                        }</span>
                        <span class="cov8" title="1">skipCertValid = b</span>
                }
                <span class="cov8" title="1">if env.Name == "PROXY_HOST" &amp;&amp; env.Value == "" </span><span class="cov8" title="1">{
                        return fmt.Errorf("PROXY_HOST for authorization is empty")
                }</span>
        }

        <span class="cov8" title="1">secrets := []string{"karavi-authorization-config", "proxy-authz-tokens"}
        if !skipCertValid </span><span class="cov8" title="1">{
                secrets = append(secrets, "proxy-server-root-certificate")
        }</span>

        <span class="cov8" title="1">for _, name := range secrets </span><span class="cov8" title="1">{
                found := &amp;corev1.Secret{}
                err := ctrlClient.Get(ctx, types.NamespacedName{
                        Name:      name,
                        Namespace: cr.GetNamespace(),
                }, found)
                if err != nil </span><span class="cov8" title="1">{
                        if k8serrors.IsNotFound(err) </span><span class="cov8" title="1">{
                                return fmt.Errorf("failed to find secret %s and certificate validation is requested", name)
                        }</span>
                        <span class="cov0" title="0">log.Error(err, "Failed to query for secret. Warning - the controller pod may not start")</span>
                }
        }

        <span class="cov8" title="1">log.Infof("preformed pre-checks for %s", auth.Name)
        return nil</span>
}

// AuthorizationServerPrecheck  - runs precheck for CSM Authorization Proxy Server
func AuthorizationServerPrecheck(ctx context.Context, op operatorutils.OperatorConfig, auth csmv1.Module, cr csmv1.ContainerStorageModule, r operatorutils.ReconcileCSM) error <span class="cov8" title="1">{
        log := logger.GetLogger(ctx)

        if auth.ConfigVersion != "" </span><span class="cov8" title="1">{
                err := checkVersion(string(csmv1.Authorization), auth.ConfigVersion, op.ConfigDirectory)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }

        // Check for secrets
        <span class="cov8" title="1">var proxyServerSecrets []string
        switch semver.Major(auth.ConfigVersion) </span>{
        case "v2":<span class="cov8" title="1">
                proxyServerSecrets = []string{"karavi-config-secret"}</span>
        case "v1":<span class="cov8" title="1">
                proxyServerSecrets = []string{"karavi-config-secret", "karavi-storage-secret"}</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("authorization major version %s not supported", semver.Major(auth.ConfigVersion))</span>
        }
        <span class="cov8" title="1">for _, name := range proxyServerSecrets </span><span class="cov8" title="1">{
                found := &amp;corev1.Secret{}
                err := r.GetClient().Get(ctx, types.NamespacedName{Name: name, Namespace: cr.GetNamespace()}, found)
                if err != nil </span><span class="cov8" title="1">{
                        if k8serrors.IsNotFound(err) </span><span class="cov8" title="1">{
                                return fmt.Errorf("failed to find secret %s", name)
                        }</span>
                }
        }

        <span class="cov8" title="1">log.Infof("preformed pre-checks for %s proxy server", auth.Name)
        return nil</span>
}

// getAuthorizationServerDeployment - apply dynamic values to the deployment manifest before installation
func getAuthorizationServerDeployment(op operatorutils.OperatorConfig, cr csmv1.ContainerStorageModule) (string, error) <span class="cov8" title="1">{
        YamlString := ""
        auth, err := getAuthorizationModule(cr)
        if err != nil </span><span class="cov0" title="0">{
                return YamlString, err
        }</span>

        <span class="cov8" title="1">buf, err := readConfigFile(auth, cr, op, AuthDeploymentManifest)
        if err != nil </span><span class="cov0" title="0">{
                return YamlString, err
        }</span>

        <span class="cov8" title="1">YamlString = string(buf)
        authNamespace := cr.Namespace

        for _, component := range auth.Components </span><span class="cov8" title="1">{
                // proxy-server component
                if component.Name == AuthProxyServerComponent </span><span class="cov8" title="1">{
                        YamlString = strings.ReplaceAll(YamlString, AuthServerImage, component.ProxyService)
                        YamlString = strings.ReplaceAll(YamlString, AuthProxyServiceReplicas, strconv.Itoa(component.ProxyServiceReplicas))
                        YamlString = strings.ReplaceAll(YamlString, AuthOpaImage, component.Opa)
                        YamlString = strings.ReplaceAll(YamlString, AuthOpaKubeMgmtImage, component.OpaKubeMgmt)
                        YamlString = strings.ReplaceAll(YamlString, AuthTenantServiceImage, component.TenantService)
                        YamlString = strings.ReplaceAll(YamlString, AuthTenantServiceReplicas, strconv.Itoa(component.TenantServiceReplicas))
                        YamlString = strings.ReplaceAll(YamlString, AuthRoleServiceImage, component.RoleService)
                        YamlString = strings.ReplaceAll(YamlString, AuthRoleServiceReplicas, strconv.Itoa(component.RoleServiceReplicas))
                        YamlString = strings.ReplaceAll(YamlString, AuthStorageServiceImage, component.StorageService)
                        YamlString = strings.ReplaceAll(YamlString, AuthStorageServiceReplicas, strconv.Itoa(component.StorageServiceReplicas))
                        YamlString = strings.ReplaceAll(YamlString, AuthControllerImage, component.AuthorizationController)
                        YamlString = strings.ReplaceAll(YamlString, AuthControllerReplicas, strconv.Itoa(component.AuthorizationControllerReplicas))
                        YamlString = strings.ReplaceAll(YamlString, AuthLeaderElectionEnabled, strconv.FormatBool(component.LeaderElection))
                        YamlString = strings.ReplaceAll(YamlString, AuthControllerReconcileInterval, component.ControllerReconcileInterval)
                        YamlString = strings.ReplaceAll(YamlString, CSMName, cr.Name)
                        YamlString = strings.ReplaceAll(YamlString, AuthCSMNameSpace, cr.Namespace)
                }</span>

                // redis component
                <span class="cov8" title="1">if component.Name == AuthRedisComponent </span><span class="cov8" title="1">{
                        YamlString = strings.ReplaceAll(YamlString, AuthRedisImage, component.Redis)
                        YamlString = strings.ReplaceAll(YamlString, AuthRedisCommanderImage, component.Commander)
                        YamlString = strings.ReplaceAll(YamlString, AuthRedisName, component.RedisName)
                        YamlString = strings.ReplaceAll(YamlString, AuthRedisCommander, component.RedisCommander)
                        YamlString = strings.ReplaceAll(YamlString, AuthRedisSentinel, component.Sentinel)
                        YamlString = strings.ReplaceAll(YamlString, AuthRedisReplicas, strconv.Itoa(component.RedisReplicas))
                        YamlString = strings.ReplaceAll(YamlString, AuthCSMNameSpace, cr.Namespace)

                        var sentinelValues []string
                        for i := 0; i &lt; component.RedisReplicas; i++ </span><span class="cov8" title="1">{
                                sentinelValues = append(sentinelValues, fmt.Sprintf("sentinel-%d.sentinel.%s.svc.cluster.local:5000", i, authNamespace))
                        }</span>
                        <span class="cov8" title="1">sentinels := strings.Join(sentinelValues, ", ")
                        YamlString = strings.ReplaceAll(YamlString, AuthRedisSentinelValues, sentinels)

                        if component.RedisStorageClass == "" </span><span class="cov8" title="1">{
                                redisStorageClass = AuthLocalStorageClass
                        }</span> else<span class="cov8" title="1"> {
                                redisStorageClass = component.RedisStorageClass
                        }</span>

                        // create redis kubernetes secret or use a secret provider class
                        <span class="cov8" title="1">for _, config := range component.RedisSecretProviderClass </span><span class="cov8" title="1">{
                                if config.RedisSecretName == "" </span><span class="cov8" title="1">{
                                        redisSecretName = defaultRedisSecretName
                                        redisSecret := createRedisK8sSecret(cr, config.RedisUsernameKey, config.RedisPasswordKey)
                                        secretYaml, err := yaml.Marshal(redisSecret)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return YamlString, fmt.Errorf("failed to marshal redis kubernetes secret: %w", err)
                                        }</span>

                                        <span class="cov8" title="1">YamlString += fmt.Sprintf("\n---\n%s", secretYaml)</span>
                                }
                        }
                }
        }

        <span class="cov8" title="1">YamlString = strings.ReplaceAll(YamlString, AuthNamespace, authNamespace)
        YamlString = strings.ReplaceAll(YamlString, AuthRedisStorageClass, redisStorageClass)
        YamlString = strings.ReplaceAll(YamlString, CSMName, cr.Name)
        YamlString = strings.ReplaceAll(YamlString, AuthCSMNameSpace, cr.Namespace)

        return YamlString, nil</span>
}

// getAuthorizationLocalProvisioner for redis
func getAuthorizationLocalProvisioner(op operatorutils.OperatorConfig, cr csmv1.ContainerStorageModule) (bool, string, error) <span class="cov8" title="1">{
        auth, err := getAuthorizationModule(cr)
        if err != nil </span><span class="cov8" title="1">{
                return false, "", err
        }</span>

        <span class="cov8" title="1">for _, component := range auth.Components </span><span class="cov8" title="1">{
                if component.Name == AuthRedisComponent </span><span class="cov8" title="1">{
                        if component.RedisStorageClass == "" </span><span class="cov8" title="1">{
                                buf, err := readConfigFile(auth, cr, op, AuthLocalProvisionerManifest)
                                if err != nil </span><span class="cov0" title="0">{
                                        return false, "", err
                                }</span>
                                <span class="cov8" title="1">return true, string(buf), nil</span>
                        }
                }
        }
        <span class="cov8" title="1">return false, "", nil</span>
}

// AuthorizationServerDeployment - apply/delete deployment objects
func AuthorizationServerDeployment(ctx context.Context, isDeleting bool, op operatorutils.OperatorConfig, cr csmv1.ContainerStorageModule, ctrlClient crclient.Client) error <span class="cov8" title="1">{
        useLocalStorage, yamlString, err := getAuthorizationLocalProvisioner(op, cr)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if useLocalStorage </span><span class="cov8" title="1">{
                err = applyDeleteObjects(ctx, ctrlClient, yamlString, isDeleting)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">YamlString, err := getAuthorizationServerDeployment(op, cr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = applyDeleteObjects(ctx, ctrlClient, YamlString, isDeleting)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = applyDeleteAuthorizationRedisStatefulsetV2(ctx, isDeleting, cr, ctrlClient)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">err = applyDeleteAuthorizationRediscommanderDeploymentV2(ctx, isDeleting, cr, ctrlClient)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = applyDeleteAuthorizationSentinelStatefulsetV2(ctx, isDeleting, cr, ctrlClient)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // TODO proxy-server, tenant-service, sentinel, redis, redis-commander
        <span class="cov8" title="1">err = applyDeleteAuthorizationProxyServerV2(ctx, isDeleting, cr, ctrlClient)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = applyDeleteAuthorizationStorageService(ctx, isDeleting, cr, ctrlClient)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// AuthorizationStorageService - apply/delete storage service deployment and volume objects
func applyDeleteAuthorizationStorageService(ctx context.Context, isDeleting bool, cr csmv1.ContainerStorageModule, ctrlClient crclient.Client) error <span class="cov8" title="1">{
        authModule, err := getAuthorizationModule(cr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">switch semver.Major(authModule.ConfigVersion) </span>{
        case "v2":<span class="cov8" title="1">
                return authorizationStorageServiceV2(ctx, isDeleting, cr, ctrlClient)</span>
        case "v1":<span class="cov0" title="0">
                return authorizationStorageServiceV1(ctx, isDeleting, cr, ctrlClient)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("authorization major version %s not supported", semver.Major(authModule.ConfigVersion))</span>
        }
}

func authorizationStorageServiceV1(ctx context.Context, isDeleting bool, cr csmv1.ContainerStorageModule, ctrlClient crclient.Client) error <span class="cov0" title="0">{
        authModule, err := getAuthorizationModule(cr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // get component variables
        <span class="cov0" title="0">image := ""
        for _, component := range authModule.Components </span><span class="cov0" title="0">{
                switch component.Name </span>{
                case AuthProxyServerComponent:<span class="cov0" title="0">
                        image = component.StorageService</span>
                }
        }

        <span class="cov0" title="0">deployment := getStorageServiceScaffold(cr.Name, cr.Namespace, image, 1)

        // set karavi-storage-secret volume
        deployment.Spec.Template.Spec.Volumes = append(deployment.Spec.Template.Spec.Volumes, corev1.Volume{
                Name: "storage-volume",
                VolumeSource: corev1.VolumeSource{
                        Secret: &amp;corev1.SecretVolumeSource{
                                SecretName: "karavi-storage-secret",
                        },
                },
        })
        for i, c := range deployment.Spec.Template.Spec.Containers </span><span class="cov0" title="0">{
                if c.Name == "storage-service" </span><span class="cov0" title="0">{
                        deployment.Spec.Template.Spec.Containers[i].VolumeMounts = append(deployment.Spec.Template.Spec.Containers[i].VolumeMounts, corev1.VolumeMount{
                                Name:      "storage-volume",
                                MountPath: "/etc/karavi-authorization/storage",
                        })
                        break</span>
                }
        }

        <span class="cov0" title="0">deploymentBytes, err := json.Marshal(&amp;deployment)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("marshalling storage-service deployment: %w", err)
        }</span>

        <span class="cov0" title="0">deploymentYaml, err := yaml.JSONToYAML(deploymentBytes)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("converting storage-service json to yaml: %w", err)
        }</span>

        <span class="cov0" title="0">return applyDeleteObjects(ctx, ctrlClient, string(deploymentYaml), isDeleting)</span>
}

func authorizationStorageServiceV2(ctx context.Context, isDeleting bool, cr csmv1.ContainerStorageModule, ctrlClient crclient.Client) error <span class="cov8" title="1">{
        authModule, err := getAuthorizationModule(cr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Vault is supported only till config v2.2.0 (CSM 1.14)
        <span class="cov8" title="1">if semver.Compare(authModule.ConfigVersion, "v2.3.0") == -1 </span><span class="cov8" title="1">{
                err = applyDeleteVaultCertificates(ctx, isDeleting, cr, ctrlClient)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("applying/deleting vault certificates: %w", err)
                }</span>
        }

        <span class="cov8" title="1">replicas := 0
        sentinels := ""
        image := ""
        vaults := []csmv1.Vault{}
        var secretProviderClasses []string
        leaderElection := true
        otelCollector := ""
        for _, component := range authModule.Components </span><span class="cov8" title="1">{
                switch component.Name </span>{
                case AuthProxyServerComponent:<span class="cov8" title="1">
                        replicas = component.StorageServiceReplicas
                        image = component.StorageService
                        leaderElection = component.LeaderElection
                        otelCollector = component.OpenTelemetryCollectorAddress</span>
                case AuthRedisComponent:<span class="cov8" title="1">
                        var sentinelValues []string
                        for i := 0; i &lt; component.RedisReplicas; i++ </span><span class="cov8" title="1">{
                                sentinelValues = append(sentinelValues, fmt.Sprintf("sentinel-%d.sentinel.%s.svc.cluster.local:5000", i, cr.Namespace))
                        }</span>
                        <span class="cov8" title="1">sentinels = strings.Join(sentinelValues, ", ")</span>
                case AuthVaultComponent:<span class="cov8" title="1">
                        vaults = component.Vaults</span>
                case AuthStorageSystemCredentialsComponent:<span class="cov8" title="1">
                        secretProviderClasses = component.SecretProviderClasses</span>
                default:<span class="cov8" title="1">
                        continue</span>
                }
        }

        // conversion to int32 is safe for a value up to 2147483647
        // #nosec G115
        <span class="cov8" title="1">deployment := getStorageServiceScaffold(cr.Name, cr.Namespace, image, int32(replicas))

        // SecretProviderClasses is supported from config v2.3.0 (CSM 1.15) onwards
        if semver.Compare(authModule.ConfigVersion, "v2.3.0") &gt;= 0 </span><span class="cov8" title="1">{
                // set volumes for secret provider classes
                readOnly := true
                for _, providerClass := range secretProviderClasses </span><span class="cov8" title="1">{
                        volume := corev1.Volume{
                                Name: fmt.Sprintf("secrets-store-inline-%s", providerClass),
                                VolumeSource: corev1.VolumeSource{
                                        CSI: &amp;corev1.CSIVolumeSource{
                                                Driver:   "secrets-store.csi.k8s.io",
                                                ReadOnly: &amp;readOnly,
                                                VolumeAttributes: map[string]string{
                                                        "secretProviderClass": providerClass,
                                                },
                                        },
                                },
                        }

                        deployment.Spec.Template.Spec.Volumes = append(deployment.Spec.Template.Spec.Volumes, volume)
                }</span>

                // set volume mounts for secret provider classes
                <span class="cov8" title="1">for i, c := range deployment.Spec.Template.Spec.Containers </span><span class="cov8" title="1">{
                        if c.Name == "storage-service" </span><span class="cov8" title="1">{
                                for _, providerClass := range secretProviderClasses </span><span class="cov8" title="1">{
                                        deployment.Spec.Template.Spec.Containers[i].VolumeMounts = append(deployment.Spec.Template.Spec.Containers[i].VolumeMounts, corev1.VolumeMount{
                                                Name:      fmt.Sprintf("secrets-store-inline-%s", providerClass),
                                                MountPath: fmt.Sprintf("/etc/csm-authorization/%s", providerClass),
                                                ReadOnly:  true,
                                        })
                                }</span>
                                <span class="cov8" title="1">break</span>
                        }
                }
        } else<span class="cov8" title="1"> {
                // Vault is supported only till config v2.2.0 (CSM 1.14)
                // set vault volumes
                for _, vault := range vaults </span><span class="cov8" title="1">{
                        volume := corev1.Volume{
                                Name: fmt.Sprintf("vault-client-certificate-%s", vault.Identifier),
                                VolumeSource: corev1.VolumeSource{
                                        Projected: &amp;corev1.ProjectedVolumeSource{
                                                Sources: []corev1.VolumeProjection{{}},
                                        },
                                },
                        }

                        if vault.CertificateAuthority != "" </span><span class="cov8" title="1">{
                                volume.VolumeSource.Projected.Sources = append(volume.VolumeSource.Projected.Sources, corev1.VolumeProjection{
                                        Secret: &amp;corev1.SecretProjection{
                                                LocalObjectReference: corev1.LocalObjectReference{
                                                        Name: fmt.Sprintf("vault-certificate-authority-%s", vault.Identifier),
                                                },
                                        },
                                })
                        }</span>

                        <span class="cov8" title="1">if vault.ClientCertificate != "" &amp;&amp; vault.ClientKey != "" </span><span class="cov8" title="1">{
                                volume.VolumeSource.Projected.Sources = append(volume.VolumeSource.Projected.Sources, corev1.VolumeProjection{
                                        Secret: &amp;corev1.SecretProjection{
                                                LocalObjectReference: corev1.LocalObjectReference{
                                                        Name: fmt.Sprintf("vault-client-certificate-%s", vault.Identifier),
                                                },
                                        },
                                })
                        }</span> else<span class="cov8" title="1"> {
                                volume.VolumeSource.Projected.Sources = append(volume.VolumeSource.Projected.Sources, corev1.VolumeProjection{
                                        Secret: &amp;corev1.SecretProjection{
                                                LocalObjectReference: corev1.LocalObjectReference{
                                                        Name: fmt.Sprintf("storage-service-selfsigned-tls-%s", vault.Identifier),
                                                },
                                        },
                                })
                        }</span>

                        <span class="cov8" title="1">deployment.Spec.Template.Spec.Volumes = append(deployment.Spec.Template.Spec.Volumes, volume)</span>
                }

                <span class="cov8" title="1">for i, c := range deployment.Spec.Template.Spec.Containers </span><span class="cov8" title="1">{
                        if c.Name == "storage-service" </span><span class="cov8" title="1">{
                                for _, vault := range vaults </span><span class="cov8" title="1">{
                                        deployment.Spec.Template.Spec.Containers[i].VolumeMounts = append(deployment.Spec.Template.Spec.Containers[i].VolumeMounts, corev1.VolumeMount{
                                                Name:      fmt.Sprintf("vault-client-certificate-%s", vault.Identifier),
                                                MountPath: fmt.Sprintf("/etc/vault/%s", vault.Identifier),
                                        })
                                }</span>
                                <span class="cov8" title="1">break</span>
                        }
                }
        }

        // set redis envs
        <span class="cov8" title="1">for _, component := range authModule.Components </span><span class="cov8" title="1">{
                for _, config := range component.RedisSecretProviderClass </span><span class="cov8" title="1">{
                        if config.RedisSecretName == "" </span><span class="cov8" title="1">{
                                redisSecretName = defaultRedisSecretName
                        }</span> else<span class="cov8" title="1"> {
                                redisSecretName = config.RedisSecretName
                        }</span>

                        <span class="cov8" title="1">redis := []corev1.EnvVar{
                                {
                                        Name:  "SENTINELS",
                                        Value: sentinels,
                                },
                                {
                                        Name: "REDIS_PASSWORD",
                                        ValueFrom: &amp;corev1.EnvVarSource{
                                                SecretKeyRef: &amp;corev1.SecretKeySelector{
                                                        LocalObjectReference: corev1.LocalObjectReference{
                                                                Name: redisSecretName,
                                                        },
                                                        Key: config.RedisPasswordKey,
                                                },
                                        },
                                },
                        }
                        for i, c := range deployment.Spec.Template.Spec.Containers </span><span class="cov8" title="1">{
                                if c.Name == "storage-service" </span><span class="cov8" title="1">{
                                        deployment.Spec.Template.Spec.Containers[i].Env = append(deployment.Spec.Template.Spec.Containers[i].Env, redis...)
                                        break</span>
                                }
                        }
                }
        }

        // Vault is supported only till config v2.2.0 (CSM 1.14)
        <span class="cov8" title="1">var vaultArgs []string
        if semver.Compare(authModule.ConfigVersion, "v2.3.0") == -1 </span><span class="cov8" title="1">{
                for _, vault := range vaults </span><span class="cov8" title="1">{
                        vaultArgs = append(vaultArgs, fmt.Sprintf("--vault=%s,%s,%s,%t", vault.Identifier, vault.Address, vault.Role, vault.SkipCertificateValidation))
                }</span>
        }

        // set arguments
        <span class="cov8" title="1">args := []string{
                "--redis-sentinel=$(SENTINELS)",
                "--redis-password=$(REDIS_PASSWORD)",
                fmt.Sprintf("--leader-election=%t", leaderElection),
        }

        // if the config version is greater than v2.0.0-alpha, add the collector-address arg
        if semver.Compare(authModule.ConfigVersion, "v2.0.0-alpha") == 1 </span><span class="cov8" title="1">{
                args = append(args, fmt.Sprintf("--collector-address=%s", otelCollector))
        }</span>
        <span class="cov8" title="1">args = append(args, vaultArgs...)

        for i, c := range deployment.Spec.Template.Spec.Containers </span><span class="cov8" title="1">{
                if c.Name == "storage-service" </span><span class="cov8" title="1">{
                        deployment.Spec.Template.Spec.Containers[i].Args = append(deployment.Spec.Template.Spec.Containers[i].Args, args...)
                        break</span>
                }
        }

        // if the config version is greater than v2.0.0-alpha, set promhttp container port
        <span class="cov8" title="1">if semver.Compare(authModule.ConfigVersion, "v2.0.0-alpha") == 1 </span><span class="cov8" title="1">{
                for i, c := range deployment.Spec.Template.Spec.Containers </span><span class="cov8" title="1">{
                        if c.Name == "storage-service" </span><span class="cov8" title="1">{
                                deployment.Spec.Template.Spec.Containers[i].Ports = append(deployment.Spec.Template.Spec.Containers[i].Ports,
                                        corev1.ContainerPort{
                                                Name:          "promhttp",
                                                Protocol:      "TCP",
                                                ContainerPort: 2112,
                                        },
                                )
                                break</span>
                        }
                }
        }

        <span class="cov8" title="1">deploymentBytes, err := json.Marshal(&amp;deployment)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("marshalling storage-service deployment: %w", err)
        }</span>

        <span class="cov8" title="1">deploymentYaml, err := yaml.JSONToYAML(deploymentBytes)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("converting storage-service json to yaml: %w", err)
        }</span>

        <span class="cov8" title="1">err = applyDeleteObjects(ctx, ctrlClient, string(deploymentYaml), isDeleting)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("applying storage-service deployment: %w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func applyDeleteAuthorizationProxyServerV2(ctx context.Context, isDeleting bool, cr csmv1.ContainerStorageModule, ctrlClient crclient.Client) error <span class="cov8" title="1">{
        authModule, err := getAuthorizationModule(cr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">replicas := 0
        sentinels := 0
        sentinelName := ""
        proxyImage := ""
        opaImage := ""
        opaKubeMgmtImage := ""
        for _, component := range authModule.Components </span><span class="cov8" title="1">{
                switch component.Name </span>{
                case AuthProxyServerComponent:<span class="cov8" title="1">
                        replicas = component.ProxyServiceReplicas
                        proxyImage = component.ProxyService
                        opaImage = component.Opa
                        opaKubeMgmtImage = component.OpaKubeMgmt</span>
                case AuthRedisComponent:<span class="cov8" title="1">
                        sentinels = component.RedisReplicas
                        sentinelName = component.Sentinel
                        // create redis kubernetes secret or use a secret provider class
                        for _, config := range component.RedisSecretProviderClass </span><span class="cov8" title="1">{
                                if config.RedisSecretName == "" </span><span class="cov8" title="1">{
                                        redisSecretName = defaultRedisSecretName
                                }</span> else<span class="cov8" title="1"> {
                                        redisSecretName = config.RedisSecretName
                                        redisPasswordKey = config.RedisPasswordKey
                                }</span>
                        }
                default:<span class="cov8" title="1">
                        continue</span>
                }
        }

        // conversion to int32 is safe for a value up to 2147483647
        // #nosec G115
        <span class="cov8" title="1">deployment := getProxyServerScaffold(cr.Name, sentinelName, cr.Namespace, proxyImage, opaImage, opaKubeMgmtImage, redisSecretName, redisPasswordKey, int32(replicas), sentinels)

        // SecretProviderClasses is supported from config v2.3.0 (CSM 1.15) onwards
        if semver.Compare(authModule.ConfigVersion, "v2.3.0") &gt;= 0 </span><span class="cov8" title="1">{
                for _, component := range authModule.Components </span><span class="cov8" title="1">{
                        for _, config := range component.RedisSecretProviderClass </span><span class="cov8" title="1">{
                                if config.RedisSecretName != "" </span><span class="cov8" title="1">{
                                        // add volume for redis secret provider class
                                        redisVolume := redisVolume(redisSecretName)
                                        deployment.Spec.Template.Spec.Volumes = append(deployment.Spec.Template.Spec.Volumes, redisVolume)

                                        // set volume mount for redis secret provider class
                                        for i := range deployment.Spec.Template.Spec.Containers </span><span class="cov8" title="1">{
                                                redisVolumeMount := redisVolumeMount()
                                                deployment.Spec.Template.Spec.Containers[i].VolumeMounts = append(deployment.Spec.Template.Spec.Containers[i].VolumeMounts, redisVolumeMount)
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov8" title="1">deploymentBytes, err := yaml.Marshal(&amp;deployment)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("marshalling proxy-server deployment: %w", err)
        }</span>

        <span class="cov8" title="1">err = applyDeleteObjects(ctx, ctrlClient, string(deploymentBytes), isDeleting)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("applying proxy-server deployment: %w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func applyDeleteAuthorizationRedisStatefulsetV2(ctx context.Context, isDeleting bool, cr csmv1.ContainerStorageModule, ctrlClient crclient.Client) error <span class="cov8" title="1">{
        authModule, err := getAuthorizationModule(cr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">redisName := ""
        image := ""
        replicas := 0
        for _, component := range authModule.Components </span><span class="cov8" title="1">{
                switch component.Name </span>{
                case AuthRedisComponent:<span class="cov8" title="1">
                        redisName = component.RedisName
                        image = component.Redis
                        replicas = component.RedisReplicas
                        // create redis kubernetes secret or use a secret provider class
                        for _, config := range component.RedisSecretProviderClass </span><span class="cov8" title="1">{
                                if config.RedisSecretName == "" </span><span class="cov8" title="1">{
                                        redisSecretName = defaultRedisSecretName
                                }</span> else<span class="cov8" title="1"> {
                                        redisSecretName = config.RedisSecretName
                                        redisPasswordKey = config.RedisPasswordKey
                                }</span>
                        }
                default:<span class="cov8" title="1">
                        continue</span>
                }
        }

        // conversion to int32 is safe for a value up to 2147483647
        // #nosec G115
        <span class="cov8" title="1">deployment := getAuthorizationRedisStatefulsetScaffold(cr.Name, redisName, cr.Namespace, image, redisSecretName, redisPasswordKey, int32(replicas))

        // SecretProviderClasses is supported from config v2.3.0 (CSM 1.15) onwards
        if semver.Compare(authModule.ConfigVersion, "v2.3.0") &gt;= 0 </span><span class="cov8" title="1">{
                for _, component := range authModule.Components </span><span class="cov8" title="1">{
                        for _, config := range component.RedisSecretProviderClass </span><span class="cov8" title="1">{
                                if config.RedisSecretName != "" </span><span class="cov8" title="1">{
                                        // add volume for redis secret provider class
                                        redisVolume := redisVolume(redisSecretName)
                                        deployment.Spec.Template.Spec.Volumes = append(deployment.Spec.Template.Spec.Volumes, redisVolume)

                                        // set volume mount for redis secret provider class
                                        for i := range deployment.Spec.Template.Spec.Containers </span><span class="cov8" title="1">{
                                                redisVolumeMount := redisVolumeMount()
                                                deployment.Spec.Template.Spec.Containers[i].VolumeMounts = append(deployment.Spec.Template.Spec.Containers[i].VolumeMounts, redisVolumeMount)
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov8" title="1">deploymentBytes, err := yaml.Marshal(&amp;deployment)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("marshalling redis statefulset: %w", err)
        }</span>

        <span class="cov8" title="1">err = applyDeleteObjects(ctx, ctrlClient, string(deploymentBytes), isDeleting)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("applying redis statefulset: %w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func applyDeleteAuthorizationRediscommanderDeploymentV2(ctx context.Context, isDeleting bool, cr csmv1.ContainerStorageModule, ctrlClient crclient.Client) error <span class="cov8" title="1">{
        authModule, err := getAuthorizationModule(cr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">rediscommanderName := ""
        image := ""
        replicas := 0
        for _, component := range authModule.Components </span><span class="cov8" title="1">{
                switch component.Name </span>{
                case AuthRedisComponent:<span class="cov8" title="1">
                        rediscommanderName = component.RedisCommander
                        image = component.Commander
                        replicas = component.RedisReplicas
                        // create redis kubernetes secret or use a secret provider class
                        for _, config := range component.RedisSecretProviderClass </span><span class="cov8" title="1">{
                                if config.RedisSecretName == "" </span><span class="cov8" title="1">{
                                        redisSecretName = defaultRedisSecretName
                                }</span> else<span class="cov8" title="1"> {
                                        redisSecretName = config.RedisSecretName
                                        redisUsernameKey = config.RedisUsernameKey
                                        redisPasswordKey = config.RedisPasswordKey
                                }</span>
                        }
                default:<span class="cov8" title="1">
                        continue</span>
                }
        }

        // conversion to int32 is safe for a value up to 2147483647
        // #nosec G115
        <span class="cov8" title="1">deployment := getAuthorizationRediscommanderDeploymentScaffold(cr.Name, rediscommanderName, cr.Namespace, image, redisSecretName, redisUsernameKey, redisPasswordKey, int32(replicas))

        // SecretProviderClasses is supported from config v2.3.0 (CSM 1.15) onwards
        if semver.Compare(authModule.ConfigVersion, "v2.3.0") &gt;= 0 </span><span class="cov8" title="1">{
                for _, component := range authModule.Components </span><span class="cov8" title="1">{
                        for _, config := range component.RedisSecretProviderClass </span><span class="cov8" title="1">{
                                if config.RedisSecretName != "" </span><span class="cov8" title="1">{
                                        // add volume for redis secret provider class
                                        redisVolume := redisVolume(redisSecretName)
                                        deployment.Spec.Template.Spec.Volumes = append(deployment.Spec.Template.Spec.Volumes, redisVolume)

                                        // set volume mount for redis secret provider class
                                        for i := range deployment.Spec.Template.Spec.Containers </span><span class="cov8" title="1">{
                                                redisVolumeMount := redisVolumeMount()
                                                deployment.Spec.Template.Spec.Containers[i].VolumeMounts = append(deployment.Spec.Template.Spec.Containers[i].VolumeMounts, redisVolumeMount)
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov8" title="1">deploymentBytes, err := yaml.Marshal(&amp;deployment)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("marshalling rediscommander deployment: %w", err)
        }</span>

        <span class="cov8" title="1">err = applyDeleteObjects(ctx, ctrlClient, string(deploymentBytes), isDeleting)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("applying rediscommander deployment: %w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func applyDeleteAuthorizationSentinelStatefulsetV2(ctx context.Context, isDeleting bool, cr csmv1.ContainerStorageModule, ctrlClient crclient.Client) error <span class="cov8" title="1">{
        authModule, err := getAuthorizationModule(cr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">rediscommanderName := ""
        image := ""
        replicas := 0
        for _, component := range authModule.Components </span><span class="cov8" title="1">{
                switch component.Name </span>{
                case AuthRedisComponent:<span class="cov8" title="1">
                        rediscommanderName = component.RedisCommander
                        image = component.Commander
                        replicas = component.RedisReplicas
                        // create redis kubernetes secret or use a secret provider class
                        for _, config := range component.RedisSecretProviderClass </span><span class="cov8" title="1">{
                                if config.RedisSecretName == "" </span><span class="cov8" title="1">{
                                        redisSecretName = defaultRedisSecretName
                                }</span> else<span class="cov8" title="1"> {
                                        redisSecretName = config.RedisSecretName
                                        redisPasswordKey = config.RedisPasswordKey
                                }</span>
                        }
                default:<span class="cov8" title="1">
                        continue</span>
                }
        }

        // conversion to int32 is safe for a value up to 2147483647
        // #nosec G115
        <span class="cov8" title="1">deployment := getAuthorizationSentinelStatefulsetScaffold(cr.Name, rediscommanderName, image, redisSecretName, redisPasswordKey, int32(replicas))

        // SecretProviderClasses is supported from config v2.3.0 (CSM 1.15) onwards
        if semver.Compare(authModule.ConfigVersion, "v2.3.0") &gt;= 0 </span><span class="cov8" title="1">{
                for _, component := range authModule.Components </span><span class="cov8" title="1">{
                        for _, config := range component.RedisSecretProviderClass </span><span class="cov8" title="1">{
                                if config.RedisSecretName != "" </span><span class="cov8" title="1">{
                                        // add volume for redis secret provider class
                                        redisVolume := redisVolume(redisSecretName)
                                        deployment.Spec.Template.Spec.Volumes = append(deployment.Spec.Template.Spec.Volumes, redisVolume)

                                        // set volume mount for redis secret provider class
                                        for i := range deployment.Spec.Template.Spec.Containers </span><span class="cov8" title="1">{
                                                redisVolumeMount := redisVolumeMount()
                                                deployment.Spec.Template.Spec.Containers[i].VolumeMounts = append(deployment.Spec.Template.Spec.Containers[i].VolumeMounts, redisVolumeMount)
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov8" title="1">deploymentBytes, err := yaml.Marshal(&amp;deployment)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("marshalling sentinel statefulset: %w", err)
        }</span>

        <span class="cov8" title="1">err = applyDeleteObjects(ctx, ctrlClient, string(deploymentBytes), isDeleting)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("applying sentinel statefulset: %w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func applyDeleteVaultCertificates(ctx context.Context, isDeleting bool, cr csmv1.ContainerStorageModule, ctrlClient crclient.Client) error <span class="cov8" title="1">{
        authModule, err := getAuthorizationModule(cr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // get vault certificate data from CR
        <span class="cov8" title="1">vaults := []csmv1.Vault{}
loop:
        for _, component := range authModule.Components </span><span class="cov8" title="1">{
                switch component.Name </span>{
                case AuthVaultComponent:<span class="cov8" title="1">
                        vaults = component.Vaults
                        break loop</span>
                default:<span class="cov8" title="1">
                        continue</span>
                }
        }

        <span class="cov8" title="1">for _, vault := range vaults </span><span class="cov8" title="1">{
                if vault.CertificateAuthority != "" </span><span class="cov8" title="1">{
                        vaultCABytes, err := base64.StdEncoding.DecodeString(vault.CertificateAuthority)
                        if err != nil </span><span class="cov8" title="1">{
                                return fmt.Errorf("decoding vault certificate authority: %w", err)
                        }</span>

                        <span class="cov8" title="1">secret := corev1.Secret{
                                TypeMeta: metav1.TypeMeta{
                                        APIVersion: "v1",
                                        Kind:       "Secret",
                                },
                                ObjectMeta: metav1.ObjectMeta{
                                        Name:      fmt.Sprintf("vault-certificate-authority-%s", vault.Identifier),
                                        Namespace: cr.Namespace,
                                },
                                Type: corev1.SecretTypeOpaque,
                                Data: map[string][]byte{
                                        "ca.crt": vaultCABytes,
                                },
                        }

                        secretBytes, err := json.Marshal(&amp;secret)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("marshalling vault certificate authority secret: %w", err)
                        }</span>

                        <span class="cov8" title="1">yamlString, err := yaml.JSONToYAML(secretBytes)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("converting vault certificate authority json to yaml: %w", err)
                        }</span>

                        <span class="cov8" title="1">err = applyDeleteObjects(ctx, ctrlClient, string(yamlString), isDeleting)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("applying vault certificate authority secret: %w", err)
                        }</span>
                }

                <span class="cov8" title="1">if vault.ClientCertificate != "" &amp;&amp; vault.ClientKey != "" </span><span class="cov8" title="1">{
                        vaultCertBytes, err := base64.StdEncoding.DecodeString(vault.ClientCertificate)
                        if err != nil </span><span class="cov8" title="1">{
                                return fmt.Errorf("decoding vault certificate: %w", err)
                        }</span>

                        <span class="cov8" title="1">vaultKeyBytes, err := base64.StdEncoding.DecodeString(vault.ClientKey)
                        if err != nil </span><span class="cov8" title="1">{
                                return fmt.Errorf("decoding vault private key: %w", err)
                        }</span>

                        <span class="cov8" title="1">secret := corev1.Secret{
                                TypeMeta: metav1.TypeMeta{
                                        APIVersion: "v1",
                                        Kind:       "Secret",
                                },
                                ObjectMeta: metav1.ObjectMeta{
                                        Name:      fmt.Sprintf("vault-client-certificate-%s", vault.Identifier),
                                        Namespace: cr.Namespace,
                                },
                                Type: corev1.SecretTypeTLS,
                                Data: map[string][]byte{
                                        "tls.crt": vaultCertBytes,
                                        "tls.key": vaultKeyBytes,
                                },
                        }

                        secretBytes, err := json.Marshal(&amp;secret)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("marshalling vault certificate secret: %w", err)
                        }</span>

                        <span class="cov8" title="1">yamlString, err := yaml.JSONToYAML(secretBytes)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("converting vault certificate json to yaml: %w", err)
                        }</span>

                        <span class="cov8" title="1">err = applyDeleteObjects(ctx, ctrlClient, string(yamlString), isDeleting)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("applying vault certificate secret: %w", err)
                        }</span>
                } else<span class="cov8" title="1"> {
                        issuer := createSelfSignedIssuer(cr, fmt.Sprintf("storage-service-selfsigned-%s", vault.Identifier))

                        issuerByes, err := json.Marshal(issuer)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("marshaling storage-service-selfsigned issuer: %v", err)
                        }</span>

                        <span class="cov8" title="1">issuerYaml, err := yaml.JSONToYAML(issuerByes)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("converting storage-service-selfsigned issuer json to yaml: %v", err)
                        }</span>

                        // create/delete issuer
                        <span class="cov8" title="1">err = applyDeleteObjects(ctx, ctrlClient, string(issuerYaml), isDeleting)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov8" title="1">certificate := createSelfSignedCertificate(
                                cr,
                                []string{fmt.Sprintf("storage-service.%s.svc.cluster.local", cr.Namespace)},
                                fmt.Sprintf("storage-service-selfsigned-%s", vault.Identifier),
                                fmt.Sprintf("storage-service-selfsigned-tls-%s", vault.Identifier),
                                fmt.Sprintf("storage-service-selfsigned-%s", vault.Identifier))

                        certBytes, err := json.Marshal(certificate)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("marshaling storage-service-selfsigned certificate: %v", err)
                        }</span>

                        <span class="cov8" title="1">certYaml, err := yaml.JSONToYAML(certBytes)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("converting storage-service-selfsigned certificate json to yaml: %v", err)
                        }</span>

                        // create/delete certificate
                        <span class="cov8" title="1">err = applyDeleteObjects(ctx, ctrlClient, string(certYaml), isDeleting)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// AuthorizationIngress - apply/delete ingress objects
func AuthorizationIngress(ctx context.Context, isDeleting, isOpenShift bool, cr csmv1.ContainerStorageModule, r operatorutils.ReconcileCSM, ctrlClient crclient.Client) error <span class="cov8" title="1">{
        ingress, err := createIngress(isOpenShift, cr)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("creating ingress: %v", err)
        }</span>

        <span class="cov8" title="1">ingressBytes, err := json.Marshal(ingress)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("marshaling ingress: %v", err)
        }</span>

        <span class="cov8" title="1">ingressYaml, err := yaml.JSONToYAML(ingressBytes)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("marshaling ingress: %v", err)
        }</span>

        // Wait for NGINX ingress controller to be ready before creating Ingresses
        // Needed for Kubernetes only
        <span class="cov8" title="1">if !isDeleting &amp;&amp; !isOpenShift </span><span class="cov8" title="1">{
                if err := operatorutils.WaitForNginxController(ctx, cr, r, time.Duration(10)*time.Second); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("NGINX ingress controller is not ready: %v", err)
                }</span>
        }

        <span class="cov8" title="1">err = applyDeleteObjects(ctx, ctrlClient, string(ingressYaml), isDeleting)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// getNginxIngressController - configure nginx ingress controller with the specified namespace before installation
func getNginxIngressController(op operatorutils.OperatorConfig, cr csmv1.ContainerStorageModule) (string, error) <span class="cov8" title="1">{
        YamlString := ""

        auth, err := getAuthorizationModule(cr)
        if err != nil </span><span class="cov8" title="1">{
                return YamlString, err
        }</span>

        <span class="cov8" title="1">buf, err := readConfigFile(auth, cr, op, AuthNginxIngressManifest)
        if err != nil </span><span class="cov0" title="0">{
                return YamlString, err
        }</span>

        <span class="cov8" title="1">YamlString = string(buf)
        authNamespace := cr.Namespace
        YamlString = strings.ReplaceAll(YamlString, AuthNamespace, authNamespace)
        YamlString = strings.ReplaceAll(YamlString, CSMName, cr.Name)
        YamlString = strings.ReplaceAll(YamlString, AuthCSMNameSpace, cr.Namespace)

        return YamlString, nil</span>
}

// NginxIngressController - apply/delete nginx ingress controller objects
func NginxIngressController(ctx context.Context, isDeleting bool, op operatorutils.OperatorConfig, cr csmv1.ContainerStorageModule, ctrlClient crclient.Client) error <span class="cov8" title="1">{
        YamlString, err := getNginxIngressController(op, cr)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">err = applyDeleteObjects(ctx, ctrlClient, YamlString, isDeleting)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// getPolicies - configure policies with the specified namespace before installation
func getPolicies(op operatorutils.OperatorConfig, cr csmv1.ContainerStorageModule) (string, error) <span class="cov8" title="1">{
        YamlString := ""

        auth, err := getAuthorizationModule(cr)
        if err != nil </span><span class="cov8" title="1">{
                return YamlString, err
        }</span>

        <span class="cov8" title="1">buf, err := readConfigFile(auth, cr, op, AuthPolicyManifest)
        if err != nil </span><span class="cov0" title="0">{
                return YamlString, err
        }</span>

        <span class="cov8" title="1">YamlString = string(buf)
        authNamespace := cr.Namespace
        YamlString = strings.ReplaceAll(YamlString, AuthNamespace, authNamespace)

        return YamlString, nil</span>
}

// InstallPolicies - apply/delete authorization opa policy objects
func InstallPolicies(ctx context.Context, isDeleting bool, op operatorutils.OperatorConfig, cr csmv1.ContainerStorageModule, ctrlClient crclient.Client) error <span class="cov8" title="1">{
        YamlString, err := getPolicies(op, cr)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">err = applyDeleteObjects(ctx, ctrlClient, YamlString, isDeleting)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func getCerts(ctx context.Context, op operatorutils.OperatorConfig, cr csmv1.ContainerStorageModule) (bool, string, error) <span class="cov8" title="1">{
        log := logger.GetLogger(ctx)
        YamlString := ""
        authNamespace := cr.Namespace

        authModule, err := getAuthorizationModule(cr)
        if err != nil </span><span class="cov0" title="0">{
                return false, YamlString, err
        }</span>

        <span class="cov8" title="1">for _, component := range authModule.Components </span><span class="cov8" title="1">{
                if component.Name == AuthProxyServerComponent </span><span class="cov8" title="1">{
                        authHostname = component.Hostname
                        authCertificate = component.Certificate
                        authPrivateKey = component.PrivateKey

                        log.Infof("Authorization hostname: %s", authHostname)
                }</span>
        }

        <span class="cov8" title="1">if authCertificate != "" || authPrivateKey != "" </span><span class="cov8" title="1">{
                // use custom tls secret
                if authCertificate != "" &amp;&amp; authPrivateKey != "" </span><span class="cov8" title="1">{
                        log.Infof("using user provided certificate and key for authorization")
                        buf, err := readConfigFile(authModule, cr, op, AuthCustomCert)
                        if err != nil </span><span class="cov0" title="0">{
                                return false, YamlString, err
                        }</span>

                        <span class="cov8" title="1">YamlString = string(buf)
                        YamlString = strings.ReplaceAll(YamlString, AuthNamespace, authNamespace)
                        YamlString = strings.ReplaceAll(YamlString, AuthCert, authCertificate)
                        YamlString = strings.ReplaceAll(YamlString, AuthPrivateKey, authPrivateKey)</span>
                } else<span class="cov8" title="1"> {
                        return false, YamlString, fmt.Errorf("authorization install failed -- either certificate or private key missing for custom cert")
                }</span>
        } else<span class="cov8" title="1"> {
                // use self-signed cert
                log.Info("using self-signed certificate for authorization")
                return true, "", nil
        }</span>

        <span class="cov8" title="1">return false, YamlString, nil</span>
}

// InstallWithCerts - apply/delete certificate related objects
func InstallWithCerts(ctx context.Context, isDeleting bool, op operatorutils.OperatorConfig, cr csmv1.ContainerStorageModule, ctrlClient crclient.Client) error <span class="cov8" title="1">{
        useSelfSignedCert, YamlString, err := getCerts(ctx, op, cr)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if useSelfSignedCert </span><span class="cov8" title="1">{
                issuer := createSelfSignedIssuer(cr, "selfsigned")
                issuerByes, err := json.Marshal(issuer)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("marshaling ingress: %v", err)
                }</span>

                <span class="cov8" title="1">issuerYaml, err := yaml.JSONToYAML(issuerByes)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("marshaling ingress: %v", err)
                }</span>

                // create/delete issuer
                <span class="cov8" title="1">err = applyDeleteObjects(ctx, ctrlClient, string(issuerYaml), isDeleting)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">hosts, err := getHosts(cr)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">cert := createSelfSignedCertificate(cr, hosts, "karavi-auth", "karavi-selfsigned-tls", "selfsigned")

                certBytes, err := json.Marshal(cert)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("marshaling ingress: %v", err)
                }</span>

                <span class="cov8" title="1">certYaml, err := yaml.JSONToYAML(certBytes)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("marshaling ingress: %v", err)
                }</span>

                // create/delete certificate
                <span class="cov8" title="1">err = applyDeleteObjects(ctx, ctrlClient, string(certYaml), isDeleting)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">err = applyDeleteObjects(ctx, ctrlClient, YamlString, isDeleting)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// getAuthCrdDeploy - apply and deploy authorization crd manifest
func getAuthCrdDeploy(op operatorutils.OperatorConfig, cr csmv1.ContainerStorageModule) (string, error) <span class="cov8" title="1">{
        yamlString := ""

        auth, err := getAuthorizationModule(cr)
        if err != nil </span><span class="cov0" title="0">{
                return yamlString, err
        }</span>

        <span class="cov8" title="1">buf, err := readConfigFile(auth, cr, op, AuthCrds)
        if err != nil </span><span class="cov8" title="1">{
                return yamlString, err
        }</span>

        <span class="cov8" title="1">yamlString = string(buf)

        yamlString = strings.ReplaceAll(yamlString, AuthNamespace, cr.Namespace)
        yamlString = strings.ReplaceAll(yamlString, AuthCSMNameSpace, cr.Namespace)

        return yamlString, nil</span>
}

// AuthCrdDeploy - apply and delete Auth crds deployment
func AuthCrdDeploy(ctx context.Context, op operatorutils.OperatorConfig, cr csmv1.ContainerStorageModule, ctrlClient crclient.Client) error <span class="cov8" title="1">{
        auth, err := getAuthorizationModule(cr)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // v1 does not have custom resources, so treat it like a no-op
        <span class="cov8" title="1">if semver.Compare(auth.ConfigVersion, "v2.0.0-alpha") &lt; 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">yamlString, err := getAuthCrdDeploy(op, cr)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">err = applyDeleteObjects(ctx, ctrlClient, yamlString, false)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func createSelfSignedIssuer(cr csmv1.ContainerStorageModule, name string) *certificate.Issuer <span class="cov8" title="1">{
        return &amp;certificate.Issuer{
                TypeMeta: metav1.TypeMeta{
                        Kind: "Issuer",
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      name,
                        Namespace: cr.Namespace,
                },
                Spec: certificate.IssuerSpec{
                        IssuerConfig: certificate.IssuerConfig{
                                SelfSigned: &amp;certificate.SelfSignedIssuer{
                                        CRLDistributionPoints: []string{},
                                },
                        },
                },
        }
}</span>

func createSelfSignedCertificate(cr csmv1.ContainerStorageModule, hosts []string, name string, secretName string, issuerName string) *certificate.Certificate <span class="cov8" title="1">{
        return &amp;certificate.Certificate{
                TypeMeta: metav1.TypeMeta{
                        Kind: "Certificate",
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      name,
                        Namespace: cr.Namespace,
                },
                Spec: certificate.CertificateSpec{
                        SecretName: secretName,
                        Duration: &amp;metav1.Duration{
                                Duration: duration, // 90d
                        },
                        RenewBefore: &amp;metav1.Duration{
                                Duration: renewBefore, // 15d
                        },
                        Subject: &amp;certificate.X509Subject{
                                Organizations: []string{"dellemc"},
                        },
                        IsCA: false,
                        PrivateKey: &amp;certificate.CertificatePrivateKey{
                                Algorithm: "RSA",
                                Encoding:  "PKCS1",
                                Size:      2048,
                        },
                        Usages: []certificate.KeyUsage{
                                "client auth",
                                "server auth",
                        },
                        DNSNames: hosts,
                        IssuerRef: cmmetav1.ObjectReference{
                                Name:  issuerName,
                                Kind:  "Issuer",
                                Group: "cert-manager.io",
                        },
                },
        }
}</span>

func createIngress(isOpenShift bool, cr csmv1.ContainerStorageModule) (*networking.Ingress, error) <span class="cov8" title="1">{
        authModule, err := getAuthorizationModule(cr)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">className, err := getClassName(isOpenShift, cr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("getting ingress class name: %v", err)
        }</span>

        <span class="cov8" title="1">annotations, err := getAnnotations(isOpenShift, cr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("getting annotations: %v", err)
        }</span>

        <span class="cov8" title="1">hosts, err := getHosts(cr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("getting hosts: %v", err)
        }</span>

        <span class="cov8" title="1">rules, err := setIngressRules(cr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("setting ingress rules: %v", err)
        }</span>

        <span class="cov8" title="1">for _, component := range authModule.Components </span><span class="cov8" title="1">{
                if component.Name == AuthProxyServerComponent </span><span class="cov8" title="1">{
                        if component.Certificate != "" &amp;&amp; component.PrivateKey != "" </span><span class="cov8" title="1">{
                                secretName = "user-provided-tls"
                        }</span> else<span class="cov8" title="1"> {
                                secretName = "karavi-selfsigned-tls"
                        }</span>
                }
        }

        <span class="cov8" title="1">ingress := networking.Ingress{
                TypeMeta: metav1.TypeMeta{
                        Kind: "Ingress",
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:        "proxy-server",
                        Namespace:   cr.Namespace,
                        Annotations: annotations,
                },
                Spec: networking.IngressSpec{
                        IngressClassName: &amp;className,
                        TLS: []networking.IngressTLS{
                                {
                                        Hosts:      hosts,
                                        SecretName: secretName,
                                },
                        },
                        Rules: rules,
                },
        }

        return &amp;ingress, nil</span>
}

func getAnnotations(isOpenShift bool, cr csmv1.ContainerStorageModule) (map[string]string, error) <span class="cov8" title="1">{
        authModule, err := getAuthorizationModule(cr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">annotations := make(map[string]string)

        if isOpenShift </span><span class="cov8" title="1">{
                annotations["route.openshift.io/termination"] = "edge"
        }</span>

        <span class="cov8" title="1">for _, component := range authModule.Components </span><span class="cov8" title="1">{
                if component.Name == AuthProxyServerComponent </span><span class="cov8" title="1">{
                        for _, ingress := range component.ProxyServerIngress </span><span class="cov8" title="1">{
                                for annotation, value := range ingress.Annotations </span><span class="cov8" title="1">{
                                        annotations[annotation] = value
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return annotations, nil</span>
}

func getHosts(cr csmv1.ContainerStorageModule) ([]string, error) <span class="cov8" title="1">{
        authModule, err := getAuthorizationModule(cr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var hosts []string
        for _, component := range authModule.Components </span><span class="cov8" title="1">{
                if component.Name == AuthProxyServerComponent </span><span class="cov8" title="1">{
                        // hostname
                        hosts = append(hosts, component.Hostname)

                        for _, proxyServerIngress := range component.ProxyServerIngress </span><span class="cov8" title="1">{
                                // proxyServerIngress.hosts
                                hosts = append(hosts, proxyServerIngress.Hosts...)
                        }</span>
                }
        }

        <span class="cov8" title="1">return hosts, nil</span>
}

func getClassName(isOpenShift bool, cr csmv1.ContainerStorageModule) (string, error) <span class="cov8" title="1">{
        authModule, err := getAuthorizationModule(cr)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">for _, component := range authModule.Components </span><span class="cov8" title="1">{
                if component.Name == AuthProxyServerComponent </span><span class="cov8" title="1">{
                        for _, proxyServerIngress := range component.ProxyServerIngress </span><span class="cov8" title="1">{
                                if !isOpenShift </span><span class="cov8" title="1">{
                                        proxyIngressClassName = proxyServerIngress.IngressClassName
                                }</span> else<span class="cov8" title="1"> {
                                        proxyIngressClassName = "openshift-default"
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return proxyIngressClassName, nil</span>
}

func setIngressRules(cr csmv1.ContainerStorageModule) ([]networking.IngressRule, error) <span class="cov8" title="1">{
        var rules []networking.IngressRule
        hosts, err := getHosts(cr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("getting hosts: %v", err)
        }</span>

        <span class="cov8" title="1">for _, host := range hosts </span><span class="cov8" title="1">{
                rule := []networking.IngressRule{
                        {
                                Host: host,
                                IngressRuleValue: networking.IngressRuleValue{
                                        HTTP: &amp;networking.HTTPIngressRuleValue{
                                                Paths: []networking.HTTPIngressPath{
                                                        {
                                                                Backend: networking.IngressBackend{
                                                                        Service: &amp;networking.IngressServiceBackend{
                                                                                Name: "proxy-server",
                                                                                Port: networking.ServiceBackendPort{
                                                                                        Number: 8080,
                                                                                },
                                                                        },
                                                                },
                                                                Path:     "/",
                                                                PathType: &amp;pathType,
                                                        },
                                                },
                                        },
                                },
                        },
                }

                rules = append(rules, rule...)
        }</span>

        <span class="cov8" title="1">noHostRule := []networking.IngressRule{
                {
                        // no host specified, uses cluster node IP address
                        IngressRuleValue: networking.IngressRuleValue{
                                HTTP: &amp;networking.HTTPIngressRuleValue{
                                        Paths: []networking.HTTPIngressPath{
                                                {
                                                        Backend: networking.IngressBackend{
                                                                Service: &amp;networking.IngressServiceBackend{
                                                                        Name: "proxy-server",
                                                                        Port: networking.ServiceBackendPort{
                                                                                Number: 8080,
                                                                        },
                                                                },
                                                        },
                                                        Path:     "/",
                                                        PathType: &amp;pathType,
                                                },
                                        },
                                },
                        },
                },
        }

        rules = append(rules, noHostRule...)

        return rules, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Copyright (c) 2025 Dell Inc., or its subsidiaries. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//  http://www.apache.org/licenses/LICENSE-2.0

package modules

import (
        "fmt"
        "strings"

        csmv1 "github.com/dell/csm-operator/api/v1"
        appsv1 "k8s.io/api/apps/v1"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/api/resource"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/util/intstr"
)
func getProxyServerScaffold(name, seninelName, namespace, proxyImage, opaImage, opaKubeMgmtImage, redisSecretName, redisPasswordKey string, replicas int32, sentinelReplicas int) appsv1.Deployment <span class="cov8" title="1">{
        return appsv1.Deployment{
                TypeMeta: metav1.TypeMeta{
                        Kind:       "Deployment",
                        APIVersion: "apps/v1",
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      "proxy-server",
                        Namespace: namespace,
                        Labels: map[string]string{
                                "app": "proxy-server",
                        },
                },
                Spec: appsv1.DeploymentSpec{
                        Replicas: &amp;replicas,
                        Selector: &amp;metav1.LabelSelector{
                                MatchLabels: map[string]string{
                                        "app": "proxy-server",
                                },
                        },
                        Template: corev1.PodTemplateSpec{
                                ObjectMeta: metav1.ObjectMeta{
                                        Labels: map[string]string{
                                                "csm": name,
                                                "app": "proxy-server",
                                        },
                                },
                                Spec: corev1.PodSpec{
                                        ServiceAccountName: "proxy-server",
                                        Containers: []corev1.Container{
                                                {
                                                        Name:            "proxy-server",
                                                        Image:           proxyImage,
                                                        ImagePullPolicy: "Always",
                                                        Env: []corev1.EnvVar{
                                                                {
                                                                        Name: "SENTINELS",
                                                                        Value: buildSentinelContainerEnv(sentinelReplicas, seninelName, namespace).Value,
                                                                },
                                                                {
                                                                        Name:  "REDIS_PASSWORD",
                                                                        ValueFrom: &amp;corev1.EnvVarSource{
                                                                                SecretKeyRef: &amp;corev1.SecretKeySelector{
                                                                                        LocalObjectReference: corev1.LocalObjectReference{
                                                                                                Name: redisSecretName,
                                                                                        },
                                                                                        Key: redisPasswordKey,
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                        Args: []string{
                                                                "--redis-sentinel=$(SENTINELS)",
                                                                "--redis-password=$(REDIS_PASSWORD)",
                                                                "--tenant-service=tenant-service.{{ .Release.Namespace }}.svc.cluster.local:50051",
                                                                "--role-service=role-service.{{ .Release.Namespace }}.svc.cluster.local:50051",
                                                                "--storage-service=storage-service.{{ .Release.Namespace }}.svc.cluster.local:50051",
                                                        },
                                                        Ports: []corev1.ContainerPort{
                                                                {
                                                                        ContainerPort: 8080,
                                                                },
                                                        },
                                                        VolumeMounts: []corev1.VolumeMount{
                                                                {
                                                                        Name:      "config-volume",
                                                                        MountPath: "/etc/karavi-authorization/config",
                                                                },
                                                                {
                                                                        Name:      "csm-config-params",
                                                                        MountPath: "/etc/karavi-authorization/csm-config-params",
                                                                },
                                                        },
                                                },
                                                {
                                                        Name: "opa",
                                                        Image: opaImage,
                                                        ImagePullPolicy: "Always",
                                                        Args: []string{
                                                                "run",
                                                                "--ignore=.",
                                                                "--server",
                                                                "--log-level=debug",
                                                        },
                                                        Ports: []corev1.ContainerPort{
                                                                {
                                                                        Name: "http",
                                                                        ContainerPort: 8181,
                                                                },
                                                        },
                                                },
                                                {
                                                        Name: "kube-mgmt",
                                                        Image: opaKubeMgmtImage,
                                                        ImagePullPolicy: "Always",
                                                        Env: []corev1.EnvVar{
                                                                {
                                                                        Name: "NAMESPACE",
                                                                        Value: namespace,
                                                                },
                                                        },
                                                        Args: []string{
                                                                "--namespaces=$(NAMESPACE)",
                                                        "--enable-data",
                                                        },
                                                },
                                        },
                                        Volumes: []corev1.Volume{
                                                {
                                                        Name: "config-volume",
                                                        VolumeSource: corev1.VolumeSource{
                                                                Secret: &amp;corev1.SecretVolumeSource{
                                                                        SecretName: "karavi-config-secret",
                                                                },
                                                        },
                                                },
                                                {
                                                        Name: "csm-config-params",
                                                        VolumeSource: corev1.VolumeSource{
                                                                ConfigMap: &amp;corev1.ConfigMapVolumeSource{
                                                                        LocalObjectReference: corev1.LocalObjectReference{
                                                                                Name: "csm-config-params",
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                },
        }
}</span>

// getStorageServiceScaffold returns the storage-service deployment with the common elements between v1 and v2
// callers must ensure that other elements specific for the version get set in the returned deployment
func getStorageServiceScaffold(name string, namespace string, image string, replicas int32) appsv1.Deployment <span class="cov8" title="1">{
        return appsv1.Deployment{
                TypeMeta: metav1.TypeMeta{
                        Kind:       "Deployment",
                        APIVersion: "apps/v1",
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      "storage-service",
                        Namespace: namespace,
                        Labels: map[string]string{
                                "app": "storage-service",
                        },
                },
                Spec: appsv1.DeploymentSpec{
                        Replicas: &amp;replicas,
                        Selector: &amp;metav1.LabelSelector{
                                MatchLabels: map[string]string{
                                        "app": "storage-service",
                                },
                        },
                        Template: corev1.PodTemplateSpec{
                                ObjectMeta: metav1.ObjectMeta{
                                        Labels: map[string]string{
                                                "csm": name,
                                                "app": "storage-service",
                                        },
                                },
                                Spec: corev1.PodSpec{
                                        ServiceAccountName: "storage-service",
                                        Containers: []corev1.Container{
                                                {
                                                        Name:            "storage-service",
                                                        Image:           image,
                                                        ImagePullPolicy: "Always",
                                                        Ports: []corev1.ContainerPort{
                                                                {
                                                                        ContainerPort: 50051,
                                                                        Name:          "grpc",
                                                                },
                                                        },
                                                        Env: []corev1.EnvVar{
                                                                {
                                                                        Name:  "NAMESPACE",
                                                                        Value: namespace,
                                                                },
                                                        },
                                                        VolumeMounts: []corev1.VolumeMount{
                                                                {
                                                                        Name:      "config-volume",
                                                                        MountPath: "/etc/karavi-authorization/config",
                                                                },
                                                                {
                                                                        Name:      "csm-config-params",
                                                                        MountPath: "/etc/karavi-authorization/csm-config-params",
                                                                },
                                                        },
                                                },
                                        },
                                        Volumes: []corev1.Volume{
                                                {
                                                        Name: "config-volume",
                                                        VolumeSource: corev1.VolumeSource{
                                                                Secret: &amp;corev1.SecretVolumeSource{
                                                                        SecretName: "karavi-config-secret",
                                                                },
                                                        },
                                                },
                                                {
                                                        Name: "csm-config-params",
                                                        VolumeSource: corev1.VolumeSource{
                                                                ConfigMap: &amp;corev1.ConfigMapVolumeSource{
                                                                        LocalObjectReference: corev1.LocalObjectReference{
                                                                                Name: "csm-config-params",
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                },
        }
}</span>

func getTenantServiceScaffold(name, namespace, seninelName, image, redisPasswordKey string, replicas int32) appsv1.Deployment <span class="cov8" title="1">{
        return appsv1.Deployment{
                TypeMeta: metav1.TypeMeta{
                        Kind:       "Deployment",
                        APIVersion: "apps/v1",
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      "tenant-service",
                        Namespace: namespace,
                        Labels: map[string]string{
                                "app": "tenant-service",
                        },
                },
                Spec: appsv1.DeploymentSpec{
                        Replicas: &amp;replicas,
                        Selector: &amp;metav1.LabelSelector{
                                MatchLabels: map[string]string{
                                        "app": "tenant-service",
                                },
                        },
                        Template: corev1.PodTemplateSpec{
                                ObjectMeta: metav1.ObjectMeta{
                                        Labels: map[string]string{
                                                "csm": name,
                                                "app": "tenant-service",
                                        },
                                },
                                Spec: corev1.PodSpec{
                                        ServiceAccountName: "tenant-service",
                                        Containers: []corev1.Container{
                                                {
                                                        Name:            "tenant-service",
                                                        Image:           image,
                                                        ImagePullPolicy: "Always",
                                                        Env: []corev1.EnvVar{
                                                                {
                                                                        Name: "SENTINELS",
                                                                        Value: buildSentinelContainerEnv(int(replicas), seninelName, namespace).Value,
                                                                },
                                                                {
                                                                        Name:  "REDIS_PASSWORD",
                                                                        ValueFrom: &amp;corev1.EnvVarSource{
                                                                                SecretKeyRef: &amp;corev1.SecretKeySelector{
                                                                                        LocalObjectReference: corev1.LocalObjectReference{
                                                                                                Name: redisSecretName,
                                                                                        },
                                                                                        Key: redisPasswordKey,
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                        Args: []string{
                                                                "--redis-sentinel=$(SENTINELS)",
                                                                "--redis-password=$(REDIS_PASSWORD)",
                                                        },
                                                        Ports: []corev1.ContainerPort{
                                                                {
                                                                        ContainerPort: 50051,
                                                                        Name:          "grpc",
                                                                },
                                                        },
                                                        VolumeMounts: []corev1.VolumeMount{
                                                                {
                                                                        Name:      "config-volume",
                                                                        MountPath: "/etc/karavi-authorization/config",
                                                                },
                                                                {
                                                                        Name:      "csm-config-params",
                                                                        MountPath: "/etc/karavi-authorization/csm-config-params",
                                                                },
                                                        },
                                                },
                                        },
                                        Volumes: []corev1.Volume{
                                                {
                                                        Name: "config-volume",
                                                        VolumeSource: corev1.VolumeSource{
                                                                Secret: &amp;corev1.SecretVolumeSource{
                                                                        SecretName: "karavi-config-secret",
                                                                },
                                                        },
                                                },
                                                {
                                                        Name: "csm-config-params",
                                                        VolumeSource: corev1.VolumeSource{
                                                                ConfigMap: &amp;corev1.ConfigMapVolumeSource{
                                                                        LocalObjectReference: corev1.LocalObjectReference{
                                                                                Name: "csm-config-params",
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                },
        }
}</span>

func getAuthorizationRedisStatefulsetScaffold(crName, name, namespace, image, redisSecretName, redisPasswordKey string, replicas int32) appsv1.StatefulSet <span class="cov8" title="1">{
        volName := "redis-primary-volume"

        return appsv1.StatefulSet{
                TypeMeta: metav1.TypeMeta{
                        Kind:       "StatefulSet",
                        APIVersion: "apps/v1",
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      name,
                        Namespace: namespace,
                },
                Spec: appsv1.StatefulSetSpec{
                        ServiceName: name,
                        Replicas:    &amp;replicas,
                        Selector: &amp;metav1.LabelSelector{
                                MatchLabels: map[string]string{
                                        "app": name,
                                },
                        },
                        Template: corev1.PodTemplateSpec{
                                ObjectMeta: metav1.ObjectMeta{
                                        Labels: map[string]string{
                                                "csm": crName,
                                                "app": name,
                                        },
                                },
                                Spec: corev1.PodSpec{
                                        ServiceAccountName: "redis",
                                        InitContainers: []corev1.Container{
                                                {
                                                        Name:            "config",
                                                        Image:           image,
                                                        ImagePullPolicy: "Always",
                                                        Env: []corev1.EnvVar{
                                                                {
                                                                        Name: "REDIS_PASSWORD",
                                                                        ValueFrom: &amp;corev1.EnvVarSource{
                                                                                SecretKeyRef: &amp;corev1.SecretKeySelector{
                                                                                        LocalObjectReference: corev1.LocalObjectReference{
                                                                                                Name: redisSecretName,
                                                                                        },
                                                                                        Key: redisPasswordKey,
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                        Command: []string{
                                                                "sh", "-c",
                                                        },
                                                        Args: []string{
                                                                `cp /csm-auth-redis-cm/redis.conf /etc/redis/redis.conf
                                                                echo "masterauth $REDIS_PASSWORD" &gt;&gt; /etc/redis/redis.conf
                                                                echo "requirepass $REDIS_PASSWORD" &gt;&gt; /etc/redis/redis.conf

                                                                echo "Finding master..."
                                                                MASTER_FDQN=$(hostname  -f | sed -e 's/{{ .Values.redis.name }}-[0-9]\./{{ .Values.redis.name }}-0./')
                                                                echo "Master at " $MASTER_FQDN
                                                                if [ "$(redis-cli -h sentinel -p 5000 ping)" != "PONG" ]; then
                                                                echo "No sentinel found..."
                                                                if [ "$(hostname)" = "{{ .Values.redis.name }}-0" ]; then
                                                                        echo "This is Redis master, not updating redis.conf..."
                                                                else
                                                                        echo "This is Redis replica, updating redis.conf..."
                                                                        echo "replicaof $MASTER_FDQN 6379" &gt;&gt; /etc/redis/redis.conf
                                                                fi
                                                                else
                                                                echo "Sentinel found, finding master..."
                                                                MASTER="$(redis-cli -h sentinel -p 5000 sentinel get-master-addr-by-name mymaster | grep -E '(^redis-csm-\d{1,})|([0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3})')"
                                                                echo "replicaof $MASTER_FDQN 6379" &gt;&gt; /etc/redis/redis.conf
                                                                fi
                                                                `,
                                                        },
                                                        VolumeMounts: []corev1.VolumeMount{
                                                                {
                                                                        Name:      volName,
                                                                        MountPath: "/data",
                                                                },
                                                                {
                                                                        Name:      "configmap",
                                                                        MountPath: "/csm-auth-redis-cm/",
                                                                },
                                                                {
                                                                        Name:      "config",
                                                                        MountPath: "/etc/redis/",
                                                                },
                                                        },
                                                },
                                        },
                                        Containers: []corev1.Container{
                                                {
                                                        Name:    name,
                                                        Image:   image,
                                                        Command: []string{"redis-server"},
                                                        Args:    []string{"/etc/redis/redis.conf"},
                                                        Ports: []corev1.ContainerPort{
                                                                {
                                                                        Name:          name,
                                                                        ContainerPort: 6379,
                                                                },
                                                        },
                                                        VolumeMounts: []corev1.VolumeMount{
                                                                {
                                                                        Name:      volName,
                                                                        MountPath: "/data",
                                                                },
                                                                {
                                                                        Name:      "configmap",
                                                                        MountPath: "/csm-auth-redis-cm/",
                                                                },
                                                                {
                                                                        Name:      "config",
                                                                        MountPath: "/etc/redis/",
                                                                },
                                                        },
                                                },
                                        },
                                        Volumes: []corev1.Volume{
                                                {
                                                        Name: volName,
                                                        VolumeSource: corev1.VolumeSource{
                                                                EmptyDir: &amp;corev1.EmptyDirVolumeSource{},
                                                        },
                                                },
                                                {
                                                        Name: "config",
                                                        VolumeSource: corev1.VolumeSource{
                                                                EmptyDir: &amp;corev1.EmptyDirVolumeSource{},
                                                        },
                                                },
                                                {
                                                        Name: "configmap",
                                                        VolumeSource: corev1.VolumeSource{
                                                                ConfigMap: &amp;corev1.ConfigMapVolumeSource{
                                                                        LocalObjectReference: corev1.LocalObjectReference{
                                                                                Name: "redis-cm",
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                },
        }
}</span>

func getAuthorizationRediscommanderDeploymentScaffold(crName, name, namespace, image, redisSecretName, redisUsernameKey, redisPasswordKey string, replicas int32) appsv1.Deployment <span class="cov8" title="1">{
        runAsNonRoot := true
        readOnlyRootFilesystem := false
        allowPrivilegeEscalation := false
        return appsv1.Deployment{
                TypeMeta: metav1.TypeMeta{
                        Kind:       "Deployment",
                        APIVersion: "apps/v1",
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      name,
                        Namespace: namespace,
                },
                Spec: appsv1.DeploymentSpec{
                        Replicas: &amp;replicas,
                        Selector: &amp;metav1.LabelSelector{
                                MatchLabels: map[string]string{
                                        "app": name,
                                },
                        },
                        Template: corev1.PodTemplateSpec{
                                ObjectMeta: metav1.ObjectMeta{
                                        Labels: map[string]string{
                                                "csm": crName,
                                                "app":  name,
                                                "tier": "backend",
                                        },
                                },
                                Spec: corev1.PodSpec{
                                        ServiceAccountName: "redis",
                                        Containers: []corev1.Container{
                                                {
                                                        Name:            name,
                                                        Image:           image,
                                                        ImagePullPolicy: "Always",
                                                        Env: []corev1.EnvVar{
                                                                {
                                                                        Name:  "SENTINELS",
                                                                        Value: buildSentinelContainerEnv(int(replicas), name, namespace).Value,
                                                                },
                                                                {
                                                                        Name:  "K8S_SIGTERM",
                                                                        Value: "1",
                                                                },
                                                                {
                                                                        Name: "REDIS_PASSWORD",
                                                                        ValueFrom: &amp;corev1.EnvVarSource{
                                                                                SecretKeyRef: &amp;corev1.SecretKeySelector{
                                                                                        LocalObjectReference: corev1.LocalObjectReference{
                                                                                                Name: redisSecretName,
                                                                                        },
                                                                                        Key: redisPasswordKey,
                                                                                },
                                                                        },
                                                                },
                                                                {
                                                                        Name: "SENTINEL_PASSWORD",
                                                                        ValueFrom: &amp;corev1.EnvVarSource{
                                                                                SecretKeyRef: &amp;corev1.SecretKeySelector{
                                                                                        LocalObjectReference: corev1.LocalObjectReference{
                                                                                                Name: redisSecretName,
                                                                                        },
                                                                                        Key: redisPasswordKey,
                                                                                },
                                                                        },
                                                                },
                                                                {
                                                                        Name: "HTTP_PASSWORD",
                                                                        ValueFrom: &amp;corev1.EnvVarSource{
                                                                                SecretKeyRef: &amp;corev1.SecretKeySelector{
                                                                                        LocalObjectReference: corev1.LocalObjectReference{
                                                                                                Name: redisSecretName,
                                                                                        },
                                                                                        Key: redisPasswordKey,
                                                                                },
                                                                        },
                                                                },
                                                                {
                                                                        Name: "HTTP_USER",
                                                                        ValueFrom: &amp;corev1.EnvVarSource{
                                                                                SecretKeyRef: &amp;corev1.SecretKeySelector{
                                                                                        LocalObjectReference: corev1.LocalObjectReference{
                                                                                                Name: redisSecretName,
                                                                                        },
                                                                                        Key: redisUsernameKey,
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                        Ports: []corev1.ContainerPort{
                                                                {
                                                                        ContainerPort: 8081,
                                                                        Name:          name,
                                                                },
                                                        },
                                                        LivenessProbe: &amp;corev1.Probe{
                                                                ProbeHandler: corev1.ProbeHandler{
                                                                        HTTPGet: &amp;corev1.HTTPGetAction{
                                                                                Path: "/favicon.png",
                                                                                Port: intstr.FromInt(8081),
                                                                        },
                                                                },
                                                                InitialDelaySeconds: 10,
                                                                TimeoutSeconds:      5,
                                                        },
                                                        Resources: corev1.ResourceRequirements{
                                                                Limits: corev1.ResourceList{
                                                                        corev1.ResourceMemory: resource.MustParse("512Mi"),
                                                                        corev1.ResourceCPU:    resource.MustParse("500m"),
                                                                },
                                                        },
                                                        SecurityContext: &amp;corev1.SecurityContext{
                                                                RunAsNonRoot:   &amp;runAsNonRoot,
                                                                ReadOnlyRootFilesystem: &amp;readOnlyRootFilesystem,
                                                                AllowPrivilegeEscalation: &amp;allowPrivilegeEscalation,
                                                                Capabilities: &amp;corev1.Capabilities{
                                                                        Drop: []corev1.Capability{
                                                                                "ALL",
                                                                        },
                                                                },
                                                        },
                                                        VolumeMounts: []corev1.VolumeMount{},
                                                },
                                        },
                                        Volumes: []corev1.Volume{},
                                },
                        },
                },
        }
}</span>

func getAuthorizationSentinelStatefulsetScaffold(crName, name, image, redisSecretName, redisPasswordKey string, replicas int32) appsv1.StatefulSet <span class="cov8" title="1">{
        return appsv1.StatefulSet{
                TypeMeta: metav1.TypeMeta{
                        Kind:       "StatefulSet",
                        APIVersion: "apps/v1",
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      name,
                },
                Spec: appsv1.StatefulSetSpec{
                        ServiceName: name,
                        Replicas:    &amp;replicas,
                        Selector: &amp;metav1.LabelSelector{
                                MatchLabels: map[string]string{
                                        "app": name,
                                },
                        },
                        Template: corev1.PodTemplateSpec{
                                ObjectMeta: metav1.ObjectMeta{
                                        Labels: map[string]string{
                                                "csm": crName,
                                                "app": name,
                                        },
                                },
                                Spec: corev1.PodSpec{
                                        ServiceAccountName: "sentinel",
                                        InitContainers: []corev1.Container{
                                                {
                                                        Name:            "config",
                                                        Image:           image,
                                                        Env: []corev1.EnvVar{
                                                                {
                                                                        Name: "REDIS_PASSWORD",
                                                                        ValueFrom: &amp;corev1.EnvVarSource{
                                                                                SecretKeyRef: &amp;corev1.SecretKeySelector{
                                                                                        LocalObjectReference: corev1.LocalObjectReference{
                                                                                                Name: redisSecretName,
                                                                                        },
                                                                                        Key: redisPasswordKey,
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                        Command: []string{
                                                                "sh", "-c",
                                                        },
                                                        Args: []string{
                                                                `replicas=$( expr {{ .Values.replicas | int }} - 1)
                                                                for i in $(seq 0 $replicas)
                                                                do
                                                                        node=$( echo "{{ .Values.name }}-$i.{{ .Values.name }}" )
                                                                        nodes=$( echo "$nodes*$node" )
                                                                done
                                                                loop=$(echo $nodes | sed -e "s/"*"/\n/g")

                                                                foundMaster="false"
                                                                while [ "$foundMaster" != "true" ]
                                                                do
                                                                        for i in $loop
                                                                        do
                                                                                echo "Finding master at $i"
                                                                                MASTER=$(redis-cli --no-auth-warning --raw -h $i -a $REDIS_PASSWORD info replication | awk '{print $1}' | grep master_host: | cut -d ":" -f2)
                                                                                if [ "$MASTER" = "" ]; then
                                                                                        echo "Master not found..."
                                                                                        echo "Sleeping 5 seconds for pods to come up..."
                                                                                        sleep 5
                                                                                        MASTER=
                                                                                else
                                                                                        echo "Master found at $MASTER..."
                                                                                        foundMaster="true"
                                                                                        break
                                                                                fi
                                                                        done
                                                                done

                                                                echo "sentinel monitor mymaster $MASTER 6379 2" &gt;&gt; /tmp/master
                                                                echo "port 5000
                                                                sentinel resolve-hostnames yes
                                                                sentinel announce-hostnames yes
                                                                $(cat /tmp/master)
                                                                sentinel down-after-milliseconds mymaster 5000
                                                                sentinel failover-timeout mymaster 60000
                                                                sentinel parallel-syncs mymaster 2
                                                                sentinel auth-pass mymaster $REDIS_PASSWORD
                                                                " &gt; /etc/redis/sentinel.conf
                                                                cat /etc/redis/sentinel.conf
                                                                `,
                                                        },
                                                        VolumeMounts: []corev1.VolumeMount{
                                                                {
                                                                        Name:      "redis-config",
                                                                        MountPath: "/etc/redis/",
                                                                },
                                                        },
                                                },
                                        },
                                        Containers: []corev1.Container{
                                                {
                                                        Name:    name,
                                                        Image:   image,
                                                        Command: []string{"redis-sentinel"},
                                                        Args:    []string{"/etc/redis/sentinel.conf"},
                                                        Ports: []corev1.ContainerPort{
                                                                {
                                                                        Name:          name,
                                                                        ContainerPort: 5000,
                                                                },
                                                        },
                                                        VolumeMounts: []corev1.VolumeMount{
                                                                {
                                                                        Name:      "redis-config",
                                                                        MountPath: "/etc/redis/",
                                                                },
                                                                {
                                                                        Name:      "data",
                                                                        MountPath: "/data",
                                                                },
                                                        },
                                                },
                                        },
                                        Volumes: []corev1.Volume{
                                                {
                                                        Name: "redis-config",
                                                        VolumeSource: corev1.VolumeSource{
                                                                EmptyDir: &amp;corev1.EmptyDirVolumeSource{},
                                                        },
                                                },
                                                {
                                                        Name: "data",
                                                        VolumeSource: corev1.VolumeSource{
                                                                EmptyDir: &amp;corev1.EmptyDirVolumeSource{},
                                                        },
                                                },
                                        },
                                },
                        },
                },
        }
}</span>

var buildSentinelEnvFunc = buildSentinelContainerEnv

func buildSentinelContainerEnv(replicas int, sentinelName, namespace string) corev1.EnvVar <span class="cov8" title="1">{
        var endpoints []string
        for i := range replicas </span><span class="cov8" title="1">{
                endpoint := fmt.Sprintf("%s-%d.%s.%s.svc.cluster.local:5000", sentinelName, i, sentinelName, namespace)
                endpoints = append(endpoints, endpoint)
        }</span>

        <span class="cov8" title="1">return corev1.EnvVar{
                Name:  "SENTINELS",
                Value: strings.Join(endpoints, ","),
        }</span>
}

func createRedisK8sSecret(cr csmv1.ContainerStorageModule, usernameKey, passworkKey string) corev1.Secret <span class="cov8" title="1">{
        return corev1.Secret{
                TypeMeta: metav1.TypeMeta{
                        Kind: "Secret",
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      defaultRedisSecretName,
                        Namespace: cr.Namespace,
                },
                Type: corev1.SecretTypeBasicAuth,
                StringData: map[string]string{
                        passworkKey: "K@ravi123!",
                        usernameKey: "dev",
                },
        }
}</span>

func redisVolume(redisSecretName string) corev1.Volume <span class="cov8" title="1">{
        volumeName := "secrets-store-inline-redis"
        readOnly := true
        return corev1.Volume{
                Name: volumeName,
                VolumeSource: corev1.VolumeSource{
                        CSI: &amp;corev1.CSIVolumeSource{
                                Driver:   "secrets-store.csi.k8s.io",
                                ReadOnly: &amp;readOnly,
                                VolumeAttributes: map[string]string{
                                        "secretProviderClass": redisSecretName,
                                },
                        },
                },
        }
}</span>

func redisVolumeMount() corev1.VolumeMount <span class="cov8" title="1">{
        volumeName := "secrets-store-inline-redis"
        return corev1.VolumeMount{
                Name:      volumeName,
                MountPath: "/etc/csm-authorization/redis",
                ReadOnly:  true,
        }
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">//  Copyright Â© 2022 Dell Inc. or its subsidiaries. All Rights Reserved.
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//       http://www.apache.org/licenses/LICENSE-2.0
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package modules

import (
        "context"
        "fmt"
        "os"
        "path/filepath"
        "strings"

        csmv1 "github.com/dell/csm-operator/api/v1"
        operatorutils "github.com/dell/csm-operator/pkg/operatorutils"
        crclient "sigs.k8s.io/controller-runtime/pkg/client"
)

const (
        // DefaultPluginIdentifier - spring placeholder for driver plugin
        DefaultPluginIdentifier = "&lt;DriverPluginIdentifier&gt;"
        // DefaultDriverConfigParamsVolumeMount - string placeholder for Driver ConfigParamsVolumeMount
        DefaultDriverConfigParamsVolumeMount = "&lt;DriverConfigParamsVolumeMount&gt;"
        // CertManagerManifest -
        CertManagerManifest = "cert-manager.yaml"
        // CertManagerCRDsManifest -
        CertManagerCRDsManifest = "cert-manager-crds.yaml"
        // CommonNamespace -
        CommonNamespace = "&lt;NAMESPACE&gt;"
        // CSMName - name
        CSMName = "&lt;NAME&gt;"
        // ComConfigCSMNameSpace - namespace CSM is found in. Needed for cases where pod namespace is not namespace of CSM
        ComConfigCSMNameSpace string = "&lt;CSM_NAMESPACE&gt;"
)

// SupportedDriverParam -
type SupportedDriverParam struct {
        PluginIdentifier              string
        DriverConfigParamsVolumeMount string
}

func checkVersion(moduleType, givenVersion, configPath string) error <span class="cov8" title="1">{
        files, err := os.ReadDir(fmt.Sprintf("%s/moduleconfig/%s/", configPath, moduleType))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">found := false
        supportedVersions := ""
        for _, file := range files </span><span class="cov8" title="1">{
                supportedVersions += (file.Name() + ",")
                if file.Name() == givenVersion </span><span class="cov8" title="1">{
                        found = true
                }</span>
        }
        <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                return fmt.Errorf(
                        "CSM %s does not have %s version. The following are supported versions: %s",
                        moduleType, givenVersion, supportedVersions[:len(supportedVersions)-1],
                )
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func readConfigFile(module csmv1.Module, cr csmv1.ContainerStorageModule, op operatorutils.OperatorConfig, filename string) ([]byte, error) <span class="cov8" title="1">{
        var err error
        moduleConfigVersion := module.ConfigVersion
        if moduleConfigVersion == "" </span><span class="cov8" title="1">{
                moduleConfigVersion, err = operatorutils.GetModuleDefaultVersion(cr.Spec.Driver.ConfigVersion, cr.Spec.Driver.CSIDriverType, module.Name, op.ConfigDirectory)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">if module.Name == csmv1.AuthorizationServer </span><span class="cov8" title="1">{
                configPath := fmt.Sprintf("%s/moduleconfig/%s/%s/%s", op.ConfigDirectory, csmv1.Authorization, moduleConfigVersion, filename)
                return os.ReadFile(filepath.Clean(configPath))
        }</span>

        <span class="cov8" title="1">configMapPath := fmt.Sprintf("%s/moduleconfig/%s/%s/%s", op.ConfigDirectory, module.Name, moduleConfigVersion, filename)
        return os.ReadFile(filepath.Clean(configMapPath))</span>
}

// getCertManager - configure cert-manager with the specified namespace before installation
func getCertManager(op operatorutils.OperatorConfig, cr csmv1.ContainerStorageModule) (string, error) <span class="cov8" title="1">{
        YamlString := ""

        certManagerPath := fmt.Sprintf("%s/moduleconfig/common/cert-manager/%s", op.ConfigDirectory, CertManagerManifest)
        buf, err := os.ReadFile(filepath.Clean(certManagerPath))
        if err != nil </span><span class="cov8" title="1">{
                return YamlString, err
        }</span>

        <span class="cov8" title="1">YamlString = string(buf)
        certNamespace := cr.Namespace
        YamlString = strings.ReplaceAll(YamlString, CommonNamespace, certNamespace)
        YamlString = strings.ReplaceAll(YamlString, CSMName, cr.Name)
        YamlString = strings.ReplaceAll(YamlString, ComConfigCSMNameSpace, cr.Namespace)

        return YamlString, nil</span>
}

func getCertManagerCRDs(op operatorutils.OperatorConfig) (string, error) <span class="cov8" title="1">{
        YamlString := ""

        certManagerPath := fmt.Sprintf("%s/moduleconfig/common/cert-manager/%s", op.ConfigDirectory, CertManagerCRDsManifest)
        buf, err := os.ReadFile(filepath.Clean(certManagerPath))
        if err != nil </span><span class="cov0" title="0">{
                return YamlString, err
        }</span>

        <span class="cov8" title="1">YamlString = string(buf)
        return YamlString, nil</span>
}

// CommonCertManager - apply/delete cert-manager objects
func CommonCertManager(ctx context.Context, isDeleting bool, op operatorutils.OperatorConfig, cr csmv1.ContainerStorageModule, ctrlClient crclient.Client) error <span class="cov8" title="1">{
        YamlString, err := getCertManager(op, cr)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">crdYamlString, err := getCertManagerCRDs(op)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">ctrlObjects, err := operatorutils.GetModuleComponentObj([]byte(YamlString))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">crdObjects, err := operatorutils.GetModuleComponentObj([]byte(crdYamlString))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // keep cert-manager CRDs in place, even if cert-manager is uninstalled
        <span class="cov8" title="1">for _, crdObj := range crdObjects </span><span class="cov8" title="1">{
                if !isDeleting </span><span class="cov8" title="1">{
                        if err := operatorutils.ApplyObject(ctx, crdObj, ctrlClient); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov8" title="1">for _, ctrlObj := range ctrlObjects </span><span class="cov8" title="1">{
                if isDeleting </span><span class="cov8" title="1">{
                        if err := operatorutils.DeleteObject(ctx, ctrlObj, ctrlClient); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                } else<span class="cov8" title="1"> {
                        if err := operatorutils.ApplyObject(ctx, ctrlObj, ctrlClient); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Copyright (c) 2025 Dell Inc., or its subsidiaries. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//  http://www.apache.org/licenses/LICENSE-2.0

package modules

import (
        "context"
        "fmt"
        "slices"
        "strings"

        k8serrors "k8s.io/apimachinery/pkg/api/errors"

        csmv1 "github.com/dell/csm-operator/api/v1"
        drivers "github.com/dell/csm-operator/pkg/drivers"
        "github.com/dell/csm-operator/pkg/logger"
        operatorutils "github.com/dell/csm-operator/pkg/operatorutils"
        "github.com/dell/csm-operator/pkg/resources/deployment"
        appsv1 "k8s.io/api/apps/v1"
        confv1 "k8s.io/client-go/applyconfigurations/apps/v1"
        acorev1 "k8s.io/client-go/applyconfigurations/core/v1"
        "k8s.io/client-go/kubernetes"
        "sigs.k8s.io/controller-runtime/pkg/client"
        crclient "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/yaml"
)

const (
        // ObservabilityOtelCollectorName - component otel-collector
        ObservabilityOtelCollectorName string = "otel-collector"

        // ObservabilityTopologyName - component topology
        ObservabilityTopologyName string = "topology"

        // ObservabilityCertManagerComponent cert-manager component name
        ObservabilityCertManagerComponent string = "cert-manager"

        // ObservabilityMetricsPowerScaleName - component metrics-powerscale
        ObservabilityMetricsPowerScaleName string = "metrics-powerscale"

        // ObservabilityMetricsPowerFlexName - component metrics-powerflex
        ObservabilityMetricsPowerFlexName string = "metrics-powerflex"

        // ObservabilityMetricsPowerMaxName - component metrics-powermax
        ObservabilityMetricsPowerMaxName string = "metrics-powermax"

        // TopologyLogLevel -
        TopologyLogLevel string = "&lt;TOPOLOGY_LOG_LEVEL&gt;"

        // TopologyYamlFile -
        TopologyYamlFile string = "karavi-topology.yaml"

        // OtelCollectorAddress - Otel collector address
        OtelCollectorAddress string = "&lt;COLLECTOR_ADDRESS&gt;"

        // PowerScaleMaxConcurrentQueries - max concurrent queries
        PowerScaleMaxConcurrentQueries string = "&lt;POWERSCALE_MAX_CONCURRENT_QUERIES&gt;"

        // PowerscaleCapacityMetricsEnabled - enable/disable collection of capacity metrics
        PowerscaleCapacityMetricsEnabled string = "&lt;POWERSCALE_CAPACITY_METRICS_ENABLED&gt;"

        // PowerscalePerformanceMetricsEnabled - enable/disable collection of performance metrics
        PowerscalePerformanceMetricsEnabled string = "&lt;POWERSCALE_PERFORMANCE_METRICS_ENABLED&gt;"

        // PowerscaleClusterCapacityPollFrequency - polling frequency to get cluster capacity data
        PowerscaleClusterCapacityPollFrequency string = "&lt;POWERSCALE_CLUSTER_CAPACITY_POLL_FREQUENCY&gt;"

        // PowerscaleClusterPerformancePollFrequency - polling frequency to get cluster performance data
        PowerscaleClusterPerformancePollFrequency string = "&lt;POWERSCALE_CLUSTER_PERFORMANCE_POLL_FREQUENCY&gt;"

        // PowerscaleQuotaCapacityPollFrequency - polling frequency to get Quota capacity data
        PowerscaleQuotaCapacityPollFrequency string = "&lt;POWERSCALE_QUOTA_CAPACITY_POLL_FREQUENCY&gt;"

        // IsiclientInsecure - skip certificate validation
        IsiclientInsecure string = "&lt;ISICLIENT_INSECURE&gt;"

        // IsiclientAuthType - enables session-based/basic authentication
        IsiclientAuthType string = "&lt;ISICLIENT_AUTH_TYPE&gt;"

        // IsiclientVerbose - content of the OneFS REST API message
        IsiclientVerbose string = "&lt;ISICLIENT_VERBOSE&gt;"

        // PowerscaleLogLevel - the level for the PowerScale metrics
        PowerscaleLogLevel string = "&lt;POWERSCALE_LOG_LEVEL&gt;"

        // PowerscaleLogFormat - log format
        PowerscaleLogFormat string = "&lt;POWERSCALE_LOG_FORMAT&gt;"

        // PowerflexSdcMetricsEnabled - enable/disable collection of sdc metrics
        PowerflexSdcMetricsEnabled string = "&lt;POWERFLEX_SDC_METRICS_ENABLED&gt;"

        // PowerflexVolumeMetricsEnabled - enable/disable collection of volume metrics
        PowerflexVolumeMetricsEnabled string = "&lt;POWERFLEX_VOLUME_METRICS_ENABLED&gt;"

        // PowerflexStoragePoolMetricsEnabled - enable/disable collection of storage pool metrics
        PowerflexStoragePoolMetricsEnabled string = "&lt;POWERFLEX_STORAGE_POOL_METRICS_ENABLED&gt;"

        // PowerflexSdcIoPollFrequency - polling frequency to get sdc data
        PowerflexSdcIoPollFrequency string = "&lt;POWERFLEX_SDC_IO_POLL_FREQUENCY&gt;"

        // PowerflexVolumeIoPollFrequency - polling frequency to get volume data
        PowerflexVolumeIoPollFrequency string = "&lt;POWERFLEX_VOLUME_IO_POLL_FREQUENCY&gt;"

        // PowerflexStoragePoolPollFrequency - polling frequency to get storage pool data
        PowerflexStoragePoolPollFrequency string = "&lt;POWERFLEX_STORAGE_POOL_POLL_FREQUENCY&gt;"

        // PowerflexMaxConcurrentQueries - max concurrent queries
        PowerflexMaxConcurrentQueries string = "&lt;POWERFLEX_MAX_CONCURRENT_QUERIES&gt;"

        // PowerflexLogLevel - the level for the PowerFlex metrics
        PowerflexLogLevel string = "&lt;POWERFLEX_LOG_LEVEL&gt;"

        // PowerflexLogFormat - log format
        PowerflexLogFormat string = "&lt;POWERFLEX_LOG_FORMAT&gt;"

        // NginxProxyImage - Nginx proxy image name
        NginxProxyImage string = "&lt;NGINX_PROXY_IMAGE&gt;"

        // OtelCollectorImage - Otel collector image name
        OtelCollectorImage string = "&lt;OTEL_COLLECTOR_IMAGE&gt;"

        // PscaleObsYamlFile - PowerScale Observability yaml file
        PscaleObsYamlFile string = "karavi-metrics-powerscale.yaml"

        // OtelCollectorYamlFile - Otel Collector yaml file
        OtelCollectorYamlFile string = "karavi-otel-collector.yaml"

        // DriverDefaultReleaseName constant
        DriverDefaultReleaseName string = "&lt;DriverDefaultReleaseName&gt;"

        // PflexObsYamlFile - powerflex metrics yaml file
        PflexObsYamlFile string = "karavi-metrics-powerflex.yaml"

        // PmaxCapacityMetricsEnabled - enable/disable capacity metrics
        PmaxCapacityMetricsEnabled string = "&lt;POWERMAX_CAPACITY_METRICS_ENABLED&gt;"

        // PmaxCapacityPollFreq - polling frequency to get capacity metrics
        PmaxCapacityPollFreq string = "&lt;POWERMAX_CAPACITY_POLL_FREQUENCY&gt;"

        // PmaxPerformanceMetricsEnabled - enable/disable performance metrics
        PmaxPerformanceMetricsEnabled string = "&lt;POWERMAX_PERFORMANCE_METRICS_ENABLED&gt;"

        // PmaxPerformancePollFreq - polling frequency to get capacity metrics
        PmaxPerformancePollFreq string = "&lt;POWERMAX_PERFORMANCE_POLL_FREQUENCY&gt;"

        // PmaxConcurrentQueries - number of concurrent queries
        PmaxConcurrentQueries string = "&lt;POWERMAX_MAX_CONCURRENT_QUERIES&gt;"

        // PmaxLogLevel - the level for the Powermax metrics
        PmaxLogLevel string = "&lt;POWERMAX_LOG_LEVEL&gt;"

        // PmaxLogFormat - log format for Powermax metrics
        PmaxLogFormat string = "&lt;POWERMAX_LOG_FORMAT&gt;"

        // PMaxObsYamlFile - powermax metrics yaml file
        PMaxObsYamlFile string = "karavi-metrics-powermax.yaml"

        // SelfSignedCert - self-signed certificate file
        SelfSignedCert string = "selfsigned-cert.yaml"

        // CustomCert - custom certificate file
        CustomCert string = "custom-cert.yaml"

        // ObservabilityCertificate -- certificate for either topology or otel-collector in base64
        ObservabilityCertificate string = "&lt;BASE64_CERTIFICATE&gt;"

        // ObservabilityPrivateKey -- private key for either topology or otel-collector in base64
        ObservabilityPrivateKey string = "&lt;BASE64_PRIVATE_KEY&gt;"

        // ObservabilitySecretPrefix --  placeholder for either karavi-topology or otel-collector
        ObservabilitySecretPrefix string = "&lt;OBSERVABILITY_SECRET_PREFIX&gt;" // #nosec G101 -- false positive

        // CSMNameSpace - namespace CSM is found in. Needed for cases where pod namespace is not namespace of CSM
        CSMNameSpace string = "&lt;CSM_NAMESPACE&gt;"
)

// ComponentNameToSecretPrefix - map from component name to secret prefix
var ComponentNameToSecretPrefix = map[string]string{ObservabilityOtelCollectorName: "otel-collector", ObservabilityTopologyName: "karavi-topology"}

// ObservabilitySupportedDrivers is a map containing the CSI Drivers supported by CSM Replication. The key is driver name and the value is the driver plugin identifier
var ObservabilitySupportedDrivers = map[string]SupportedDriverParam{
        "powerscale": {
                PluginIdentifier:              drivers.PowerScalePluginIdentifier,
                DriverConfigParamsVolumeMount: drivers.PowerScaleConfigParamsVolumeMount,
        },
        "isilon": {
                PluginIdentifier:              drivers.PowerScalePluginIdentifier,
                DriverConfigParamsVolumeMount: drivers.PowerScaleConfigParamsVolumeMount,
        },
        "powerflex": {
                PluginIdentifier:              drivers.PowerFlexPluginIdentifier,
                DriverConfigParamsVolumeMount: drivers.PowerFlexConfigParamsVolumeMount,
        },
        "vxflexos": {
                PluginIdentifier:              drivers.PowerFlexPluginIdentifier,
                DriverConfigParamsVolumeMount: drivers.PowerFlexConfigParamsVolumeMount,
        },
        string(csmv1.PowerMax): {
                PluginIdentifier:              drivers.PowerMaxPluginIdentifier,
                DriverConfigParamsVolumeMount: drivers.PowerMaxConfigParamsVolumeMount,
        },
}

var defaultVolumeConfigName = map[csmv1.DriverType]string{
        csmv1.PowerScaleName: "isilon-creds",
        csmv1.PowerScale:     "isilon-creds",
        csmv1.PowerFlexName:  "vxflexos-config",
        csmv1.PowerFlex:      "vxflexos-config",
}

var defaultSecretsName = map[csmv1.DriverType]string{
        csmv1.PowerScale:     "&lt;DriverDefaultReleaseName&gt;-creds",
        csmv1.PowerScaleName: "&lt;DriverDefaultReleaseName&gt;-creds",
        csmv1.PowerFlex:      "&lt;DriverDefaultReleaseName&gt;-config",
        csmv1.PowerFlexName:  "&lt;DriverDefaultReleaseName&gt;-config",
        csmv1.PowerMax:       "&lt;DriverDefaultReleaseName&gt;-creds",
}

var defaultAuthSecretsName = []string{"karavi-authorization-config", "proxy-authz-tokens", "proxy-server-root-certificate"}

// ObservabilityPrecheck  - runs precheck for CSM Otoolsabilitytools
func ObservabilityPrecheck(ctx context.Context, op operatorutils.OperatorConfig, obs csmv1.Module, cr csmv1.ContainerStorageModule, _ operatorutils.ReconcileCSM) error <span class="cov8" title="1">{
        log := logger.GetLogger(ctx)

        if _, ok := ObservabilitySupportedDrivers[string(cr.Spec.Driver.CSIDriverType)]; !ok </span><span class="cov8" title="1">{
                return fmt.Errorf("CSM Operator does not suport Observability deployment for %s driver", cr.Spec.Driver.CSIDriverType)
        }</span>

        // check if provided version is supported
        <span class="cov8" title="1">if obs.ConfigVersion != "" </span><span class="cov8" title="1">{
                err := checkVersion(string(csmv1.Observability), obs.ConfigVersion, op.ConfigDirectory)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">log.Infof("\nperformed pre checks for: %s", obs.Name)
        return nil</span>
}

// ObservabilityTopology - delete or update topology objectstools
func ObservabilityTopology(ctx context.Context, isDeleting bool, op operatorutils.OperatorConfig, cr csmv1.ContainerStorageModule, ctrlClient client.Client) error <span class="cov8" title="1">{
        log := logger.GetLogger(ctx)
        topoObjects, err := getTopology(op, cr)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">for _, ctrlObj := range topoObjects </span><span class="cov8" title="1">{
                log.Infow("current topoObject is ", "ctrlObj", ctrlObj)
                if isDeleting </span><span class="cov8" title="1">{
                        if err := operatorutils.DeleteObject(ctx, ctrlObj, ctrlClient); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                } else<span class="cov8" title="1"> {
                        if err := operatorutils.ApplyCTRLObject(ctx, ctrlObj, ctrlClient); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

func getTopology(op operatorutils.OperatorConfig, cr csmv1.ContainerStorageModule) ([]crclient.Object, error) <span class="cov8" title="1">{
        obs, err := getObservabilityModule(cr)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">buf, err := readConfigFile(obs, cr, op, TopologyYamlFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">YamlString := string(buf)

        logLevel := "INFO"
        topologyImage := ""

        for _, component := range obs.Components </span><span class="cov8" title="1">{
                if component.Name == ObservabilityTopologyName </span><span class="cov8" title="1">{
                        if component.Image != "" </span><span class="cov8" title="1">{
                                topologyImage = string(component.Image)
                        }</span>
                        <span class="cov8" title="1">for _, env := range component.Envs </span><span class="cov8" title="1">{
                                if strings.Contains(TopologyLogLevel, env.Name) </span><span class="cov8" title="1">{
                                        logLevel = env.Value
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">YamlString = strings.ReplaceAll(YamlString, CSMName, cr.Name)
        YamlString = strings.ReplaceAll(YamlString, CSMNameSpace, cr.Namespace)
        YamlString = strings.ReplaceAll(YamlString, TopologyLogLevel, logLevel)

        topoObjects, err := operatorutils.GetModuleComponentObj([]byte(YamlString))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">operatorutils.SetContainerImage(topoObjects, "karavi-topology", "karavi-topology", topologyImage)

        return topoObjects, nil</span>
}

// OtelCollector - delete or update otel collector objects
func OtelCollector(ctx context.Context, isDeleting bool, op operatorutils.OperatorConfig, cr csmv1.ContainerStorageModule, ctrlClient client.Client) error <span class="cov8" title="1">{
        YamlString, err := getOtelCollector(op, cr)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">otelObjects, err := operatorutils.GetModuleComponentObj([]byte(YamlString))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for _, ctrlObj := range otelObjects </span><span class="cov8" title="1">{
                if isDeleting </span><span class="cov8" title="1">{
                        if err := operatorutils.DeleteObject(ctx, ctrlObj, ctrlClient); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                } else<span class="cov8" title="1"> {
                        if err := operatorutils.ApplyCTRLObject(ctx, ctrlObj, ctrlClient); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// getOtelCollector - get otel collector yaml string
func getOtelCollector(op operatorutils.OperatorConfig, cr csmv1.ContainerStorageModule) (string, error) <span class="cov8" title="1">{
        YamlString := ""

        obs, err := getObservabilityModule(cr)
        if err != nil </span><span class="cov8" title="1">{
                return YamlString, err
        }</span>

        <span class="cov8" title="1">buf, err := readConfigFile(obs, cr, op, OtelCollectorYamlFile)
        if err != nil </span><span class="cov0" title="0">{
                return YamlString, err
        }</span>
        <span class="cov8" title="1">YamlString = string(buf)

        nginxProxyImage := "nginxinc/nginx-unprivileged:1.27"
        otelCollectorImage := "ghcr.io/open-telemetry/opentelemetry-collector-releases/opentelemetry-collector:0.124.0"
        configVersion := cr.Spec.Driver.ConfigVersion
        // Currently supported config versions by this operator(release candidate for CSM v2.14.0) are v2.11.0, v2.12.0, v2.13.0.
        // These config versions were already supported by the released operators. So use the same otel image for them.
        if configVersion == "v2.11.0" || configVersion == "v2.12.0" || configVersion == "v2.13.0" </span><span class="cov8" title="1">{
                otelCollectorImage = "otel/opentelemetry-collector:0.42.0"
        }</span>

        <span class="cov8" title="1">for _, component := range obs.Components </span><span class="cov8" title="1">{
                if component.Name == ObservabilityOtelCollectorName </span><span class="cov8" title="1">{
                        if component.Image != "" </span><span class="cov8" title="1">{
                                otelCollectorImage = string(component.Image)
                        }</span>
                        <span class="cov8" title="1">for _, env := range component.Envs </span><span class="cov8" title="1">{
                                if strings.Contains(NginxProxyImage, env.Name) </span><span class="cov8" title="1">{
                                        nginxProxyImage = env.Value
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">YamlString = strings.ReplaceAll(YamlString, CSMName, cr.Name)
        YamlString = strings.ReplaceAll(YamlString, CSMNameSpace, cr.Namespace)
        YamlString = strings.ReplaceAll(YamlString, OtelCollectorImage, otelCollectorImage)
        YamlString = strings.ReplaceAll(YamlString, NginxProxyImage, nginxProxyImage)

        return YamlString, nil</span>
}

// PowerScaleMetrics - delete or update powerscale metrics objects
func PowerScaleMetrics(ctx context.Context, isDeleting bool, op operatorutils.OperatorConfig, cr csmv1.ContainerStorageModule, ctrlClient client.Client, k8sClient kubernetes.Interface) error <span class="cov8" title="1">{
        log := logger.GetLogger(ctx)

        powerscaleMetricsObjects, err := getPowerScaleMetricsObjects(op, cr)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // update secret volume and inject authorization to deployment
        <span class="cov8" title="1">var dpApply *confv1.DeploymentApplyConfiguration
        foundDp := false
        for i, obj := range powerscaleMetricsObjects </span><span class="cov8" title="1">{
                if deployment, ok := obj.(*appsv1.Deployment); ok </span><span class="cov8" title="1">{
                        dpApply, err = parseObservabilityMetricsDeployment(ctx, deployment, op, cr)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">foundDp = true
                        powerscaleMetricsObjects[i] = powerscaleMetricsObjects[len(powerscaleMetricsObjects)-1]
                        powerscaleMetricsObjects = powerscaleMetricsObjects[:len(powerscaleMetricsObjects)-1]
                        break</span>
                }
        }
        <span class="cov8" title="1">if !foundDp </span><span class="cov0" title="0">{
                return fmt.Errorf("could not find deployment obj")
        }</span>

        <span class="cov8" title="1">for _, ctrlObj := range powerscaleMetricsObjects </span><span class="cov8" title="1">{
                if isDeleting </span><span class="cov8" title="1">{
                        if err := operatorutils.DeleteObject(ctx, ctrlObj, ctrlClient); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                } else<span class="cov8" title="1"> {
                        if err := operatorutils.ApplyCTRLObject(ctx, ctrlObj, ctrlClient); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        // update Deployment
        <span class="cov8" title="1">if isDeleting </span><span class="cov8" title="1">{
                // Delete Deployment
                deploymentKey := client.ObjectKey{
                        Namespace: *dpApply.Namespace,
                        Name:      *dpApply.Name,
                }
                deploymentObj := &amp;appsv1.Deployment{}
                if err = ctrlClient.Get(ctx, deploymentKey, deploymentObj); err == nil </span><span class="cov8" title="1">{
                        if err = ctrlClient.Delete(ctx, deploymentObj); err != nil &amp;&amp; !k8serrors.IsNotFound(err) </span><span class="cov0" title="0">{
                                return fmt.Errorf("error delete deployment: %v", err)
                        }</span>
                } else<span class="cov8" title="1"> {
                        log.Infow("error getting deployment", "deploymentKey", deploymentKey)
                }</span>
        } else<span class="cov8" title="1"> {
                // Create/Update Deployment
                if err = deployment.SyncDeployment(ctx, *dpApply, k8sClient, cr.Name); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// getPowerScaleMetricsObjects - get powerscale metrics yaml string
func getPowerScaleMetricsObjects(op operatorutils.OperatorConfig, cr csmv1.ContainerStorageModule) ([]crclient.Object, error) <span class="cov8" title="1">{
        obs, err := getObservabilityModule(cr)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">buf, err := readConfigFile(obs, cr, op, PscaleObsYamlFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">YamlString := string(buf)

        logLevel := "INFO"
        otelCollectorAddress := "otel-collector:55680"
        pscaleImage := ""
        maxConcurrentQueries := "10"
        capacityEnabled := "true"
        performanceEnabled := "true"
        clusterCapacityPollFrequency := "30"
        clusterPerformancePollFrequency := "20"
        quotaCapacityPollFrequency := "30"
        clientInsecure := "true"
        clientAuthType := "1"
        clientVerbose := "0"
        logFormat := "TEXT"

        for _, component := range obs.Components </span><span class="cov8" title="1">{
                if component.Name == ObservabilityMetricsPowerScaleName </span><span class="cov8" title="1">{
                        if component.Image != "" </span><span class="cov8" title="1">{
                                pscaleImage = string(component.Image)
                        }</span>
                        <span class="cov8" title="1">for _, env := range component.Envs </span><span class="cov8" title="1">{
                                if strings.Contains(PowerscaleLogLevel, env.Name) </span><span class="cov8" title="1">{
                                        logLevel = env.Value
                                }</span> else<span class="cov8" title="1"> if strings.Contains(PowerScaleMaxConcurrentQueries, env.Name) </span><span class="cov8" title="1">{
                                        maxConcurrentQueries = env.Value
                                }</span> else<span class="cov8" title="1"> if strings.Contains(PowerscaleCapacityMetricsEnabled, env.Name) </span><span class="cov8" title="1">{
                                        capacityEnabled = env.Value
                                }</span> else<span class="cov8" title="1"> if strings.Contains(PowerscalePerformanceMetricsEnabled, env.Name) </span><span class="cov8" title="1">{
                                        performanceEnabled = env.Value
                                }</span> else<span class="cov8" title="1"> if strings.Contains(PowerscaleClusterCapacityPollFrequency, env.Name) </span><span class="cov8" title="1">{
                                        clusterCapacityPollFrequency = env.Value
                                }</span> else<span class="cov8" title="1"> if strings.Contains(PowerscaleClusterPerformancePollFrequency, env.Name) </span><span class="cov8" title="1">{
                                        clusterPerformancePollFrequency = env.Value
                                }</span> else<span class="cov8" title="1"> if strings.Contains(PowerscaleQuotaCapacityPollFrequency, env.Name) </span><span class="cov8" title="1">{
                                        quotaCapacityPollFrequency = env.Value
                                }</span> else<span class="cov8" title="1"> if strings.Contains(IsiclientInsecure, env.Name) </span><span class="cov8" title="1">{
                                        clientInsecure = env.Value
                                }</span> else<span class="cov8" title="1"> if strings.Contains(IsiclientAuthType, env.Name) </span><span class="cov8" title="1">{
                                        clientAuthType = env.Value
                                }</span> else<span class="cov8" title="1"> if strings.Contains(IsiclientVerbose, env.Name) </span><span class="cov8" title="1">{
                                        clientVerbose = env.Value
                                }</span> else<span class="cov8" title="1"> if strings.Contains(PowerscaleLogFormat, env.Name) </span><span class="cov8" title="1">{
                                        logFormat = env.Value
                                }</span> else<span class="cov8" title="1"> if strings.Contains(OtelCollectorAddress, env.Name) </span><span class="cov8" title="1">{
                                        otelCollectorAddress = env.Value
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">YamlString = strings.ReplaceAll(YamlString, CSMName, cr.Name)
        YamlString = strings.ReplaceAll(YamlString, CSMNameSpace, cr.Namespace)
        YamlString = strings.ReplaceAll(YamlString, PowerscaleLogLevel, logLevel)
        YamlString = strings.ReplaceAll(YamlString, PowerScaleMaxConcurrentQueries, maxConcurrentQueries)
        YamlString = strings.ReplaceAll(YamlString, PowerscaleCapacityMetricsEnabled, capacityEnabled)
        YamlString = strings.ReplaceAll(YamlString, PowerscalePerformanceMetricsEnabled, performanceEnabled)
        YamlString = strings.ReplaceAll(YamlString, PowerscaleClusterCapacityPollFrequency, clusterCapacityPollFrequency)
        YamlString = strings.ReplaceAll(YamlString, PowerscaleClusterPerformancePollFrequency, clusterPerformancePollFrequency)
        YamlString = strings.ReplaceAll(YamlString, PowerscaleQuotaCapacityPollFrequency, quotaCapacityPollFrequency)
        YamlString = strings.ReplaceAll(YamlString, IsiclientInsecure, clientInsecure)
        YamlString = strings.ReplaceAll(YamlString, IsiclientAuthType, clientAuthType)
        YamlString = strings.ReplaceAll(YamlString, IsiclientVerbose, clientVerbose)
        YamlString = strings.ReplaceAll(YamlString, PowerscaleLogFormat, logFormat)
        YamlString = strings.ReplaceAll(YamlString, OtelCollectorAddress, otelCollectorAddress)
        YamlString = strings.ReplaceAll(YamlString, DriverDefaultReleaseName, cr.Name)

        metricsObjects, err := operatorutils.GetModuleComponentObj([]byte(YamlString))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">operatorutils.SetContainerImage(metricsObjects, "karavi-metrics-powerscale", "karavi-metrics-powerscale", pscaleImage)

        return metricsObjects, nil</span>
}

// parseObservabilityMetricsDeployment - update secret volume and inject authorization to deployment
func parseObservabilityMetricsDeployment(ctx context.Context, deployment *appsv1.Deployment, op operatorutils.OperatorConfig, cr csmv1.ContainerStorageModule) (*confv1.DeploymentApplyConfiguration, error) <span class="cov8" title="1">{
        // parse deployment to DeploymentApplyConfiguration
        dpBuf, err := yaml.Marshal(deployment)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">dpApply := &amp;confv1.DeploymentApplyConfiguration{}
        err = yaml.Unmarshal(dpBuf, dpApply)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Update secret volume
        <span class="cov8" title="1">for i, v := range dpApply.Spec.Template.Spec.Volumes </span><span class="cov8" title="1">{
                if *v.Name == defaultVolumeConfigName[cr.GetDriverType()] &amp;&amp; cr.Spec.Driver.AuthSecret != "" </span><span class="cov8" title="1">{
                        dpApply.Spec.Template.Spec.Volumes[i].Secret.SecretName = &amp;cr.Spec.Driver.AuthSecret
                }</span>
        }

        // inject authorization to deployment
        <span class="cov8" title="1">if authorizationEnabled, _ := operatorutils.IsModuleEnabled(ctx, cr, csmv1.Authorization); authorizationEnabled </span><span class="cov8" title="1">{
                dpApply, err = AuthInjectDeployment(*dpApply, cr, op)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("injecting auth into Observability metrics deployment: %v", err)
                }</span>
        }
        <span class="cov8" title="1">return dpApply, nil</span>
}

// PowerFlexMetrics - delete or update powerflex metrics objects
func PowerFlexMetrics(ctx context.Context, isDeleting bool, op operatorutils.OperatorConfig, cr csmv1.ContainerStorageModule, ctrlClient client.Client, k8sClient kubernetes.Interface) error <span class="cov8" title="1">{
        log := logger.GetLogger(ctx)

        powerflexMetricsObjects, err := getPowerFlexMetricsObject(op, cr)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // update secret volume and inject authorization to deployment
        <span class="cov8" title="1">var dpApply *confv1.DeploymentApplyConfiguration
        foundDp := false
        for i, obj := range powerflexMetricsObjects </span><span class="cov8" title="1">{
                if deployment, ok := obj.(*appsv1.Deployment); ok </span><span class="cov8" title="1">{
                        dpApply, err = parseObservabilityMetricsDeployment(ctx, deployment, op, cr)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">foundDp = true
                        powerflexMetricsObjects[i] = powerflexMetricsObjects[len(powerflexMetricsObjects)-1]
                        powerflexMetricsObjects = powerflexMetricsObjects[:len(powerflexMetricsObjects)-1]
                        break</span>
                }
        }
        <span class="cov8" title="1">if !foundDp </span><span class="cov0" title="0">{
                return fmt.Errorf("could not find deployment obj")
        }</span>

        <span class="cov8" title="1">for _, ctrlObj := range powerflexMetricsObjects </span><span class="cov8" title="1">{
                if isDeleting </span><span class="cov8" title="1">{
                        if err := operatorutils.DeleteObject(ctx, ctrlObj, ctrlClient); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                } else<span class="cov8" title="1"> {
                        if err := operatorutils.ApplyCTRLObject(ctx, ctrlObj, ctrlClient); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        // update Deployment
        <span class="cov8" title="1">if isDeleting </span><span class="cov8" title="1">{
                // Delete Deployment
                deploymentKey := client.ObjectKey{
                        Namespace: *dpApply.Namespace,
                        Name:      *dpApply.Name,
                }
                deploymentObj := &amp;appsv1.Deployment{}
                if err = ctrlClient.Get(ctx, deploymentKey, deploymentObj); err == nil </span><span class="cov8" title="1">{
                        if err = ctrlClient.Delete(ctx, deploymentObj); err != nil &amp;&amp; !k8serrors.IsNotFound(err) </span><span class="cov0" title="0">{
                                return fmt.Errorf("error delete deployment: %v", err)
                        }</span>
                } else<span class="cov8" title="1"> {
                        log.Infow("error getting deployment", "deploymentKey", deploymentKey)
                }</span>
        } else<span class="cov8" title="1"> {
                // Create/Update Deployment
                if err = deployment.SyncDeployment(ctx, *dpApply, k8sClient, cr.Name); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// getPowerFlexMetricsObject - get powerflex metrics yaml string
func getPowerFlexMetricsObject(op operatorutils.OperatorConfig, cr csmv1.ContainerStorageModule) ([]crclient.Object, error) <span class="cov8" title="1">{
        obs, err := getObservabilityModule(cr)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">buf, err := readConfigFile(obs, cr, op, PflexObsYamlFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">YamlString := string(buf)

        otelCollectorAddress := "otel-collector:55680"
        pflexImage := ""
        maxConcurrentQueries := "10"
        sdcEnabled := "true"
        volumeEnabled := "true"
        storagePoolEnabled := "true"
        sdcPollFrequency := "10"
        volumePollFrequency := "10"
        storagePoolPollFrequency := "10"
        logFormat := "TEXT"
        logLevel := "INFO"

        for _, component := range obs.Components </span><span class="cov8" title="1">{
                if component.Name == ObservabilityMetricsPowerFlexName </span><span class="cov8" title="1">{
                        if component.Image != "" </span><span class="cov8" title="1">{
                                pflexImage = string(component.Image)
                        }</span>
                        <span class="cov8" title="1">for _, env := range component.Envs </span><span class="cov8" title="1">{
                                if strings.Contains(PowerflexLogLevel, env.Name) </span><span class="cov8" title="1">{
                                        logLevel = env.Value
                                }</span> else<span class="cov8" title="1"> if strings.Contains(PowerflexMaxConcurrentQueries, env.Name) </span><span class="cov8" title="1">{
                                        maxConcurrentQueries = env.Value
                                }</span> else<span class="cov8" title="1"> if strings.Contains(PowerflexSdcMetricsEnabled, env.Name) </span><span class="cov8" title="1">{
                                        sdcEnabled = env.Value
                                }</span> else<span class="cov8" title="1"> if strings.Contains(PowerflexSdcIoPollFrequency, env.Name) </span><span class="cov8" title="1">{
                                        sdcPollFrequency = env.Value
                                }</span> else<span class="cov8" title="1"> if strings.Contains(PowerflexVolumeMetricsEnabled, env.Name) </span><span class="cov8" title="1">{
                                        volumeEnabled = env.Value
                                }</span> else<span class="cov8" title="1"> if strings.Contains(PowerflexVolumeIoPollFrequency, env.Name) </span><span class="cov8" title="1">{
                                        volumePollFrequency = env.Value
                                }</span> else<span class="cov8" title="1"> if strings.Contains(PowerflexStoragePoolMetricsEnabled, env.Name) </span><span class="cov8" title="1">{
                                        storagePoolEnabled = env.Value
                                }</span> else<span class="cov8" title="1"> if strings.Contains(PowerflexStoragePoolPollFrequency, env.Name) </span><span class="cov8" title="1">{
                                        storagePoolPollFrequency = env.Value
                                }</span> else<span class="cov8" title="1"> if strings.Contains(PowerflexLogFormat, env.Name) </span><span class="cov8" title="1">{
                                        logFormat = env.Value
                                }</span> else<span class="cov8" title="1"> if strings.Contains(OtelCollectorAddress, env.Name) </span><span class="cov8" title="1">{
                                        otelCollectorAddress = env.Value
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">YamlString = strings.ReplaceAll(YamlString, CSMName, cr.Name)
        YamlString = strings.ReplaceAll(YamlString, CSMNameSpace, cr.Namespace)
        YamlString = strings.ReplaceAll(YamlString, PowerflexLogLevel, logLevel)
        YamlString = strings.ReplaceAll(YamlString, PowerflexMaxConcurrentQueries, maxConcurrentQueries)
        YamlString = strings.ReplaceAll(YamlString, PowerflexSdcMetricsEnabled, sdcEnabled)
        YamlString = strings.ReplaceAll(YamlString, PowerflexSdcIoPollFrequency, sdcPollFrequency)
        YamlString = strings.ReplaceAll(YamlString, PowerflexVolumeMetricsEnabled, volumeEnabled)
        YamlString = strings.ReplaceAll(YamlString, PowerflexVolumeIoPollFrequency, volumePollFrequency)
        YamlString = strings.ReplaceAll(YamlString, PowerflexStoragePoolMetricsEnabled, storagePoolEnabled)
        YamlString = strings.ReplaceAll(YamlString, PowerflexStoragePoolPollFrequency, storagePoolPollFrequency)
        YamlString = strings.ReplaceAll(YamlString, PowerflexLogFormat, logFormat)
        YamlString = strings.ReplaceAll(YamlString, OtelCollectorAddress, otelCollectorAddress)
        YamlString = strings.ReplaceAll(YamlString, DriverDefaultReleaseName, cr.Name)

        metricsObjects, err := operatorutils.GetModuleComponentObj([]byte(YamlString))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">operatorutils.SetContainerImage(metricsObjects, "karavi-metrics-powerflex", "karavi-metrics-powerflex", pflexImage)

        return metricsObjects, nil</span>
}

// getObservabilityModule - get instance of observability module
func getObservabilityModule(cr csmv1.ContainerStorageModule) (csmv1.Module, error) <span class="cov8" title="1">{
        for _, m := range cr.Spec.Modules </span><span class="cov8" title="1">{
                if m.Name == csmv1.Observability </span><span class="cov8" title="1">{
                        return m, nil
                }</span>
        }
        <span class="cov8" title="1">return csmv1.Module{}, fmt.Errorf("could not find observability module")</span>
}

// getIssuerCertServiceObs - gets cert manager issuer and certificate manifest for observability
func getIssuerCertServiceObs(op operatorutils.OperatorConfig, obs csmv1.Module, componentName string, cr csmv1.ContainerStorageModule) (string, error) <span class="cov8" title="1">{
        yamlString := ""
        certificate := ""
        privateKey := ""

        for _, component := range obs.Components </span><span class="cov8" title="1">{
                if component.Name == componentName </span><span class="cov8" title="1">{
                        certificate = component.Certificate
                        privateKey = component.PrivateKey
                }</span>
        }

        // If we have at least one of the certificate or privateKey fields filled in, we assume the customer is trying to use a custom cert.
        // Otherwise, we give them the self-signed cert.
        <span class="cov8" title="1">if certificate != "" || privateKey != "" </span><span class="cov8" title="1">{
                if certificate != "" &amp;&amp; privateKey != "" </span><span class="cov8" title="1">{
                        buf, err := readConfigFile(obs, cr, op, CustomCert)
                        if err != nil </span><span class="cov0" title="0">{
                                return yamlString, err
                        }</span>

                        <span class="cov8" title="1">yamlString = string(buf)</span>
                } else<span class="cov8" title="1"> {
                        return yamlString, fmt.Errorf("observability install failed -- either cert or privatekey missing for %s custom cert", componentName)
                }</span>
        } else<span class="cov8" title="1"> {
                buf, err := readConfigFile(obs, cr, op, SelfSignedCert)
                if err != nil </span><span class="cov8" title="1">{
                        return yamlString, err
                }</span>

                <span class="cov8" title="1">yamlString = string(buf)</span>
        }

        <span class="cov8" title="1">yamlString = strings.ReplaceAll(yamlString, ObservabilityCertificate, certificate)
        yamlString = strings.ReplaceAll(yamlString, ObservabilityPrivateKey, privateKey)
        yamlString = strings.ReplaceAll(yamlString, ObservabilitySecretPrefix, ComponentNameToSecretPrefix[componentName])
        yamlString = strings.ReplaceAll(yamlString, CSMNameSpace, cr.Namespace)

        return yamlString, nil</span>
}

// IssuerCertServiceObs - apply and delete the observability issuer and certificate service
func IssuerCertServiceObs(ctx context.Context, isDeleting bool, op operatorutils.OperatorConfig, cr csmv1.ContainerStorageModule, ctrlClient crclient.Client) error <span class="cov8" title="1">{
        obs, err := getObservabilityModule(cr)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">for _, component := range obs.Components </span><span class="cov8" title="1">{
                if (component.Name == ObservabilityOtelCollectorName &amp;&amp; *(component.Enabled)) || (component.Name == ObservabilityTopologyName &amp;&amp; *(component.Enabled)) </span><span class="cov8" title="1">{
                        yamlString, err := getIssuerCertServiceObs(op, obs, component.Name, cr)
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        <span class="cov8" title="1">err = applyDeleteObjects(ctx, ctrlClient, yamlString, isDeleting)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// PowerMaxMetrics - delete or update powermax metrics objects
func PowerMaxMetrics(ctx context.Context, isDeleting bool, op operatorutils.OperatorConfig, cr csmv1.ContainerStorageModule, ctrlClient client.Client, k8sClient kubernetes.Interface) error <span class="cov8" title="1">{
        log := logger.GetLogger(ctx)

        powerMaxMetricsObjects, err := getPowerMaxMetricsObject(op, cr)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // update secret volume and inject authorization to deployment
        <span class="cov8" title="1">var dpApply *confv1.DeploymentApplyConfiguration
        foundDp := false
        for i, obj := range powerMaxMetricsObjects </span><span class="cov8" title="1">{
                if deployment, ok := obj.(*appsv1.Deployment); ok </span><span class="cov8" title="1">{
                        dpApply, err = parseObservabilityMetricsDeployment(ctx, deployment, op, cr)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">foundDp = true
                        powerMaxMetricsObjects[i] = powerMaxMetricsObjects[len(powerMaxMetricsObjects)-1]
                        powerMaxMetricsObjects = powerMaxMetricsObjects[:len(powerMaxMetricsObjects)-1]
                        break</span>
                }
        }
        <span class="cov8" title="1">if !foundDp </span><span class="cov0" title="0">{
                return fmt.Errorf("could not find deployment obj")
        }</span>

        // Dynamic secret/configMap mounting is only supported in v2.14.0 and above
        <span class="cov8" title="1">secretSupported, err := operatorutils.MinVersionCheck(drivers.PowerMaxMountCredentialMinVersion, cr.Spec.Driver.ConfigVersion)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">useSecret := drivers.UseReverseProxySecret(&amp;cr)
        if secretSupported &amp;&amp; useSecret </span><span class="cov8" title="1">{
                // Append config map or mount cred secret.
                // We ensure that we pass through the DeploymentApplyConfiguration.
                _ = drivers.DynamicallyMountPowermaxContent(dpApply, cr)
        }</span>

        <span class="cov8" title="1">if !useSecret </span><span class="cov8" title="1">{
                err := setPowerMaxMetricsConfigMap(dpApply, cr)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">for _, ctrlObj := range powerMaxMetricsObjects </span><span class="cov8" title="1">{
                if isDeleting </span><span class="cov8" title="1">{
                        if err := operatorutils.DeleteObject(ctx, ctrlObj, ctrlClient); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                } else<span class="cov8" title="1"> {
                        if err := operatorutils.ApplyCTRLObject(ctx, ctrlObj, ctrlClient); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        // update Deployment
        <span class="cov8" title="1">if isDeleting </span><span class="cov8" title="1">{
                // Delete Deployment
                deploymentKey := client.ObjectKey{
                        Namespace: *dpApply.Namespace,
                        Name:      *dpApply.Name,
                }
                deploymentObj := &amp;appsv1.Deployment{}
                if err = ctrlClient.Get(ctx, deploymentKey, deploymentObj); err == nil </span><span class="cov8" title="1">{
                        if err = ctrlClient.Delete(ctx, deploymentObj); err != nil &amp;&amp; !k8serrors.IsNotFound(err) </span><span class="cov0" title="0">{
                                return fmt.Errorf("error delete deployment: %v", err)
                        }</span>
                } else<span class="cov8" title="1"> {
                        log.Infow("error getting deployment", "deploymentKey", deploymentKey)
                }</span>
        } else<span class="cov8" title="1"> {
                // Create/Update Deployment
                if err = deployment.SyncDeployment(ctx, *dpApply, k8sClient, cr.Name); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func setPowerMaxMetricsConfigMap(dp *confv1.DeploymentApplyConfiguration, cr csmv1.ContainerStorageModule) error <span class="cov8" title="1">{
        obs, err := getObservabilityModule(cr)
        if err != nil </span><span class="cov8" title="1">{
                // Observability module not found
                return err
        }</span>

        <span class="cov8" title="1">cm := "powermax-reverseproxy-config"
        // Get the config map name from the observability module
        for _, component := range obs.Components </span><span class="cov8" title="1">{
                if component.Name == ObservabilityMetricsPowerMaxName </span><span class="cov8" title="1">{
                        for _, env := range component.Envs </span><span class="cov8" title="1">{
                                if env.Name == "X_CSI_CONFIG_MAP_NAME" </span><span class="cov8" title="1">{
                                        cm = env.Value
                                        break</span>
                                }
                        }
                }
        }

        <span class="cov8" title="1">optional := false
        vol := acorev1.VolumeApplyConfiguration{
                Name: &amp;cm,
                VolumeSourceApplyConfiguration: acorev1.VolumeSourceApplyConfiguration{
                        ConfigMap: &amp;acorev1.ConfigMapVolumeSourceApplyConfiguration{
                                LocalObjectReferenceApplyConfiguration: acorev1.LocalObjectReferenceApplyConfiguration{Name: &amp;cm},
                                Optional:                               &amp;optional,
                        },
                },
        }

        // Dynamically add the volume
        contains := slices.ContainsFunc(dp.Spec.Template.Spec.Volumes,
                func(v acorev1.VolumeApplyConfiguration) bool </span><span class="cov8" title="1">{ return *(v.Name) == *(vol.Name) }</span>,
        )
        <span class="cov8" title="1">if !contains </span><span class="cov8" title="1">{
                dp.Spec.Template.Spec.Volumes = append(dp.Spec.Template.Spec.Volumes, vol)
        }</span>

        <span class="cov8" title="1">mountPath := "/etc/reverseproxy"
        volumeMount := acorev1.VolumeMountApplyConfiguration{Name: &amp;cm, MountPath: &amp;mountPath}
        contains = slices.ContainsFunc(dp.Spec.Template.Spec.Containers[0].VolumeMounts,
                func(v acorev1.VolumeMountApplyConfiguration) bool </span><span class="cov8" title="1">{
                        // Cast to pull out value instead of comparing addresses.
                        return *(v.Name) == *(volumeMount.Name)
                }</span>,
        )

        <span class="cov8" title="1">if !contains </span><span class="cov8" title="1">{
                dp.Spec.Template.Spec.Containers[0].VolumeMounts = append(dp.Spec.Template.Spec.Containers[0].VolumeMounts, volumeMount)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// getPowerMaxMetricsObject - get powermax metrics yaml string
func getPowerMaxMetricsObject(op operatorutils.OperatorConfig, cr csmv1.ContainerStorageModule) ([]crclient.Object, error) <span class="cov8" title="1">{
        obs, err := getObservabilityModule(cr)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">buf, err := readConfigFile(obs, cr, op, PMaxObsYamlFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">YamlString := string(buf)

        otelCollectorAddress := "otel-collector:55680"
        pmaxImage := ""
        maxConcurrentQueries := "10"
        capacityEnabled := "true"
        perfEnabled := "true"
        capacityPollFrequency := "10"
        perfPollFrequency := "10"
        logFormat := "TEXT"
        logLevel := "INFO"
        revproxyConfigMap := "powermax-reverseproxy-config"

        for _, component := range obs.Components </span><span class="cov8" title="1">{
                if component.Name == ObservabilityMetricsPowerMaxName </span><span class="cov8" title="1">{
                        if component.Image != "" </span><span class="cov8" title="1">{
                                pmaxImage = string(component.Image)
                        }</span>
                        <span class="cov8" title="1">for _, env := range component.Envs </span><span class="cov8" title="1">{
                                if strings.Contains(PmaxLogLevel, env.Name) </span><span class="cov8" title="1">{
                                        logLevel = env.Value
                                }</span> else<span class="cov8" title="1"> if strings.Contains(PmaxConcurrentQueries, env.Name) </span><span class="cov8" title="1">{
                                        maxConcurrentQueries = env.Value
                                }</span> else<span class="cov8" title="1"> if strings.Contains(PmaxCapacityMetricsEnabled, env.Name) </span><span class="cov8" title="1">{
                                        capacityEnabled = env.Value
                                }</span> else<span class="cov8" title="1"> if strings.Contains(PmaxCapacityPollFreq, env.Name) </span><span class="cov8" title="1">{
                                        capacityPollFrequency = env.Value
                                }</span> else<span class="cov8" title="1"> if strings.Contains(PmaxPerformanceMetricsEnabled, env.Name) </span><span class="cov8" title="1">{
                                        perfEnabled = env.Value
                                }</span> else<span class="cov8" title="1"> if strings.Contains(PmaxPerformancePollFreq, env.Name) </span><span class="cov8" title="1">{
                                        perfPollFrequency = env.Value
                                }</span> else<span class="cov8" title="1"> if strings.Contains(ReverseProxyConfigMap, env.Name) </span><span class="cov8" title="1">{
                                        revproxyConfigMap = env.Value
                                }</span> else<span class="cov8" title="1"> if strings.Contains(PmaxLogFormat, env.Name) </span><span class="cov8" title="1">{
                                        logFormat = env.Value
                                }</span> else<span class="cov8" title="1"> if strings.Contains(OtelCollectorAddress, env.Name) </span><span class="cov8" title="1">{
                                        otelCollectorAddress = env.Value
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">YamlString = strings.ReplaceAll(YamlString, CSMName, cr.Name)
        YamlString = strings.ReplaceAll(YamlString, CSMNameSpace, cr.Namespace)
        YamlString = strings.ReplaceAll(YamlString, PmaxLogLevel, logLevel)
        YamlString = strings.ReplaceAll(YamlString, PmaxLogFormat, logFormat)
        YamlString = strings.ReplaceAll(YamlString, PmaxConcurrentQueries, maxConcurrentQueries)
        YamlString = strings.ReplaceAll(YamlString, PmaxCapacityMetricsEnabled, capacityEnabled)
        YamlString = strings.ReplaceAll(YamlString, PmaxCapacityPollFreq, capacityPollFrequency)
        YamlString = strings.ReplaceAll(YamlString, PmaxPerformanceMetricsEnabled, perfEnabled)
        YamlString = strings.ReplaceAll(YamlString, PmaxPerformancePollFreq, perfPollFrequency)
        YamlString = strings.ReplaceAll(YamlString, OtelCollectorAddress, otelCollectorAddress)
        YamlString = strings.ReplaceAll(YamlString, ReverseProxyConfigMap, revproxyConfigMap)
        YamlString = strings.ReplaceAll(YamlString, DriverDefaultReleaseName, cr.Name)

        metricsObjects, err := operatorutils.GetModuleComponentObj([]byte(YamlString))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">operatorutils.SetContainerImage(metricsObjects, "karavi-metrics-powermax", "karavi-metrics-powermax", pmaxImage)

        return metricsObjects, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">//  Copyright Â© 2022-2023 Dell Inc. or its subsidiaries. All Rights Reserved.
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//       http://www.apache.org/licenses/LICENSE-2.0
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package modules

import (
        "context"
        "fmt"
        "strings"

        corev1 "k8s.io/api/core/v1"
        k8serrors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        t1 "k8s.io/apimachinery/pkg/types"

        csmv1 "github.com/dell/csm-operator/api/v1"

        "github.com/dell/csm-operator/pkg/drivers"
        "github.com/dell/csm-operator/pkg/logger"
        operatorutils "github.com/dell/csm-operator/pkg/operatorutils"
        rbacv1 "k8s.io/api/rbac/v1"

        applyv1 "k8s.io/client-go/applyconfigurations/apps/v1"
        acorev1 "k8s.io/client-go/applyconfigurations/core/v1"

        appsv1 "k8s.io/api/apps/v1"
        crclient "sigs.k8s.io/controller-runtime/pkg/client"

        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/yaml"
)

const (
        // RepctlBinary - default binary name
        RepctlBinary = "repctl"
        // ReplicationPrefix -
        ReplicationPrefix = "replication.storage.dell.com"
        // ReplicationCrds - YAML with Replication CRDs
        ReplicationCrds = "replicationcrds.all.yaml"
        // DefaultReplicationContextPrefix -
        DefaultReplicationContextPrefix = "&lt;ReplicationContextPrefix&gt;"
        // DefaultReplicationPrefix -
        DefaultReplicationPrefix = "&lt;ReplicationPrefix&gt;"
        // DefaultLogLevel -
        DefaultLogLevel = "&lt;REPLICATION_CTRL_LOG_LEVEL&gt;"
        // DefautlReplicaCount -
        DefautlReplicaCount = "&lt;REPLICATION_CTRL_REPLICAS&gt;"
        // DefaultRetryMin -
        DefaultRetryMin = "&lt;RETRY_INTERVAL_MIN&gt;"
        // DefaultRetryMax -
        DefaultRetryMax = "&lt;RETRY_INTERVAL_MAX&gt;"
        // DefaultReplicaInitImage -
        DefaultReplicaInitImage = "&lt;REPLICATION_INIT_IMAGE&gt;"
        // ReplicationCSMNameSpace - namespace CSM is found in. Needed for cases where pod namespace is not namespace of CSM
        ReplicationCSMNameSpace = "&lt;CSM_NAMESPACE&gt;"
        // DefaultPVCRemapState - default state of Disable PVC remap argument
        DefaultDisablePVCRemapState = "&lt;DISABLE_PVC_REMAP&gt;"
        // AllowPvcCreationOnTarget -
        AllowPvcCreationOnTarget = "&lt;REPLICATION_ALLOW_PVC_CREATION_ON_TARGET&gt;"
)

var (
        // XCSIReplicaCTXPrefix -
        XCSIReplicaCTXPrefix = "X_CSI_REPLICATION_CONTEXT_PREFIX"
        // XCSIReplicaPrefix -
        XCSIReplicaPrefix = "X_CSI_REPLICATION_PREFIX" // #nosec G101
)

// ReplicationSupportedDrivers is a map containing the CSI Drivers supported by CSM Replication. The key is driver name and the value is the driver plugin identifier
var ReplicationSupportedDrivers = map[string]SupportedDriverParam{
        string(csmv1.PowerScaleName): {
                PluginIdentifier:              drivers.PowerScalePluginIdentifier,
                DriverConfigParamsVolumeMount: drivers.PowerScaleConfigParamsVolumeMount,
        },
        string(csmv1.PowerScale): {
                PluginIdentifier:              drivers.PowerScalePluginIdentifier,
                DriverConfigParamsVolumeMount: drivers.PowerScaleConfigParamsVolumeMount,
        },
        string(csmv1.PowerFlex): {
                PluginIdentifier:              drivers.PowerFlexPluginIdentifier,
                DriverConfigParamsVolumeMount: drivers.PowerFlexConfigParamsVolumeMount,
        },
        string(csmv1.PowerFlexName): {
                PluginIdentifier:              drivers.PowerFlexPluginIdentifier,
                DriverConfigParamsVolumeMount: drivers.PowerFlexConfigParamsVolumeMount,
        },
        string(csmv1.PowerMax): {
                PluginIdentifier:              drivers.PowerMaxPluginIdentifier,
                DriverConfigParamsVolumeMount: drivers.PowerMaxConfigParamsVolumeMount,
        },
        string(csmv1.PowerStore): {
                PluginIdentifier:              drivers.PowerStorePluginIdentifier,
                DriverConfigParamsVolumeMount: drivers.PowerStoreConfigParamsVolumeMount,
        },
}

func getRepctlPrefices(replicaModule csmv1.Module, driverType csmv1.DriverType) (string, string) <span class="cov8" title="1">{
        replicationPrefix := ReplicationPrefix
        replicationContextPrefix := ReplicationSupportedDrivers[string(driverType)].PluginIdentifier

        for _, component := range replicaModule.Components </span><span class="cov8" title="1">{
                if component.Name == operatorutils.ReplicationSideCarName </span><span class="cov8" title="1">{
                        for _, env := range component.Envs </span><span class="cov8" title="1">{
                                if env.Name == XCSIReplicaPrefix &amp;&amp; env.Value != "" </span><span class="cov8" title="1">{
                                        replicationPrefix = env.Value
                                }</span> else<span class="cov8" title="1"> if env.Name == XCSIReplicaCTXPrefix &amp;&amp; env.Value != "" </span><span class="cov8" title="1">{
                                        replicationContextPrefix = env.Value
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return replicationContextPrefix, replicationPrefix</span>
}

func getReplicaApplyCR(cr csmv1.ContainerStorageModule, op operatorutils.OperatorConfig) (*csmv1.Module, *acorev1.ContainerApplyConfiguration, error) <span class="cov8" title="1">{
        var err error
        replicaModule := csmv1.Module{}
        for _, m := range cr.Spec.Modules </span><span class="cov8" title="1">{
                if m.Name == csmv1.Replication </span><span class="cov8" title="1">{
                        replicaModule = m
                        break</span>
                }
        }

        <span class="cov8" title="1">buf, err := readConfigFile(replicaModule, cr, op, "container.yaml")
        if err != nil </span><span class="cov8" title="1">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">YamlString := operatorutils.ModifyCommonCR(string(buf), cr)

        replicationContextPrefix, replicationPrefix := getRepctlPrefices(replicaModule, cr.Spec.Driver.CSIDriverType)
        YamlString = strings.ReplaceAll(YamlString, DefaultReplicationPrefix, replicationPrefix)
        YamlString = strings.ReplaceAll(YamlString, DefaultReplicationContextPrefix, replicationContextPrefix)
        YamlString = strings.ReplaceAll(YamlString, DefaultDriverConfigParamsVolumeMount, ReplicationSupportedDrivers[string(cr.Spec.Driver.CSIDriverType)].DriverConfigParamsVolumeMount)
        YamlString = strings.ReplaceAll(YamlString, ReplicationCSMNameSpace, cr.Namespace)

        var container acorev1.ContainerApplyConfiguration
        err = yaml.Unmarshal([]byte(YamlString), &amp;container)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">for _, component := range replicaModule.Components </span><span class="cov8" title="1">{
                if component.Name == operatorutils.ReplicationSideCarName </span><span class="cov8" title="1">{
                        if component.Image != "" </span><span class="cov8" title="1">{
                                image := string(component.Image)
                                container.Image = &amp;image
                        }</span>
                        <span class="cov8" title="1">if component.ImagePullPolicy != "" </span><span class="cov0" title="0">{
                                container.ImagePullPolicy = &amp;component.ImagePullPolicy
                        }</span>
                }
        }

        <span class="cov8" title="1">return &amp;replicaModule, &amp;container, nil</span>
}

// ReplicationInjectDeployment - inject replication into deployment
func ReplicationInjectDeployment(dp applyv1.DeploymentApplyConfiguration, cr csmv1.ContainerStorageModule, op operatorutils.OperatorConfig) (*applyv1.DeploymentApplyConfiguration, error) <span class="cov8" title="1">{
        replicaModule, containerPtr, err := getReplicaApplyCR(cr, op)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">container := *containerPtr
        dp.Spec.Template.Spec.Containers = append(dp.Spec.Template.Spec.Containers, container)

        // inject replication in driver environment

        replicationContextPrefix, replicationPrefix := getRepctlPrefices(*replicaModule, cr.Spec.Driver.CSIDriverType)
        for i, cnt := range dp.Spec.Template.Spec.Containers </span><span class="cov8" title="1">{
                if *cnt.Name == "driver" </span><span class="cov8" title="1">{
                        dp.Spec.Template.Spec.Containers[i].Env = append(dp.Spec.Template.Spec.Containers[i].Env,
                                acorev1.EnvVarApplyConfiguration{Name: &amp;XCSIReplicaCTXPrefix, Value: &amp;replicationContextPrefix},
                                acorev1.EnvVarApplyConfiguration{Name: &amp;XCSIReplicaPrefix, Value: &amp;replicationPrefix},
                        )
                        break</span>
                }
        }
        <span class="cov8" title="1">return &amp;dp, nil</span>
}

// CheckApplyContainersReplica --
func CheckApplyContainersReplica(containers []acorev1.ContainerApplyConfiguration, cr csmv1.ContainerStorageModule) error <span class="cov8" title="1">{
        replicaModule, err := getReplicaModule(cr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">driverString := "driver"
        replicationContextPrefix, replicationPrefix := getRepctlPrefices(replicaModule, cr.Spec.Driver.CSIDriverType)
        for _, cnt := range containers </span><span class="cov8" title="1">{
                if *cnt.Name == operatorutils.ReplicationSideCarName </span><span class="cov8" title="1">{
                        // check volumes
                        volName := ReplicationSupportedDrivers[string(cr.Spec.Driver.CSIDriverType)].DriverConfigParamsVolumeMount
                        foundVol := false
                        for _, vol := range cnt.VolumeMounts </span><span class="cov8" title="1">{
                                if *vol.Name == volName </span><span class="cov8" title="1">{
                                        foundVol = true
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if !foundVol </span><span class="cov0" title="0">{
                                return fmt.Errorf("missing the following volume mount %s", volName)
                        }</span>

                        // check arguments
                        <span class="cov8" title="1">foundReplicationPrefix := false
                        foundReplicationContextPrefix := false
                        for _, arg := range cnt.Args </span><span class="cov8" title="1">{
                                if fmt.Sprintf("--context-prefix=%s", replicationContextPrefix) == arg </span><span class="cov8" title="1">{
                                        foundReplicationContextPrefix = true
                                }</span>
                                <span class="cov8" title="1">if fmt.Sprintf("--prefix=%s", replicationPrefix) == arg </span><span class="cov8" title="1">{
                                        foundReplicationPrefix = true
                                }</span>
                        }
                        <span class="cov8" title="1">if !foundReplicationContextPrefix </span><span class="cov0" title="0">{
                                return fmt.Errorf("missing the following  argument %s", replicationContextPrefix)
                        }</span>
                        <span class="cov8" title="1">if !foundReplicationPrefix </span><span class="cov0" title="0">{
                                return fmt.Errorf("missing the following  argument %s", replicationPrefix)
                        }</span>

                } else<span class="cov8" title="1"> if *cnt.Name == driverString </span><span class="cov8" title="1">{
                        foundReplicationPrefix := false
                        foundReplicationContextPrefix := false
                        for _, env := range cnt.Env </span><span class="cov8" title="1">{
                                if *env.Name == XCSIReplicaPrefix </span><span class="cov8" title="1">{
                                        foundReplicationPrefix = true
                                        if *env.Value != replicationPrefix </span><span class="cov0" title="0">{
                                                return fmt.Errorf("expected %s to have a value of: %s but got: %s", XCSIReplicaPrefix, replicationPrefix, *env.Value)
                                        }</span>
                                }
                                <span class="cov8" title="1">if *env.Name == XCSIReplicaCTXPrefix </span><span class="cov8" title="1">{
                                        foundReplicationContextPrefix = true
                                        if *env.Value != replicationContextPrefix </span><span class="cov0" title="0">{
                                                return fmt.Errorf("expected %s to have a value of: %s but got: %s", XCSIReplicaCTXPrefix, replicationContextPrefix, *env.Value)
                                        }</span>
                                }
                        }
                        <span class="cov8" title="1">if !foundReplicationContextPrefix </span><span class="cov0" title="0">{
                                return fmt.Errorf("missing the following  argument %s", replicationContextPrefix)
                        }</span>
                        <span class="cov8" title="1">if !foundReplicationPrefix </span><span class="cov0" title="0">{
                                return fmt.Errorf("missing the following  argument %s", replicationPrefix)
                        }</span>

                }
        }
        <span class="cov8" title="1">return nil</span>
}

// CheckClusterRoleReplica -
func CheckClusterRoleReplica(rules []rbacv1.PolicyRule) error <span class="cov8" title="1">{
        foundRepilcaGroup := false
        foundReplicaStatus := false
        for _, rule := range rules </span><span class="cov8" title="1">{
                if len(rule.APIGroups) &gt; 0 &amp;&amp; rule.APIGroups[0] == "replication.storage.dell.com" </span><span class="cov8" title="1">{
                        if rule.Resources[0] == "dellcsireplicationgroups" </span><span class="cov8" title="1">{
                                foundRepilcaGroup = true
                        }</span>
                        <span class="cov8" title="1">if rule.Resources[0] == "dellcsireplicationgroups/status" </span><span class="cov8" title="1">{
                                foundReplicaStatus = true
                        }</span>
                }
        }

        <span class="cov8" title="1">if !foundRepilcaGroup </span><span class="cov0" title="0">{
                return fmt.Errorf("missing the resources for %s", "dellcsireplicationgroups")
        }</span>
        <span class="cov8" title="1">if !foundReplicaStatus </span><span class="cov0" title="0">{
                return fmt.Errorf("missing the resources for %s", "dellcsireplicationgroups/status")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ReplicationInjectClusterRole - inject replication into clusterrole
func ReplicationInjectClusterRole(clusterRole rbacv1.ClusterRole, cr csmv1.ContainerStorageModule, op operatorutils.OperatorConfig) (*rbacv1.ClusterRole, error) <span class="cov8" title="1">{
        var err error

        replicaModule, err := getReplicaModule(cr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">buf, err := readConfigFile(replicaModule, cr, op, "rules.yaml")
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var rules []rbacv1.PolicyRule
        err = yaml.Unmarshal(buf, &amp;rules)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">clusterRole.Rules = append(clusterRole.Rules, rules...)
        return &amp;clusterRole, nil</span>
}

// ReplicationPrecheck  - runs precheck for CSM ReplicationPrecheck
func ReplicationPrecheck(ctx context.Context, op operatorutils.OperatorConfig, replica csmv1.Module, cr csmv1.ContainerStorageModule, r operatorutils.ReconcileCSM) error <span class="cov8" title="1">{
        log := logger.GetLogger(ctx)

        if _, ok := ReplicationSupportedDrivers[string(cr.Spec.Driver.CSIDriverType)]; !ok </span><span class="cov8" title="1">{
                return fmt.Errorf("CSM Operator does not suport Replication deployment for %s driver", cr.Spec.Driver.CSIDriverType)
        }</span>

        // check if provided version is supported
        <span class="cov8" title="1">if replica.ConfigVersion != "" </span><span class="cov8" title="1">{
                err := checkVersion(string(csmv1.Replication), replica.ConfigVersion, op.ConfigDirectory)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">clusterClient := operatorutils.GetCluster(ctx, r)

        switch cr.Spec.Driver.CSIDriverType </span>{
        case csmv1.PowerScale:<span class="cov8" title="1">
                tmpCR := cr
                log.Infof("\nperforming pre checks for: %s", clusterClient.ClusterID)
                err := drivers.PrecheckPowerScale(ctx, &amp;tmpCR, op, clusterClient.ClusterCTRLClient)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed powerscale validation: %v for cluster %s", err, clusterClient.ClusterID)
                }</span>
        case csmv1.PowerFlex:<span class="cov8" title="1">
                tmpCR := cr
                log.Infof("\nperforming pre checks for: %s", clusterClient.ClusterID)
                err := drivers.PrecheckPowerFlex(ctx, &amp;tmpCR, op, clusterClient.ClusterCTRLClient)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed powerflex validation: %v for cluster %s", err, clusterClient.ClusterID)
                }</span>
        case csmv1.PowerStore:<span class="cov8" title="1">
                tmpCR := cr
                log.Infof("\nperforming pre checks for: %s", clusterClient.ClusterID)
                err := drivers.PrecheckPowerStore(ctx, &amp;tmpCR, op, clusterClient.ClusterCTRLClient)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed powerstore validation: %v for cluster %s", err, clusterClient.ClusterID)
                }</span>

        }

        <span class="cov8" title="1">return nil</span>
}

func getReplicaController(op operatorutils.OperatorConfig, cr csmv1.ContainerStorageModule) ([]crclient.Object, error) <span class="cov8" title="1">{
        YamlString := ""

        replica, err := getReplicaModule(cr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">buf, err := readConfigFile(replica, cr, op, "controller.yaml")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">YamlString = operatorutils.ModifyCommonCR(string(buf), cr)

        logLevel := "debug"
        replicaCount := "1"
        retryMin := "1s"
        retryMax := "5m"
        replicaImage := ""
        replicaInitImage := ""
        disablePVCRemapState := "false"
        allowPVCCreationOnTarget := "false"

        for _, component := range replica.Components </span><span class="cov8" title="1">{
                if component.Name == operatorutils.ReplicationControllerManager </span><span class="cov8" title="1">{
                        if component.Image != "" </span><span class="cov8" title="1">{
                                replicaImage = string(component.Image)
                        }</span>
                        <span class="cov8" title="1">for _, env := range component.Envs </span><span class="cov8" title="1">{
                                if strings.Contains(DefaultLogLevel, env.Name) &amp;&amp; env.Value != "" </span><span class="cov8" title="1">{
                                        logLevel = env.Value
                                }</span> else<span class="cov8" title="1"> if strings.Contains(DefautlReplicaCount, env.Name) &amp;&amp; env.Value != "" </span><span class="cov8" title="1">{
                                        replicaCount = env.Value
                                }</span> else<span class="cov8" title="1"> if strings.Contains(DefaultRetryMin, env.Name) &amp;&amp; env.Value != "" </span><span class="cov8" title="1">{
                                        retryMin = env.Value
                                }</span> else<span class="cov8" title="1"> if strings.Contains(DefaultRetryMax, env.Name) &amp;&amp; env.Value != "" </span><span class="cov8" title="1">{
                                        retryMax = env.Value
                                }</span> else<span class="cov8" title="1"> if strings.Contains(DefaultDisablePVCRemapState, env.Name) &amp;&amp; env.Value != "" </span><span class="cov8" title="1">{
                                        disablePVCRemapState = env.Value
                                }</span> else<span class="cov8" title="1"> if strings.Contains(AllowPvcCreationOnTarget, env.Name) &amp;&amp; env.Value != "" </span><span class="cov8" title="1">{
                                        allowPVCCreationOnTarget = env.Value
                                }</span>
                        }
                } else<span class="cov8" title="1"> if component.Name == operatorutils.ReplicationControllerInit </span><span class="cov0" title="0">{
                        if component.Image != "" </span><span class="cov0" title="0">{
                                replicaInitImage = string(component.Image)
                        }</span>
                }
        }

        <span class="cov8" title="1">YamlString = strings.ReplaceAll(YamlString, DefaultLogLevel, logLevel)
        YamlString = strings.ReplaceAll(YamlString, DefautlReplicaCount, replicaCount)
        YamlString = strings.ReplaceAll(YamlString, DefaultReplicaInitImage, replicaInitImage)
        YamlString = strings.ReplaceAll(YamlString, DefaultRetryMax, retryMax)
        YamlString = strings.ReplaceAll(YamlString, DefaultRetryMin, retryMin)
        YamlString = strings.ReplaceAll(YamlString, ReplicationCSMNameSpace, cr.Namespace)
        YamlString = strings.ReplaceAll(YamlString, DefaultDisablePVCRemapState, disablePVCRemapState)
        YamlString = strings.ReplaceAll(YamlString, AllowPvcCreationOnTarget, allowPVCCreationOnTarget)

        ctrlObjects, err := operatorutils.GetModuleComponentObj([]byte(YamlString))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // loop ctrlObjects to find the deployment and set the image
        <span class="cov8" title="1">if len(replicaImage) != 0 </span><span class="cov8" title="1">{
                for _, ctrlObj := range ctrlObjects </span><span class="cov8" title="1">{
                        if deployment, ok := ctrlObj.(*appsv1.Deployment); ok </span><span class="cov8" title="1">{
                                deployment.Spec.Template.Spec.Containers[0].Image = replicaImage
                        }</span>
                }
        }
        <span class="cov8" title="1">return ctrlObjects, nil</span>
}

func getReplicaModule(cr csmv1.ContainerStorageModule) (csmv1.Module, error) <span class="cov8" title="1">{
        for _, m := range cr.Spec.Modules </span><span class="cov8" title="1">{
                if m.Name == csmv1.Replication </span><span class="cov8" title="1">{
                        return m, nil
                }</span>
        }
        <span class="cov8" title="1">return csmv1.Module{}, fmt.Errorf("could not find replica module")</span>
}

// ReplicationManagerController -
func ReplicationManagerController(ctx context.Context, isDeleting bool, op operatorutils.OperatorConfig, cr csmv1.ContainerStorageModule, ctrlClient client.Client) error <span class="cov8" title="1">{
        ctrlObjects, err := getReplicaController(op, cr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for _, ctrlObj := range ctrlObjects </span><span class="cov8" title="1">{
                if isDeleting </span><span class="cov8" title="1">{
                        if err := operatorutils.DeleteObject(ctx, ctrlObj, ctrlClient); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                } else<span class="cov8" title="1"> {
                        if err := operatorutils.ApplyObject(ctx, ctrlObj, ctrlClient); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

func CreateReplicationConfigmap(ctx context.Context, cr csmv1.ContainerStorageModule, op operatorutils.OperatorConfig, ctrlClient client.Client) ([]crclient.Object, error) <span class="cov8" title="1">{
        replica, err := getReplicaModule(cr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">buf, err := readConfigFile(replica, cr, op, "dell-replication-controller-config.yaml")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var cm corev1.ConfigMap
        if err := yaml.Unmarshal(buf, &amp;cm); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Check if the ConfigMap already exists
        <span class="cov8" title="1">foundConfigMap := &amp;corev1.ConfigMap{}

        err = ctrlClient.Get(ctx, t1.NamespacedName{Name: cm.Name, Namespace: cm.Namespace}, foundConfigMap)
        if err != nil &amp;&amp; k8serrors.IsNotFound(err) </span><span class="cov8" title="1">{
                // ConfigMap doesn't exist, create it
                if err := ctrlClient.Create(ctx, &amp;cm); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">return []crclient.Object{&amp;cm}, nil</span>
}

func DeleteReplicationConfigmap(ctrlClient client.Client) error <span class="cov8" title="1">{
        configMap := &amp;corev1.ConfigMap{
                ObjectMeta: metav1.ObjectMeta{
                        Name:      "dell-replication-controller-config",
                        Namespace: "dell-replication-controller",
                },
        }

        if err := ctrlClient.Delete(context.Background(), configMap); err != nil </span><span class="cov0" title="0">{
                if k8serrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func getReplicationCrdDeploy(op operatorutils.OperatorConfig, cr csmv1.ContainerStorageModule) (string, error) <span class="cov8" title="1">{
        yamlString := ""

        repl, err := getReplicaModule(cr)
        if err != nil </span><span class="cov8" title="1">{
                return yamlString, err
        }</span>

        <span class="cov8" title="1">buf, err := readConfigFile(repl, cr, op, ReplicationCrds)
        if err != nil </span><span class="cov8" title="1">{
                return yamlString, err
        }</span>

        <span class="cov8" title="1">yamlString = string(buf)
        return yamlString, nil</span>
}

func ReplicationCrdDeploy(ctx context.Context, op operatorutils.OperatorConfig, cr csmv1.ContainerStorageModule, ctrlClient crclient.Client) error <span class="cov8" title="1">{
        yamlString, err := getReplicationCrdDeploy(op, cr)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return applyDeleteObjects(ctx, ctrlClient, yamlString, false)</span>
}

func DeleteReplicationCrds(ctx context.Context, op operatorutils.OperatorConfig, cr csmv1.ContainerStorageModule, ctrlClient crclient.Client) error <span class="cov8" title="1">{
        yamlString, err := getReplicationCrdDeploy(op, cr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return applyDeleteObjects(ctx, ctrlClient, yamlString, true)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">//  Copyright Â© 2023 Dell Inc. or its subsidiaries. All Rights Reserved.
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//       http://www.apache.org/licenses/LICENSE-2.0
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package modules

import (
        "context"
        "fmt"
        "strings"

        csmv1 "github.com/dell/csm-operator/api/v1"
        drivers "github.com/dell/csm-operator/pkg/drivers"
        "github.com/dell/csm-operator/pkg/logger"
        operatorutils "github.com/dell/csm-operator/pkg/operatorutils"
        corev1 "k8s.io/api/core/v1"
        rbacv1 "k8s.io/api/rbac/v1"
        applyv1 "k8s.io/client-go/applyconfigurations/apps/v1"
        acorev1 "k8s.io/client-go/applyconfigurations/core/v1"
        "sigs.k8s.io/yaml"
)

var (
        // XCSIPodmonArrayConnectivityPollRate -
        XCSIPodmonArrayConnectivityPollRate = "X_CSI_PODMON_ARRAY_CONNECTIVITY_POLL_RATE"
        // XCSIPodmonAPIPort -
        XCSIPodmonAPIPort = "X_CSI_PODMON_API_PORT"
        // XCSIPodmonEnabled -
        XCSIPodmonEnabled = "X_CSI_PODMON_ENABLED"
)

const (
        controllerMode = "controller"
        nodeMode       = "node"
)

// ResiliencySupportedDrivers is a map containing the CSI Drivers supported by CSM Resiliency. The key is driver name and the value is the driver plugin identifier
var ResiliencySupportedDrivers = map[string]SupportedDriverParam{
        string(csmv1.PowerStore): {
                PluginIdentifier:              drivers.PowerStorePluginIdentifier,
                DriverConfigParamsVolumeMount: drivers.PowerStoreConfigParamsVolumeMount,
        },
        string(csmv1.PowerScaleName): {
                PluginIdentifier:              drivers.PowerScalePluginIdentifier,
                DriverConfigParamsVolumeMount: drivers.PowerScaleConfigParamsVolumeMount,
        },
        string(csmv1.PowerScale): {
                PluginIdentifier:              drivers.PowerScalePluginIdentifier,
                DriverConfigParamsVolumeMount: drivers.PowerScaleConfigParamsVolumeMount,
        },
        string(csmv1.PowerFlex): {
                PluginIdentifier:              drivers.PowerFlexPluginIdentifier,
                DriverConfigParamsVolumeMount: drivers.PowerFlexConfigParamsVolumeMount,
        },
        string(csmv1.PowerFlexName): {
                PluginIdentifier:              drivers.PowerFlexPluginIdentifier,
                DriverConfigParamsVolumeMount: drivers.PowerFlexConfigParamsVolumeMount,
        },
        string(csmv1.PowerMax): {
                PluginIdentifier:              drivers.PowerMaxPluginIdentifier,
                DriverConfigParamsVolumeMount: drivers.PowerMaxConfigParamsVolumeMount,
        },
}

// ResiliencyPrecheck - Resiliency module precheck for supported versions
func ResiliencyPrecheck(ctx context.Context, op operatorutils.OperatorConfig, resiliency csmv1.Module, cr csmv1.ContainerStorageModule, _ operatorutils.ReconcileCSM) error <span class="cov8" title="1">{
        log := logger.GetLogger(ctx)

        if _, ok := ResiliencySupportedDrivers[string(cr.Spec.Driver.CSIDriverType)]; !ok </span><span class="cov8" title="1">{
                log.Errorf("CSM Operator does not suport Resiliency deployment for %s driver", cr.Spec.Driver.CSIDriverType)
                return fmt.Errorf("CSM Operator does not suport Resiliency deployment for %s driver", cr.Spec.Driver.CSIDriverType)
        }</span>

        // check if provided version is supported
        <span class="cov8" title="1">if resiliency.ConfigVersion != "" </span><span class="cov8" title="1">{
                err := checkVersion(string(csmv1.Resiliency), resiliency.ConfigVersion, op.ConfigDirectory)
                if err != nil </span><span class="cov8" title="1">{
                        log.Errorf("CSM Operator does not suport Resiliency deployment for this version combination %v", err)
                        return err
                }</span>
        }

        <span class="cov8" title="1">log.Infof("\nperformed pre checks for: %s", resiliency.Name)
        return nil</span>
}

// ResiliencyInjectClusterRole - inject resiliency into clusterrole
func ResiliencyInjectClusterRole(clusterRole rbacv1.ClusterRole, cr csmv1.ContainerStorageModule, op operatorutils.OperatorConfig, mode string) (*rbacv1.ClusterRole, error) <span class="cov8" title="1">{
        var err error
        roleFileName := mode + "-clusterroles.yaml"
        resiliencyModule, err := getResiliencyModule(cr)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        // roleFiles are under moduleConfig for node &amp; controller mode
        <span class="cov8" title="1">buf, err := readConfigFile(resiliencyModule, cr, op, roleFileName)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var rules []rbacv1.PolicyRule
        err = yaml.Unmarshal(buf, &amp;rules)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">clusterRole.Rules = append(clusterRole.Rules, rules...)
        return &amp;clusterRole, nil</span>
}

// ResiliencyInjectRole - inject resiliency into role
func ResiliencyInjectRole(role rbacv1.Role, cr csmv1.ContainerStorageModule, op operatorutils.OperatorConfig, mode string) (*rbacv1.Role, error) <span class="cov8" title="1">{
        // There are no roles for controller in Resliency
        if mode == "controller" </span><span class="cov8" title="1">{
                return &amp;role, nil
        }</span>

        <span class="cov8" title="1">var err error
        roleFileName := mode + "-roles.yaml"
        resiliencyModule, err := getResiliencyModule(cr)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">resiliencyVersion := resiliencyModule.ConfigVersion
        if resiliencyVersion == "" </span><span class="cov0" title="0">{
                resiliencyVersion, err = operatorutils.GetModuleDefaultVersion(cr.Spec.Driver.ConfigVersion, cr.Spec.Driver.CSIDriverType, resiliencyModule.Name, op.ConfigDirectory)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">isOldResiliencyVersion, err := operatorutils.MinVersionCheck(resiliencyVersion, "v1.12.0")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if isOldResiliencyVersion </span><span class="cov0" title="0">{
                return &amp;role, nil
        }</span>
        // roleFiles are under moduleConfig for node &amp; controller mode
        <span class="cov8" title="1">buf, err := readConfigFile(resiliencyModule, cr, op, roleFileName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var rules []rbacv1.PolicyRule
        err = yaml.Unmarshal(buf, &amp;rules)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">role.Rules = append(role.Rules, rules...)
        return &amp;role, nil</span>
}

func getResiliencyModule(cr csmv1.ContainerStorageModule) (csmv1.Module, error) <span class="cov8" title="1">{
        for _, m := range cr.Spec.Modules </span><span class="cov8" title="1">{
                if m.Name == csmv1.Resiliency </span><span class="cov8" title="1">{
                        return m, nil
                }</span>
        }
        <span class="cov8" title="1">return csmv1.Module{}, fmt.Errorf("could not find resiliency module")</span>
}

func getResiliencyEnv(resiliencyModule csmv1.Module, _ csmv1.DriverType) string <span class="cov8" title="1">{
        for _, component := range resiliencyModule.Components </span><span class="cov8" title="1">{
                if component.Name == operatorutils.PodmonNodeComponent </span><span class="cov8" title="1">{
                        for _, env := range component.Envs </span><span class="cov8" title="1">{
                                if env.Name == XCSIPodmonAPIPort </span><span class="cov8" title="1">{
                                        return env.Value
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return ""</span>
}

// Apply resiliency module from the manifest file to the podmon sidecar
func modifyPodmon(component csmv1.ContainerTemplate, container *acorev1.ContainerApplyConfiguration) <span class="cov8" title="1">{
        if component.Image != "" </span><span class="cov8" title="1">{
                image := string(component.Image)
                if container.Image != nil </span><span class="cov8" title="1">{
                        *container.Image = image
                }</span>
                <span class="cov8" title="1">container.Image = &amp;image</span>
        }
        <span class="cov8" title="1">if component.ImagePullPolicy != "" </span><span class="cov8" title="1">{
                if container.ImagePullPolicy != nil </span><span class="cov8" title="1">{
                        *container.ImagePullPolicy = component.ImagePullPolicy
                }</span>
                <span class="cov8" title="1">container.ImagePullPolicy = &amp;component.ImagePullPolicy</span>
        }
        <span class="cov8" title="1">emptyEnv := make([]corev1.EnvVar, 0)
        container.Env = operatorutils.ReplaceAllApplyCustomEnvs(container.Env, emptyEnv, component.Envs)
        container.Args = operatorutils.ReplaceAllArgs(container.Args, component.Args)</span>
}

func setResiliencyArgs(m csmv1.Module, mode string, container *acorev1.ContainerApplyConfiguration) <span class="cov8" title="1">{
        for _, component := range m.Components </span><span class="cov8" title="1">{
                if component.Name == operatorutils.PodmonControllerComponent &amp;&amp; mode == controllerMode </span><span class="cov8" title="1">{
                        modifyPodmon(component, container)
                }</span>
                <span class="cov8" title="1">if component.Name == operatorutils.PodmonNodeComponent &amp;&amp; mode == "node" </span><span class="cov8" title="1">{
                        modifyPodmon(component, container)
                }</span>
        }
}

func getPollRateFromArgs(args []string) string <span class="cov8" title="1">{
        for _, arg := range args </span><span class="cov8" title="1">{
                if strings.Contains(arg, "arrayConnectivityPollRate") </span><span class="cov8" title="1">{
                        sub := strings.Split(arg, "=")
                        if len(sub) == 2 </span><span class="cov8" title="1">{
                                return strings.Split(arg, "=")[1]
                        }</span>
                }
        }
        <span class="cov0" title="0">return ""</span>
}

func getResiliencyApplyCR(cr csmv1.ContainerStorageModule, op operatorutils.OperatorConfig, driverType, mode string) (*csmv1.Module, *acorev1.ContainerApplyConfiguration, error) <span class="cov8" title="1">{
        resiliencyModule := csmv1.Module{}
        for _, m := range cr.Spec.Modules </span><span class="cov8" title="1">{
                if m.Name == csmv1.Resiliency </span><span class="cov8" title="1">{
                        resiliencyModule = m
                        break</span>
                }
        }
        <span class="cov8" title="1">if driverType == string(csmv1.PowerScale) </span><span class="cov8" title="1">{
                driverType = string(csmv1.PowerScaleName)
        }</span>
        <span class="cov8" title="1">if driverType == string(csmv1.PowerFlexName) </span><span class="cov8" title="1">{
                driverType = string(csmv1.PowerFlex)
        }</span>
        <span class="cov8" title="1">fileToRead := "container-" + driverType + "-" + mode + ".yaml"
        buf, err := readConfigFile(resiliencyModule, cr, op, fileToRead)
        if err != nil </span><span class="cov8" title="1">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">YamlString := operatorutils.ModifyCommonCR(string(buf), cr)

        var container acorev1.ContainerApplyConfiguration
        err = yaml.Unmarshal([]byte(YamlString), &amp;container)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        // read args from the respective components
        <span class="cov8" title="1">setResiliencyArgs(resiliencyModule, mode, &amp;container)
        return &amp;resiliencyModule, &amp;container, nil</span>
}

// ResiliencyInjectDeployment - inject resiliency into deployment
func ResiliencyInjectDeployment(dp applyv1.DeploymentApplyConfiguration, cr csmv1.ContainerStorageModule, op operatorutils.OperatorConfig, driverType string) (*applyv1.DeploymentApplyConfiguration, error) <span class="cov8" title="1">{
        resiliencyModule, podmonPtr, err := getResiliencyApplyCR(cr, op, driverType, controllerMode)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">podmon := *podmonPtr
        // prepend podmon container in controller-pod
        dp.Spec.Template.Spec.Containers = append([]acorev1.ContainerApplyConfiguration{podmon}, dp.Spec.Template.Spec.Containers...)

        if driverType == string(csmv1.PowerScale) </span><span class="cov8" title="1">{
                driverType = string(csmv1.PowerScaleName)
        }</span>
        // we need to set these ENV for PowerStore, PowerMax &amp; PowerScale only
        <span class="cov8" title="1">if driverType == string(csmv1.PowerScaleName) || driverType == string(csmv1.PowerStore) || driverType == string(csmv1.PowerMax) </span><span class="cov8" title="1">{
                for i, cnt := range dp.Spec.Template.Spec.Containers </span><span class="cov8" title="1">{
                        if *cnt.Name == "driver" </span><span class="cov8" title="1">{
                                podmonAPIPort := getResiliencyEnv(*resiliencyModule, cr.Spec.Driver.CSIDriverType)
                                podmonArrayConnectivityPollRate := getPollRateFromArgs(podmon.Args)
                                enabled := "true"
                                dp.Spec.Template.Spec.Containers[i].Env = append(dp.Spec.Template.Spec.Containers[i].Env,
                                        acorev1.EnvVarApplyConfiguration{Name: &amp;XCSIPodmonEnabled, Value: &amp;enabled},
                                )
                                if podmonArrayConnectivityPollRate != "" </span><span class="cov8" title="1">{
                                        dp.Spec.Template.Spec.Containers[i].Env = append(dp.Spec.Template.Spec.Containers[i].Env,
                                                acorev1.EnvVarApplyConfiguration{Name: &amp;XCSIPodmonArrayConnectivityPollRate, Value: &amp;podmonArrayConnectivityPollRate},
                                        )
                                }</span>
                                <span class="cov8" title="1">if podmonAPIPort != "" </span><span class="cov8" title="1">{
                                        dp.Spec.Template.Spec.Containers[i].Env = append(dp.Spec.Template.Spec.Containers[i].Env,
                                                acorev1.EnvVarApplyConfiguration{Name: &amp;XCSIPodmonAPIPort, Value: &amp;podmonAPIPort},
                                        )
                                }</span>
                                <span class="cov8" title="1">break</span>
                        }
                }
        }
        <span class="cov8" title="1">return &amp;dp, nil</span>
}

// ResiliencyInjectDaemonset  - inject resiliency into daemonset
func ResiliencyInjectDaemonset(ds applyv1.DaemonSetApplyConfiguration, cr csmv1.ContainerStorageModule, op operatorutils.OperatorConfig, driverType string) (*applyv1.DaemonSetApplyConfiguration, error) <span class="cov8" title="1">{
        resiliencyModule, podmonPtr, err := getResiliencyApplyCR(cr, op, driverType, nodeMode)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">podmon := *podmonPtr
        // prepend podmon container in node-pod
        ds.Spec.Template.Spec.Containers = append([]acorev1.ContainerApplyConfiguration{podmon}, ds.Spec.Template.Spec.Containers...)

        podmonAPIPort := getResiliencyEnv(*resiliencyModule, cr.Spec.Driver.CSIDriverType)
        enabled := "true"
        podmonArrayConnectivityPollRate := getPollRateFromArgs(podmon.Args)
        for i, cnt := range ds.Spec.Template.Spec.Containers </span><span class="cov8" title="1">{
                if *cnt.Name == "driver" </span><span class="cov8" title="1">{
                        ds.Spec.Template.Spec.Containers[i].Env = append(ds.Spec.Template.Spec.Containers[i].Env,
                                acorev1.EnvVarApplyConfiguration{Name: &amp;XCSIPodmonArrayConnectivityPollRate, Value: &amp;podmonArrayConnectivityPollRate},
                                acorev1.EnvVarApplyConfiguration{Name: &amp;XCSIPodmonAPIPort, Value: &amp;podmonAPIPort},
                                acorev1.EnvVarApplyConfiguration{Name: &amp;XCSIPodmonEnabled, Value: &amp;enabled},
                        )
                        break</span>
                }
        }

        <span class="cov8" title="1">return &amp;ds, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">//  Copyright Â© 2023-2025 Dell Inc. or its subsidiaries. All Rights Reserved.
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//       http://www.apache.org/licenses/LICENSE-2.0
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package modules

import (
        "context"
        "fmt"
        "os"
        "path/filepath"
        "slices"
        "strconv"
        "strings"

        operatorutils "github.com/dell/csm-operator/pkg/operatorutils"
        appsv1 "k8s.io/api/apps/v1"
        corev1 "k8s.io/api/core/v1"
        k8serrors "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/types"
        v1 "k8s.io/client-go/applyconfigurations/apps/v1"
        acorev1 "k8s.io/client-go/applyconfigurations/core/v1"

        crclient "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/yaml"

        csmv1 "github.com/dell/csm-operator/api/v1"
        "github.com/dell/csm-operator/pkg/drivers"
        "github.com/dell/csm-operator/pkg/logger"
)

// Constants to be used in reverse proxy config files
const (
        ReverseProxyServerComponent = "csipowermax-reverseproxy" // #nosec G101
        ReverseProxyDeployment      = "controller.yaml"
        ReverseProxySidecar         = "container.yaml"
        ReverseProxyService         = "service.yaml"
        ReverseProxyImage           = "&lt;REVERSEPROXY_PROXY_SERVER_IMAGE&gt;"
        ReverseProxyTLSSecret       = "&lt;X_CSI_REVPROXY_TLS_SECRET&gt;" // #nosec G101
        ReverseProxyConfigMap       = "&lt;X_CSI_CONFIG_MAP_NAME&gt;"
        ReverseProxyPort            = "&lt;X_CSI_REVPROXY_PORT&gt;"
        ReverseProxyCSMNameSpace    = "&lt;CSM_NAMESPACE&gt;"
)

// var used in deploying reverseproxy
var (
        deployAsSidecar              = true
        CSIPmaxRevProxyServiceName   = "X_CSI_POWERMAX_PROXY_SERVICE_NAME"
        CSIPmaxRevProxyPort          = "X_CSI_POWERMAX_SIDECAR_PROXY_PORT"
        RevProxyDefaultPort          = "2222"
        RevProxyServiceName          = "csipowermax-reverseproxy"
        RevProxyConfigMapVolName     = "configmap-volume"
        RevProxyConfigMapDeafultName = "powermax-reverseproxy-config"
        RevProxyTLSSecretVolName     = "tls-secret"
        RevProxyTLSSecretDefaultName = "csirevproxy-tls-secret" // #nosec G101
        RevProxyConfigMapMountPath   = "/etc/config/configmap"
)

// ReverseproxySupportedDrivers is a map containing the CSI Drivers supported by CSM Reverseproxy. The key is driver name and the value is the driver plugin identifier
var ReverseproxySupportedDrivers = map[string]SupportedDriverParam{
        string(csmv1.PowerMax): {
                PluginIdentifier:              drivers.PowerMaxPluginIdentifier,
                DriverConfigParamsVolumeMount: drivers.PowerMaxConfigParamsVolumeMount,
        },
}

// ReverseProxyPrecheck  - runs precheck for CSM ReverseProxy
func ReverseProxyPrecheck(ctx context.Context, op operatorutils.OperatorConfig, revproxy csmv1.Module, cr csmv1.ContainerStorageModule, r operatorutils.ReconcileCSM) error <span class="cov8" title="1">{
        log := logger.GetLogger(ctx)

        if _, ok := ReverseproxySupportedDrivers[string(cr.Spec.Driver.CSIDriverType)]; !ok </span><span class="cov8" title="1">{
                return fmt.Errorf("CSM Reverseproxy does not support %s driver", string(cr.Spec.Driver.CSIDriverType))
        }</span>

        // check if provided version is supported
        <span class="cov8" title="1">if revproxy.ConfigVersion != "" </span><span class="cov8" title="1">{
                err := checkVersion(string(csmv1.ReverseProxy), revproxy.ConfigVersion, op.ConfigDirectory)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        // Check for secrets
        <span class="cov8" title="1">proxyServerSecret := "csirevproxy-tls-secret" // #nosec G101
        proxyConfigMap := "powermax-reverseproxy-config"
        if revproxy.Components != nil </span><span class="cov8" title="1">{
                for _, env := range revproxy.Components[0].Envs </span><span class="cov8" title="1">{
                        if env.Name == "X_CSI_REVPROXY_TLS_SECRET" </span><span class="cov8" title="1">{
                                proxyServerSecret = env.Value
                        }</span>
                        <span class="cov8" title="1">if env.Name == "X_CSI_CONFIG_MAP_NAME" </span><span class="cov8" title="1">{
                                proxyConfigMap = env.Value
                        }</span>
                        <span class="cov8" title="1">if env.Name == "DeployAsSidecar" </span><span class="cov8" title="1">{
                                das, err := strconv.ParseBool(env.Value)
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Warnf("Error parsing %s, %s. Deploying reverseproxy as sidecar.", env.Name, err.Error())
                                        das = true
                                }</span>

                                <span class="cov8" title="1">deployAsSidecar = das</span>
                        }
                }
        }

        <span class="cov8" title="1">err := r.GetClient().Get(ctx, types.NamespacedName{Name: proxyServerSecret, Namespace: cr.GetNamespace()}, &amp;corev1.Secret{})
        if err != nil </span><span class="cov8" title="1">{
                if k8serrors.IsNotFound(err) </span><span class="cov8" title="1">{
                        return fmt.Errorf("failed to find secret %s", proxyServerSecret)
                }</span>
        }

        <span class="cov8" title="1">if !drivers.UseReverseProxySecret(&amp;cr) </span><span class="cov8" title="1">{
                log.Infof("[ReverseProxyPrecheck] using configmap %s", proxyConfigMap)
                err = r.GetClient().Get(ctx, types.NamespacedName{Name: proxyConfigMap, Namespace: cr.GetNamespace()}, &amp;corev1.ConfigMap{})
                if err != nil </span><span class="cov8" title="1">{
                        if k8serrors.IsNotFound(err) </span><span class="cov8" title="1">{
                                return fmt.Errorf("failed to find configmap %s", proxyConfigMap)
                        }</span>
                }
        }
        <span class="cov8" title="1">log.Infof("\nperformed pre checks for: %s", revproxy.Name)
        return nil</span>
}

// ReverseProxyServer - apply/delete deployment objects
func ReverseProxyServer(ctx context.Context, isDeleting bool, op operatorutils.OperatorConfig, cr csmv1.ContainerStorageModule, ctrlClient crclient.Client) error <span class="cov8" title="1">{
        log := logger.GetLogger(ctx)
        YamlString, err := getReverseProxyDeployment(op, cr)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">deployObjects, err := operatorutils.GetModuleComponentObj([]byte(YamlString))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for _, ctrlObj := range deployObjects </span><span class="cov8" title="1">{
                log.Infof("Object: %v -----\n", ctrlObj)
                if ctrlObj.GetName() == RevProxyServiceName &amp;&amp; ctrlObj.GetObjectKind().GroupVersionKind().Kind == "Deployment" </span><span class="cov8" title="1">{
                        dp := ctrlObj.(*appsv1.Deployment)

                        // Mount Credential support is only introduced in CSM v2.14.0. Prior to this version, we will not try to dynamically
                        // add the necessary fields for either approach.
                        secretSupported, err := operatorutils.MinVersionCheck(drivers.PowerMaxMountCredentialMinVersion, cr.Spec.Driver.ConfigVersion)
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>

                        <span class="cov8" title="1">if secretSupported </span><span class="cov8" title="1">{
                                if drivers.UseReverseProxySecret(&amp;cr) </span><span class="cov8" title="1">{
                                        secretName := cr.Spec.Driver.AuthSecret
                                        deploymentSetReverseProxySecretMounts(dp, secretName)
                                }</span> else<span class="cov8" title="1"> {
                                        revProxyModule, _, err := getRevproxyApplyCR(cr, op)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>

                                        <span class="cov8" title="1">cm := getRevProxyEnvVariable(*revProxyModule, "X_CSI_CONFIG_MAP_NAME")
                                        deploymentSetReverseProxyConfigMapMounts(dp, cm)</span>
                                }
                        }
                }
                <span class="cov8" title="1">if isDeleting </span><span class="cov8" title="1">{
                        if err := operatorutils.DeleteObject(ctx, ctrlObj, ctrlClient); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                } else<span class="cov8" title="1"> {
                        if err := operatorutils.ApplyObject(ctx, ctrlObj, ctrlClient); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov8" title="1">log.Info("Create/Update reverseproxy successful...")
        return nil</span>
}

// ReverseProxyStartService starts reverseproxy service for node to connect to revserseproxy sidecar
func ReverseProxyStartService(ctx context.Context, isDeleting bool, op operatorutils.OperatorConfig, cr csmv1.ContainerStorageModule, ctrlClient crclient.Client) error <span class="cov8" title="1">{
        log := logger.GetLogger(ctx)

        YamlString, err := getReverseProxyService(op, cr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">deployObjects, err := operatorutils.GetModuleComponentObj([]byte(YamlString))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for _, ctrlObj := range deployObjects </span><span class="cov8" title="1">{
                log.Infof("Object: %v -----\n", ctrlObj)
                if isDeleting </span><span class="cov8" title="1">{
                        if err := operatorutils.DeleteObject(ctx, ctrlObj, ctrlClient); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                } else<span class="cov8" title="1"> {
                        if err := operatorutils.ApplyObject(ctx, ctrlObj, ctrlClient); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov8" title="1">log.Info("Create/Update reverseproxy serivce successful...")
        return nil</span>
}

func getReverseProxyModule(cr csmv1.ContainerStorageModule) (csmv1.Module, error) <span class="cov8" title="1">{
        for _, m := range cr.Spec.Modules </span><span class="cov8" title="1">{
                if m.Name == csmv1.ReverseProxy </span><span class="cov8" title="1">{
                        return m, nil
                }</span>
        }
        <span class="cov8" title="1">return csmv1.Module{}, fmt.Errorf("reverseproxy module not found")</span>
}

// getReverseProxyService - gets the reverseproxy service manifest
func getReverseProxyService(op operatorutils.OperatorConfig, cr csmv1.ContainerStorageModule) (string, error) <span class="cov8" title="1">{
        yamlString := ""
        revProxy := cr.GetModule(csmv1.ReverseProxy)
        // This is necessary for the minimal manifest, where the reverse proxy will not be included in the CSM CR.
        if len(revProxy.Name) == 0 </span><span class="cov0" title="0">{
                revProxy.Name = csmv1.ReverseProxy
        }</span>

        <span class="cov8" title="1">buf, err := readConfigFile(revProxy, cr, op, ReverseProxyService)
        if err != nil </span><span class="cov0" title="0">{
                return yamlString, err
        }</span>

        <span class="cov8" title="1">yamlString = string(buf)
        proxyPort := "2222"
        for _, component := range revProxy.Components </span><span class="cov8" title="1">{
                if component.Name == ReverseProxyServerComponent </span><span class="cov8" title="1">{
                        for _, env := range component.Envs </span><span class="cov8" title="1">{
                                if env.Name == "X_CSI_REVPROXY_PORT" </span><span class="cov8" title="1">{
                                        proxyPort = env.Value
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">yamlString = strings.ReplaceAll(yamlString, operatorutils.DefaultReleaseName, cr.Name)
        yamlString = strings.ReplaceAll(yamlString, ReverseProxyPort, proxyPort)
        yamlString = strings.ReplaceAll(yamlString, operatorutils.DefaultReleaseNamespace, cr.Namespace)
        yamlString = strings.ReplaceAll(yamlString, ReverseProxyCSMNameSpace, cr.Namespace)

        return yamlString, nil</span>
}

// getReverseProxyDeployment - updates deployment manifest with reverseproxy CRD values
func getReverseProxyDeployment(op operatorutils.OperatorConfig, cr csmv1.ContainerStorageModule) (string, error) <span class="cov8" title="1">{
        YamlString := ""
        revProxy, err := getReverseProxyModule(cr)
        if err != nil </span><span class="cov8" title="1">{
                return YamlString, err
        }</span>

        <span class="cov8" title="1">deploymentPath := fmt.Sprintf("%s/moduleconfig/%s/%s/%s", op.ConfigDirectory, csmv1.ReverseProxy, revProxy.ConfigVersion, ReverseProxyDeployment)
        buf, err := os.ReadFile(filepath.Clean(deploymentPath))
        if err != nil </span><span class="cov0" title="0">{
                return YamlString, err
        }</span>

        <span class="cov8" title="1">YamlString = string(buf)
        proxyNamespace := cr.Namespace
        proxyTLSSecret := RevProxyTLSSecretDefaultName
        proxyPort := RevProxyDefaultPort
        proxyConfig := RevProxyConfigMapDeafultName
        image := op.K8sVersion.Images.CSIRevProxy

        for _, component := range revProxy.Components </span><span class="cov8" title="1">{
                if component.Name == ReverseProxyServerComponent </span><span class="cov8" title="1">{
                        if string(component.Image) != "" </span><span class="cov8" title="1">{
                                image = string(component.Image)
                        }</span>
                        <span class="cov8" title="1">for _, env := range component.Envs </span><span class="cov8" title="1">{
                                if env.Name == "X_CSI_REVPROXY_TLS_SECRET" </span><span class="cov8" title="1">{
                                        proxyTLSSecret = env.Value
                                }</span>
                                <span class="cov8" title="1">if env.Name == "X_CSI_REVPROXY_PORT" </span><span class="cov8" title="1">{
                                        proxyPort = env.Value
                                }</span>
                                <span class="cov8" title="1">if env.Name == "X_CSI_CONFIG_MAP_NAME" </span><span class="cov8" title="1">{
                                        proxyConfig = env.Value
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">YamlString = strings.ReplaceAll(YamlString, ReverseProxyImage, image)
        YamlString = strings.ReplaceAll(YamlString, operatorutils.DefaultReleaseNamespace, proxyNamespace)
        YamlString = strings.ReplaceAll(YamlString, ReverseProxyPort, proxyPort)
        YamlString = strings.ReplaceAll(YamlString, ReverseProxyTLSSecret, proxyTLSSecret)
        YamlString = strings.ReplaceAll(YamlString, ReverseProxyConfigMap, proxyConfig)
        YamlString = strings.ReplaceAll(YamlString, ReverseProxyCSMNameSpace, cr.Namespace)

        return YamlString, nil</span>
}

// ReverseProxyInjectDeployment injects reverseproxy container as sidecar into controller
func ReverseProxyInjectDeployment(dp v1.DeploymentApplyConfiguration, cr csmv1.ContainerStorageModule, op operatorutils.OperatorConfig) (*v1.DeploymentApplyConfiguration, error) <span class="cov8" title="1">{
        revProxyModule, containerPtr, err := getRevproxyApplyCR(cr, op)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">container := *containerPtr
        // update the image
        for _, side := range revProxyModule.Components </span><span class="cov8" title="1">{
                if side.Name == ReverseProxyServerComponent </span><span class="cov8" title="1">{
                        if side.Image != "" </span><span class="cov8" title="1">{
                                *container.Image = string(side.Image)
                        }</span>
                }
        }
        <span class="cov8" title="1">dp.Spec.Template.Spec.Containers = append(dp.Spec.Template.Spec.Containers, container)
        // inject revProxy ENVs in driver environment
        revProxyPort := getRevProxyPort(*revProxyModule)
        for i, cnt := range dp.Spec.Template.Spec.Containers </span><span class="cov8" title="1">{
                if *cnt.Name == "driver" </span><span class="cov8" title="1">{
                        dp.Spec.Template.Spec.Containers[i].Env = append(dp.Spec.Template.Spec.Containers[i].Env,
                                acorev1.EnvVarApplyConfiguration{Name: &amp;CSIPmaxRevProxyPort, Value: &amp;revProxyPort},
                        )
                        break</span>
                }
        }

        // Dynamic secret/configMap mounting is only supported in v2.14.0 and above
        <span class="cov8" title="1">secretSupported, err := operatorutils.MinVersionCheck(drivers.PowerMaxMountCredentialMinVersion, cr.Spec.Driver.ConfigVersion)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">useSecret := drivers.UseReverseProxySecret(&amp;cr)
        if secretSupported &amp;&amp; useSecret </span><span class="cov8" title="1">{
                err = drivers.DynamicallyMountPowermaxContent(&amp;dp, cr)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">if !useSecret </span><span class="cov8" title="1">{
                setReverseProxyConfigMapMounts(&amp;dp, *revProxyModule, cr)
        }</span>

        <span class="cov8" title="1">return &amp;dp, nil</span>
}

func UpdatePowerMaxConfigMap(cm *corev1.ConfigMap, cr csmv1.ContainerStorageModule) <span class="cov8" title="1">{
        if drivers.UseReverseProxySecret(&amp;cr) </span><span class="cov8" title="1">{
                data := cm.Data[drivers.ConfigParamsFile]

                port := RevProxyDefaultPort
                reverseProxy, err := getReverseProxyModule(cr)
                if err == nil </span><span class="cov8" title="1">{
                        // Not minimal manifest, retrieve the port from the reverse proxy
                        port = getRevProxyPort(reverseProxy)
                }</span>

                <span class="cov8" title="1">data += fmt.Sprintf("\n%s: %s", "CSI_POWERMAX_REVERSE_PROXY_PORT", port)

                // Dynamically update the configMap with the reverse proxy port
                cm.Data[drivers.ConfigParamsFile] = data</span>
        }
}

func deploymentSetReverseProxySecretMounts(dp *appsv1.Deployment, secretName string) <span class="cov8" title="1">{
        optional := false

        // Add Secret Volume for Reverse Proxy
        dp.Spec.Template.Spec.Volumes = append(dp.Spec.Template.Spec.Volumes,
                corev1.Volume{
                        Name:         drivers.CSIPowerMaxSecretVolumeName,
                        VolumeSource: corev1.VolumeSource{Secret: &amp;corev1.SecretVolumeSource{SecretName: secretName, Optional: &amp;optional}},
                })

        // Add Config Params Volume for Reverse Proxy
        configParamsVolume := corev1.Volume{
                Name: drivers.PowerMaxConfigParamsVolumeMount,
                VolumeSource: corev1.VolumeSource{
                        ConfigMap: &amp;corev1.ConfigMapVolumeSource{
                                LocalObjectReference: corev1.LocalObjectReference{
                                        Name: drivers.PowerMaxConfigParamsVolumeMount,
                                },
                                Optional: &amp;optional,
                        },
                },
        }
        dp.Spec.Template.Spec.Volumes = append(dp.Spec.Template.Spec.Volumes, configParamsVolume)

        // Adding volume mount for both the reverseproxy and driver
        for i, cnt := range dp.Spec.Template.Spec.Containers </span><span class="cov8" title="1">{
                if cnt.Name == RevProxyServiceName </span><span class="cov8" title="1">{
                        for _, mount := range drivers.MountCredentialsVolumeMounts </span><span class="cov8" title="1">{
                                dp.Spec.Template.Spec.Containers[i].VolumeMounts = append(dp.Spec.Template.Spec.Containers[i].VolumeMounts,
                                        corev1.VolumeMount{
                                                Name:      mount.Name,
                                                MountPath: mount.Value,
                                        })
                        }</span>

                        <span class="cov8" title="1">for _, env := range drivers.MountCredentialsEnvs </span><span class="cov8" title="1">{
                                dp.Spec.Template.Spec.Containers[i].Env = append(dp.Spec.Template.Spec.Containers[i].Env, corev1.EnvVar{
                                        Name:  env.Name,
                                        Value: env.Value,
                                })
                        }</span>
                        <span class="cov8" title="1">break</span>
                }
        }
}

func setReverseProxyConfigMapMounts(dp *v1.DeploymentApplyConfiguration, revProxyModule csmv1.Module, cr csmv1.ContainerStorageModule) <span class="cov8" title="1">{
        // inject revProxy volumes in driver volumes
        revProxyVolume := getRevProxyVolumeComp(revProxyModule)
        dp.Spec.Template.Spec.Volumes = append(dp.Spec.Template.Spec.Volumes, revProxyVolume...)
        volumeMount := acorev1.VolumeMountApplyConfiguration{Name: &amp;RevProxyConfigMapVolName, MountPath: &amp;RevProxyConfigMapMountPath}

        secretName := cr.Name + "-creds"
        if cr.Spec.Driver.AuthSecret != "" </span><span class="cov8" title="1">{
                secretName = cr.Spec.Driver.AuthSecret
        }</span>

        // Adding volume mount
        <span class="cov8" title="1">for i, cnt := range dp.Spec.Template.Spec.Containers </span><span class="cov8" title="1">{
                if *cnt.Name == "reverseproxy" </span><span class="cov8" title="1">{
                        contains := slices.ContainsFunc(dp.Spec.Template.Spec.Containers[i].VolumeMounts,
                                func(v acorev1.VolumeMountApplyConfiguration) bool </span><span class="cov8" title="1">{
                                        // Cast to pull out value instead of comparing addresses.
                                        return *(v.Name) == *(volumeMount.Name)
                                }</span>,
                        )

                        <span class="cov8" title="1">if !contains </span><span class="cov8" title="1">{
                                dp.Spec.Template.Spec.Containers[i].VolumeMounts = append(dp.Spec.Template.Spec.Containers[i].VolumeMounts,
                                        acorev1.VolumeMountApplyConfiguration{Name: &amp;RevProxyConfigMapVolName, MountPath: &amp;RevProxyConfigMapMountPath})
                        }</span>
                } else<span class="cov8" title="1"> if *cnt.Name == "driver" </span><span class="cov8" title="1">{
                        drivers.SetPowermaxConfigContent(&amp;dp.Spec.Template.Spec.Containers[i], secretName)
                }</span>
        }
}

func deploymentSetReverseProxyConfigMapMounts(dp *appsv1.Deployment, cmName string) <span class="cov8" title="1">{
        optional := true
        volume := corev1.Volume{
                Name: RevProxyConfigMapVolName,
                VolumeSource: corev1.VolumeSource{
                        ConfigMap: &amp;corev1.ConfigMapVolumeSource{
                                LocalObjectReference: corev1.LocalObjectReference{
                                        Name: cmName,
                                },
                                Optional: &amp;optional,
                        },
                },
        }
        volumeMount := corev1.VolumeMount{Name: RevProxyConfigMapVolName, MountPath: RevProxyConfigMapMountPath}

        contains := slices.ContainsFunc(dp.Spec.Template.Spec.Volumes, func(v corev1.Volume) bool </span><span class="cov8" title="1">{ return v.Name == volume.Name }</span>)
        <span class="cov8" title="1">if !contains </span><span class="cov8" title="1">{
                dp.Spec.Template.Spec.Volumes = append(dp.Spec.Template.Spec.Volumes, volume)
        }</span>

        // Adding volume mount
        <span class="cov8" title="1">for i, cnt := range dp.Spec.Template.Spec.Containers </span><span class="cov8" title="1">{
                if cnt.Name == RevProxyServiceName </span><span class="cov8" title="1">{
                        contains := slices.ContainsFunc(dp.Spec.Template.Spec.Containers[i].VolumeMounts,
                                func(v corev1.VolumeMount) bool </span><span class="cov8" title="1">{ return v.Name == volumeMount.Name }</span>,
                        )
                        <span class="cov8" title="1">if !contains </span><span class="cov8" title="1">{
                                dp.Spec.Template.Spec.Containers[i].VolumeMounts = append(dp.Spec.Template.Spec.Containers[i].VolumeMounts, volumeMount)
                        }</span>

                        <span class="cov8" title="1">break</span>
                }
        }
}

func getRevProxyPort(revProxyModule csmv1.Module) string <span class="cov8" title="1">{
        revProxyPort := RevProxyDefaultPort
        for _, component := range revProxyModule.Components </span><span class="cov8" title="1">{
                if component.Name == ReverseProxyServerComponent </span><span class="cov8" title="1">{
                        for _, env := range component.Envs </span><span class="cov8" title="1">{
                                if env.Name == "X_CSI_REVPROXY_PORT" </span><span class="cov8" title="1">{
                                        revProxyPort = env.Value
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return revProxyPort</span>
}

func getRevProxyEnvVariable(revProxyModule csmv1.Module, envVar string) string <span class="cov8" title="1">{
        val := ""
        for _, component := range revProxyModule.Components </span><span class="cov8" title="1">{
                if component.Name == ReverseProxyServerComponent </span><span class="cov8" title="1">{
                        for _, env := range component.Envs </span><span class="cov8" title="1">{
                                if env.Name == envVar </span><span class="cov8" title="1">{
                                        val = env.Value
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return val</span>
}

func getRevProxyVolumeComp(revProxyModule csmv1.Module) []acorev1.VolumeApplyConfiguration <span class="cov8" title="1">{
        revProxyConfigMap, revProxyTLSSecret := RevProxyConfigMapDeafultName, RevProxyTLSSecretDefaultName
        for _, component := range revProxyModule.Components </span><span class="cov8" title="1">{
                if component.Name == ReverseProxyServerComponent </span><span class="cov8" title="1">{
                        for _, env := range component.Envs </span><span class="cov8" title="1">{
                                if env.Name == "X_CSI_CONFIG_MAP_NAME" </span><span class="cov8" title="1">{
                                        revProxyConfigMap = env.Value
                                }</span>
                                <span class="cov8" title="1">if env.Name == "X_CSI_REVPROXY_TLS_SECRET" </span><span class="cov8" title="1">{
                                        revProxyTLSSecret = env.Value
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">optional := true
        revProxyVolumes := []acorev1.VolumeApplyConfiguration{
                {
                        Name: &amp;RevProxyConfigMapVolName,
                        VolumeSourceApplyConfiguration: acorev1.VolumeSourceApplyConfiguration{
                                ConfigMap: &amp;acorev1.ConfigMapVolumeSourceApplyConfiguration{
                                        LocalObjectReferenceApplyConfiguration: acorev1.LocalObjectReferenceApplyConfiguration{Name: &amp;revProxyConfigMap},
                                        Optional:                               &amp;optional,
                                },
                        },
                },
        }

        // Volume tls-secret should be added only of version is older than 2.12.0
        isNewReverProxy, _ := operatorutils.MinVersionCheck("v2.12.0", revProxyModule.ConfigVersion)
        if revProxyModule.ConfigVersion != "" &amp;&amp; !isNewReverProxy </span><span class="cov0" title="0">{
                revProxyVolumes = append(revProxyVolumes, []acorev1.VolumeApplyConfiguration{
                        {
                                Name: &amp;RevProxyTLSSecretVolName,
                                VolumeSourceApplyConfiguration: acorev1.VolumeSourceApplyConfiguration{
                                        Secret: &amp;acorev1.SecretVolumeSourceApplyConfiguration{
                                                SecretName: &amp;revProxyTLSSecret,
                                        },
                                },
                        },
                }...)
        }</span>

        <span class="cov8" title="1">return revProxyVolumes</span>
}

// returns revproxy module and container
func getRevproxyApplyCR(cr csmv1.ContainerStorageModule, op operatorutils.OperatorConfig) (*csmv1.Module, *acorev1.ContainerApplyConfiguration, error) <span class="cov8" title="1">{
        var err error
        revProxyModule := cr.GetModule(csmv1.ReverseProxy)

        // This is necessary for the minimal manifest, where the reverse proxy will not be included in the CSM CR.
        if len(revProxyModule.Name) == 0 </span><span class="cov0" title="0">{
                revProxyModule.Name = csmv1.ReverseProxy
        }</span>

        <span class="cov8" title="1">buf, err := readConfigFile(revProxyModule, cr, op, ReverseProxySidecar)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">YamlString := operatorutils.ModifyCommonCR(string(buf), cr)
        var container acorev1.ContainerApplyConfiguration
        err = yaml.Unmarshal([]byte(YamlString), &amp;container)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov8" title="1">return &amp;revProxyModule, &amp;container, nil</span>
}

func AddReverseProxyServiceName(dp *v1.DeploymentApplyConfiguration) <span class="cov8" title="1">{
        for i, cnt := range dp.Spec.Template.Spec.Containers </span><span class="cov8" title="1">{
                if *cnt.Name == "driver" </span><span class="cov8" title="1">{
                        dp.Spec.Template.Spec.Containers[i].Env = append(dp.Spec.Template.Spec.Containers[i].Env,
                                acorev1.EnvVarApplyConfiguration{Name: &amp;CSIPmaxRevProxyServiceName, Value: &amp;RevProxyServiceName},
                        )
                        break</span>
                }
        }
}

var IsReverseProxySidecar = func() bool <span class="cov8" title="1">{
        return deployAsSidecar
}</span>

func ResetDeployAsSidecar() <span class="cov8" title="1">{
        deployAsSidecar = true
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
